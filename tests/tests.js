// Generated by CoffeeScript 1.6.2
(function() {
  var globals;

  globals = this;

  describe("gamEvolve", function() {
    beforeEach(function() {
      return this.addMatchers({
        toDeeplyEqual: function(expected) {
          return _.isEqual(this.actual, expected);
        },
        toBeEmpty: function(expected) {
          return expected.length === 0;
        }
      });
    });
    describe("model", function() {
      it("can be created empty", function() {
        var model;

        model = new GE.Model();
        expect(model.version).toEqual(0);
        return expect(model.data).toDeeplyEqual({});
      });
      it("can be created with data", function() {
        var model;

        model = new GE.Model({
          a: 1,
          b: 2
        });
        expect(model.version).toEqual(0);
        return expect(model.data).toDeeplyEqual({
          a: 1,
          b: 2
        });
      });
      it("can be patched", function() {
        var newData, newModel, oldData, oldModel, patches;

        oldData = {
          a: 1,
          b: {
            b1: true,
            b2: "hi"
          }
        };
        newData = {
          b: {
            b1: true,
            b2: "there"
          },
          c: {
            bob: "is cool"
          }
        };
        patches = GE.makePatches(oldData, newData);
        oldModel = new GE.Model(oldData);
        newModel = oldModel.applyPatches(patches);
        expect(oldModel.version).toEqual(0);
        expect(oldModel.data).toDeeplyEqual(oldData);
        expect(newModel.version).toEqual(1);
        return expect(newModel.data).toDeeplyEqual(newData);
      });
      it("rejects conflicting patches", function() {
        var newDataA, newDataB, oldData, oldModel, patchesA, patchesB;

        oldData = {
          a: 1
        };
        newDataA = {
          a: 2
        };
        newDataB = {
          b: 3
        };
        patchesA = GE.makePatches(oldData, newDataA);
        patchesB = GE.makePatches(oldData, newDataB);
        oldModel = new GE.Model(oldData);
        return expect(function() {
          return oldModel.applyPatches(_.flatten([patchesA, patchesB]));
        }).toThrow();
      });
      return it("can be retrieved at a given version", function() {
        var model, v0, v1, v2;

        v0 = {
          a: 0
        };
        v1 = {
          a: 1
        };
        v2 = {
          a: 2
        };
        model = new GE.Model(v0).setData(v1).setData(v2);
        expect(model.clonedData()).toDeeplyEqual(v2);
        expect(model.version).toBe(2);
        expect(model.atVersion(1).clonedData()).toDeeplyEqual(v1);
        expect(model.atVersion(1).version).toBe(1);
        expect(model.atVersion(0).clonedData()).toDeeplyEqual(v0);
        return expect(model.atVersion(0).version).toBe(0);
      });
    });
    return describe("runSteps", function() {
      it("calls functions", function() {
        var layout;

        globals.testFunction = jasmine.createSpy();
        layout = {
          call: "testFunction",
          params: [1, 2]
        };
        GE.runStep(new GE.Model(), null, null, layout);
        return expect(globals.testFunction).toHaveBeenCalledWith(1, 2);
      });
      it("calls actions", function() {
        var actions, isCalled, layout;

        isCalled = false;
        actions = {
          doNothing: {
            paramDefs: {
              x: 1,
              y: "z"
            },
            update: function() {
              isCalled = true;
              expect(arguments.length).toEqual(0);
              return expect(this.params).toDeeplyEqual({
                x: 2,
                y: "z"
              });
            }
          }
        };
        layout = {
          action: "doNothing",
          params: {
            x: 2,
            y: "z"
          }
        };
        GE.runStep(new GE.Model(), null, actions, layout);
        return expect(isCalled).toBeTruthy();
      });
      it("calls children of actions", function() {
        var actions, layout, timesCalled;

        timesCalled = 0;
        actions = {
          doNothing: {
            paramDefs: {},
            update: function() {
              return timesCalled++;
            }
          }
        };
        layout = {
          action: "doNothing",
          params: {},
          children: [
            {
              action: "doNothing",
              params: {}
            }, {
              action: "doNothing",
              params: {}
            }
          ]
        };
        GE.runStep(new GE.Model(), null, actions, layout);
        return expect(timesCalled).toEqual(3);
      });
      it("evaluates parameters for functions", function() {
        var assets, layout, model;

        model = new GE.Model({
          person: {
            firstName: "bob"
          }
        });
        assets = {
          image: new Image()
        };
        globals.testFunction = jasmine.createSpy();
        layout = {
          bind: {
            select: {
              lastName: "jon"
            }
          },
          children: [
            {
              call: "testFunction",
              params: ["@model:person.firstName", "model", "$lastName", "@asset:image"]
            }
          ]
        };
        GE.runStep(model, assets, null, layout);
        return expect(globals.testFunction).toHaveBeenCalledWith("bob", "model", "jon", assets.image);
      });
      it("evaluates parameters for actions", function() {
        var actions, assets, layout, newModel, oldModel, patches, result, _ref;

        oldModel = new GE.Model({
          a: 1,
          b: 10,
          c: 20
        });
        assets = {
          image: new Image()
        };
        actions = {
          adjustModel: {
            paramDefs: {
              x: null,
              y: null,
              z: null,
              d: 2,
              e: null
            },
            update: function() {
              this.params.x++;
              this.params.y--;
              this.params.z = 30;
              expect(this.params.d).toBe(2);
              return expect(this.params.e).toBe(assets.image);
            }
          }
        };
        layout = {
          bind: {
            select: {
              c: "@model:b",
              z: "@model:c",
              e: "@asset:image"
            }
          },
          children: [
            {
              action: "adjustModel",
              params: {
                x: "@model:a",
                y: "$c"
              }
            }
          ]
        };
        _ref = GE.runStep(oldModel, assets, actions, layout), result = _ref[0], patches = _ref[1];
        newModel = oldModel.applyPatches(patches);
        expect(oldModel.data.a).toBe(1);
        expect(oldModel.data.b).toBe(10);
        expect(oldModel.data.c).toBe(20);
        expect(newModel.data.a).toBe(2);
        expect(newModel.data.b).toBe(9);
        return expect(newModel.data.c).toBe(30);
      });
      it("sets the model", function() {
        var layout, newModel, oldModel, patches, result, _ref;

        oldModel = new GE.Model({
          a: {
            a1: 1
          },
          b: 10,
          c: "hi"
        });
        layout = {
          setModel: {
            "a.a1": 2,
            "b": "@model:c"
          }
        };
        _ref = GE.runStep(oldModel, null, null, layout), result = _ref[0], patches = _ref[1];
        newModel = oldModel.applyPatches(patches);
        expect(oldModel.data.a.a1).toBe(1);
        expect(oldModel.data.b).toBe(10);
        expect(newModel.data.a.a1).toBe(2);
        return expect(newModel.data.b).toBe("hi");
      });
      it("checks and adjusts activation", function() {
        var actions, layout, models, patches, result, _ref, _ref1;

        models = [
          new GE.Model({
            activeChild: 0,
            child0TimesCalled: 0,
            child1TimesCalled: 0
          })
        ];
        actions = {
          nextOnDone: {
            paramDefs: {
              activeChild: 0
            },
            listActiveChildren: function() {
              return [this.params.activeChild];
            },
            handleSignals: function() {
              if (this.signals[this.params.activeChild] === GE.signals.DONE) {
                this.params.activeChild++;
              }
              if (this.params.activeChild >= this.children.length - 1) {
                return GE.signals.DONE;
              }
            }
          },
          reportDone: {
            paramDefs: {
              timesCalled: 0
            },
            update: function() {
              this.params.timesCalled++;
              return GE.signals.DONE;
            }
          }
        };
        layout = {
          action: "nextOnDone",
          params: {
            activeChild: "@model:activeChild"
          },
          children: [
            {
              action: "reportDone",
              params: {
                timesCalled: "@model:child0TimesCalled"
              }
            }, {
              action: "reportDone",
              params: {
                timesCalled: "@model:child1TimesCalled"
              }
            }
          ]
        };
        _ref = GE.runStep(models[0], null, actions, layout), result = _ref[0], patches = _ref[1];
        models[1] = models[0].applyPatches(patches);
        expect(models[1].data.child0TimesCalled).toBe(1);
        expect(models[1].data.child1TimesCalled).toBe(0);
        expect(models[1].data.activeChild).toBe(1);
        _ref1 = GE.runStep(models[1], null, actions, layout), result = _ref1[0], patches = _ref1[1];
        models[2] = models[1].applyPatches(patches);
        expect(models[2].data.child0TimesCalled).toBe(1);
        expect(models[2].data.child1TimesCalled).toBe(1);
        return expect(models[2].data.activeChild).toBe(2);
      });
      it("binds across model arrays", function() {
        var actions, layout, newModel, oldModel, patches, result, _ref;

        oldModel = new GE.Model({
          people: [
            {
              first: "bill",
              last: "bobson"
            }, {
              first: "joe",
              last: "johnson"
            }
          ]
        });
        actions = {
          changeName: {
            paramDefs: {
              newName: "",
              toChange: ""
            },
            update: function() {
              return this.params.toChange = this.params.newName;
            }
          }
        };
        layout = {
          bind: {
            from: {
              person: "@model:people"
            }
          },
          children: [
            {
              action: "changeName",
              params: {
                newName: "$person.first",
                toChange: "$person.last"
              }
            }
          ]
        };
        _ref = GE.runStep(oldModel, null, actions, layout), result = _ref[0], patches = _ref[1];
        newModel = oldModel.applyPatches(patches);
        expect(newModel.data.people[0].last).toBe("bill");
        return expect(newModel.data.people[1].last).toBe("joe");
      });
      return it("binds across constant arrays", function() {
        var layout, oldModel, people, person, _i, _len, _results;

        oldModel = new GE.Model();
        people = [
          {
            first: "bill",
            last: "bobson"
          }, {
            first: "joe",
            last: "johnson"
          }
        ];
        globals.testFunction = jasmine.createSpy();
        layout = {
          bind: {
            from: {
              person: people
            }
          },
          children: [
            {
              call: "testFunction",
              params: ["$person"]
            }
          ]
        };
        GE.runStep(oldModel, null, null, layout);
        _results = [];
        for (_i = 0, _len = people.length; _i < _len; _i++) {
          person = people[_i];
          _results.push(expect(globals.testFunction).toHaveBeenCalledWith(person));
        }
        return _results;
      });
    });
  });

}).call(this);
