// Generated by CoffeeScript 1.3.3
(function() {
  var globals;

  globals = this;

  describe("gamEvolve", function() {
    beforeEach(function() {
      return this.addMatchers({
        toDeeplyEqual: function(expected) {
          return _.isEqual(this.actual, expected);
        },
        toBeEmpty: function() {
          return this.actual.length === 0;
        }
      });
    });
    describe("model", function() {
      it("can be created empty", function() {
        var model;
        model = new GE.Model();
        expect(model.version).toEqual(0);
        return expect(model.data).toDeeplyEqual({});
      });
      it("can be created with data", function() {
        var model;
        model = new GE.Model({
          a: 1,
          b: 2
        });
        expect(model.version).toEqual(0);
        return expect(model.data).toDeeplyEqual({
          a: 1,
          b: 2
        });
      });
      it("can be patched", function() {
        var newData, newModel, oldData, oldModel, patches;
        oldData = {
          a: 1,
          b: {
            b1: true,
            b2: "hi"
          }
        };
        newData = {
          b: {
            b1: true,
            b2: "there"
          },
          c: {
            bob: "is cool"
          }
        };
        patches = GE.makePatches(oldData, newData);
        oldModel = new GE.Model(oldData);
        newModel = oldModel.applyPatches(patches);
        expect(oldModel.version).toEqual(0);
        expect(oldModel.data).toDeeplyEqual(oldData);
        expect(newModel.version).toEqual(1);
        return expect(newModel.data).toDeeplyEqual(newData);
      });
      it("rejects conflicting patches", function() {
        var newDataA, newDataB, oldData, oldModel, patchesA, patchesB;
        oldData = {
          a: 1
        };
        newDataA = {
          a: 2
        };
        newDataB = {
          b: 3
        };
        patchesA = GE.makePatches(oldData, newDataA);
        patchesB = GE.makePatches(oldData, newDataB);
        oldModel = new GE.Model(oldData);
        return expect(function() {
          return oldModel.applyPatches(_.flatten([patchesA, patchesB]));
        }).toThrow();
      });
      return it("can be retrieved at a given version", function() {
        var model, v0, v1, v2;
        v0 = {
          a: 0
        };
        v1 = {
          a: 1
        };
        v2 = {
          a: 2
        };
        model = new GE.Model(v0).setData(v1).setData(v2);
        expect(model.clonedData()).toDeeplyEqual(v2);
        expect(model.version).toBe(2);
        expect(model.atVersion(1).clonedData()).toDeeplyEqual(v1);
        expect(model.atVersion(1).version).toBe(1);
        expect(model.atVersion(0).clonedData()).toDeeplyEqual(v0);
        return expect(model.atVersion(0).version).toBe(0);
      });
    });
    describe("visitNode()", function() {
      it("calls functions", function() {
        var constants, layout;
        globals.testFunction = jasmine.createSpy();
        layout = {
          call: "testFunction",
          params: [1, 2]
        };
        constants = new GE.NodeVisitorConstants({}, {}, {}, {});
        GE.visitNode(layout, constants, {});
        return expect(globals.testFunction).toHaveBeenCalledWith(1, 2);
      });
      it("calls actions", function() {
        var actions, constants, isCalled, layout;
        isCalled = false;
        actions = {
          doNothing: {
            paramDefs: {
              x: 1,
              y: "z"
            },
            update: function() {
              isCalled = true;
              expect(arguments.length).toEqual(0);
              return expect(this.params).toDeeplyEqual({
                x: 2,
                y: "z"
              });
            }
          }
        };
        layout = {
          action: "doNothing",
          params: {
            x: 2,
            y: "z"
          }
        };
        constants = new GE.NodeVisitorConstants({}, {}, {}, actions);
        GE.visitNode(layout, constants, {});
        return expect(isCalled).toBeTruthy();
      });
      it("calls children of actions", function() {
        var actions, constants, layout, timesCalled;
        timesCalled = 0;
        actions = {
          doNothing: {
            paramDefs: {},
            update: function() {
              return timesCalled++;
            }
          }
        };
        layout = {
          action: "doNothing",
          params: {},
          children: [
            {
              action: "doNothing",
              params: {}
            }, {
              action: "doNothing",
              params: {}
            }
          ]
        };
        constants = new GE.NodeVisitorConstants({}, {}, {}, actions);
        GE.visitNode(layout, constants, {});
        return expect(timesCalled).toEqual(3);
      });
      it("evaluates parameters for functions", function() {
        var assets, constants, layout, model;
        model = {
          person: {
            firstName: "bob"
          }
        };
        assets = {
          image: new Image()
        };
        globals.testFunction = jasmine.createSpy();
        layout = {
          bind: {
            select: {
              lastName: "jon"
            }
          },
          children: [
            {
              call: "testFunction",
              params: ["@model:person.firstName", "model", "$lastName", "@asset:image"]
            }
          ]
        };
        constants = new GE.NodeVisitorConstants(model, {}, assets, {});
        GE.visitNode(layout, constants, {});
        return expect(globals.testFunction).toHaveBeenCalledWith("bob", "model", "jon", assets.image);
      });
      it("evaluates parameters for actions", function() {
        var actions, assets, constants, layout, newModel, oldModel, results;
        oldModel = {
          a: 1,
          b: 10,
          c: 20
        };
        assets = {
          image: new Image()
        };
        actions = {
          adjustModel: {
            paramDefs: {
              x: null,
              y: null,
              z: null,
              d: 2,
              e: null
            },
            update: function() {
              this.params.x++;
              this.params.y--;
              this.params.z = 30;
              expect(this.params.d).toBe(2);
              return expect(this.params.e).toBe(assets.image);
            }
          }
        };
        layout = {
          bind: {
            select: {
              c: "@model:b",
              z: "@model:c",
              e: "@asset:image"
            }
          },
          children: [
            {
              action: "adjustModel",
              params: {
                x: "@model:a",
                y: "$c"
              }
            }
          ]
        };
        constants = new GE.NodeVisitorConstants(oldModel, {}, assets, actions);
        results = GE.visitNode(layout, constants, {});
        newModel = GE.applyPatches(results.modelPatches, oldModel);
        expect(oldModel.a).toBe(1);
        expect(oldModel.b).toBe(10);
        expect(oldModel.c).toBe(20);
        expect(newModel.a).toBe(2);
        expect(newModel.b).toBe(9);
        return expect(newModel.c).toBe(30);
      });
      it("sets the model", function() {
        var constants, layout, newModel, oldModel, results;
        oldModel = {
          a: {
            a1: 1
          },
          b: 10,
          c: "hi"
        };
        layout = {
          setModel: {
            "a.a1": 2,
            "b": "@model:c"
          }
        };
        constants = new GE.NodeVisitorConstants(oldModel, {}, {}, {});
        results = GE.visitNode(layout, constants, {});
        newModel = GE.applyPatches(results.modelPatches, oldModel);
        expect(oldModel.a.a1).toBe(1);
        expect(oldModel.b).toBe(10);
        expect(newModel.a.a1).toBe(2);
        return expect(newModel.b).toBe("hi");
      });
      it("checks and adjusts activation", function() {
        var actions, constants, layout, models, results;
        models = [
          {
            activeChild: 0,
            child0TimesCalled: 0,
            child1TimesCalled: 0
          }
        ];
        actions = {
          nextOnDone: {
            paramDefs: {
              activeChild: 0
            },
            listActiveChildren: function() {
              return [this.params.activeChild];
            },
            handleSignals: function() {
              if (this.signals[this.params.activeChild] === GE.signals.DONE) {
                this.params.activeChild++;
              }
              if (this.params.activeChild >= this.children.length - 1) {
                return GE.signals.DONE;
              }
            }
          },
          reportDone: {
            paramDefs: {
              timesCalled: 0
            },
            update: function() {
              this.params.timesCalled++;
              return GE.signals.DONE;
            }
          }
        };
        layout = {
          action: "nextOnDone",
          params: {
            activeChild: "@model:activeChild"
          },
          children: [
            {
              action: "reportDone",
              params: {
                timesCalled: "@model:child0TimesCalled"
              }
            }, {
              action: "reportDone",
              params: {
                timesCalled: "@model:child1TimesCalled"
              }
            }
          ]
        };
        constants = new GE.NodeVisitorConstants(models[0], {}, {}, actions);
        results = GE.visitNode(layout, constants, {});
        models[1] = GE.applyPatches(results.modelPatches, models[0]);
        expect(models[1].child0TimesCalled).toBe(1);
        expect(models[1].child1TimesCalled).toBe(0);
        expect(models[1].activeChild).toBe(1);
        constants = new GE.NodeVisitorConstants(models[1], {}, {}, actions);
        results = GE.visitNode(layout, constants, {});
        models[2] = GE.applyPatches(results.modelPatches, models[1]);
        expect(models[2].child0TimesCalled).toBe(1);
        expect(models[2].child1TimesCalled).toBe(1);
        return expect(models[2].activeChild).toBe(2);
      });
      it("binds across model arrays", function() {
        var actions, constants, layout, newModel, oldModel, results;
        oldModel = {
          people: [
            {
              first: "bill",
              last: "bobson"
            }, {
              first: "joe",
              last: "johnson"
            }
          ]
        };
        actions = {
          changeName: {
            paramDefs: {
              newName: "",
              toChange: ""
            },
            update: function() {
              return this.params.toChange = this.params.newName;
            }
          }
        };
        layout = {
          bind: {
            from: {
              person: "@model:people"
            }
          },
          children: [
            {
              action: "changeName",
              params: {
                newName: "$person.first",
                toChange: "$person.last"
              }
            }
          ]
        };
        constants = new GE.NodeVisitorConstants(oldModel, {}, {}, actions);
        results = GE.visitNode(layout, constants, {});
        newModel = GE.applyPatches(results.modelPatches, oldModel);
        expect(newModel.people[0].last).toBe("bill");
        return expect(newModel.people[1].last).toBe("joe");
      });
      return it("communicates with services", function() {
        var actions, constants, layout, newServiceData, oldServiceData, results;
        oldServiceData = {
          serviceA: {
            a: 1
          }
        };
        actions = {
          incrementServiceData: {
            paramDefs: {
              service: ""
            },
            update: function() {
              expect(this.params.service.a).toBe(1);
              return this.params.service.a++;
            }
          }
        };
        layout = {
          action: "incrementServiceData",
          params: {
            service: "@service:serviceA"
          }
        };
        constants = new GE.NodeVisitorConstants({}, oldServiceData, {}, actions);
        results = GE.visitNode(layout, constants, {});
        newServiceData = GE.applyPatches(results.servicePatches, oldServiceData);
        return expect(newServiceData.serviceA.a).toBe(2);
      });
    });
    return describe("stepLoop()", function() {
      it("sends output data directly to services", function() {
        var a, modelPatches, outputServiceData, services;
        services = {
          myService: {
            establishData: jasmine.createSpy()
          }
        };
        outputServiceData = {
          myService: a = 1
        };
        modelPatches = GE.stepLoop(null, {}, {}, {}, services, null, null, outputServiceData);
        expect(services.myService.establishData).toHaveBeenCalledWith(outputServiceData.myService, {});
        return expect(modelPatches).toBeEmpty();
      });
      it("send service input data to visitNode", function() {
        var actions, inputServiceData, layout, modelPatches, services;
        services = {
          myService: {
            establishData: jasmine.createSpy()
          }
        };
        inputServiceData = {
          myService: {
            a: 1
          }
        };
        actions = {
          incrementServiceData: {
            paramDefs: {
              service: ""
            },
            update: function() {
              expect(this.params.service.a).toBe(1);
              return this.params.service.a++;
            }
          }
        };
        layout = {
          action: "incrementServiceData",
          params: {
            service: "@service:myService"
          }
        };
        modelPatches = GE.stepLoop(layout, {}, {}, actions, services, null, inputServiceData);
        expect(services.myService.establishData).toHaveBeenCalledWith({
          a: 2
        }, {});
        return expect(modelPatches).toBeEmpty();
      });
      return it("gathers service input data, visits nodes, and gives output to services", function() {
        var actions, layout, modelPatches, services;
        services = {
          myService: {
            provideData: function() {
              return {
                a: 1
              };
            },
            establishData: jasmine.createSpy()
          }
        };
        spyOn(services.myService, "provideData").andCallThrough();
        actions = {
          incrementServiceData: {
            paramDefs: {
              service: ""
            },
            update: function() {
              expect(this.params.service.a).toBe(1);
              return this.params.service.a++;
            }
          }
        };
        layout = {
          action: "incrementServiceData",
          params: {
            service: "@service:myService"
          }
        };
        modelPatches = GE.stepLoop(layout, {}, {}, actions, services);
        expect(services.myService.provideData).toHaveBeenCalledWith({});
        expect(services.myService.establishData).toHaveBeenCalledWith({
          a: 2
        }, {});
        return expect(modelPatches).toBeEmpty();
      });
    });
  });

}).call(this);
