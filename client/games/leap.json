{
  "name": "leap",
  "fileVersion": 0.1,
  "memory": {
    "blocks": [],
    "mouseDetection": {
      "state": null,
      "dragStartPosition": null,
      "shape": null
    },
    "activeChild": 0,
    "gridTranslation": [
      0,
      0
    ],
    "targetGridTranslation": null,
    "ageForm": {
      "gender": "male",
      "age": 33,
      "done": false
    },
    "blocksForm": {
      "done": false
    },
    "gallery": [],
    "selectionGrids": [],
    "selectedGalleryIndexes": [],
    "blockGroupsToBeHighlighted": [],
    "highlightedBlocks": [],
    "dragFrameCounter": 0,
    "events": [],
    "constants": {
      "grid": {
        "type": "infinite",
        "upperLeft": [
          205,
          0
        ],
        "cellSize": [
          55,
          55
        ],
        "gridSize": [
          10,
          10
        ]
      },
      "galleryGrid": {
        "type": "infinite",
        "upperLeft": [
          800,
          10
        ],
        "cellSize": [
          15,
          15
        ],
        "gridSize": [
          10,
          10
        ]
      },
      "selectionGrid": {
        "type": "fixed",
        "upperLeft": [
          30,
          50
        ],
        "cellSize": [
          150,
          150
        ],
        "gridSize": [
          6,
          3
        ]
      },
      "initialBlocks": [
        [
          0,
          0
        ],
        [
          1,
          0
        ],
        [
          2,
          0
        ],
        [
          3,
          0
        ],
        [
          4,
          0
        ],
        [
          5,
          0
        ],
        [
          6,
          0
        ],
        [
          7,
          0
        ],
        [
          8,
          0
        ],
        [
          9,
          0
        ]
      ],
      "blockColor": [
        129,
        231,
        0
      ],
      "highlightedBlockColor": [
        89,
        133,
        59
      ],
      "dragHighlightPeriod": 30,
      "blockSize": [
        50,
        50
      ],
      "galleryBlockSize": [
        12,
        12
      ],
      "minGridTranslation": 1
    }
  },
  "io": {
    "layers": [
      {
        "name": "bg",
        "type": "canvas"
      },
      {
        "name": "gallery",
        "type": "canvas"
      },
      {
        "name": "blocks",
        "type": "canvas"
      },
      {
        "name": "drag",
        "type": "canvas"
      },
      {
        "name": "html",
        "type": "html"
      }
    ]
  },
  "board": {
    "children": [
      {
        "emitter": {
          "io.canvas.shapes": "transformers.drawShape({ type: 'rectangle', layer: 'bg', position: [0, 0], size: io.canvas.size, fillStyle: 'black' })"
        }
      },
      {
        "pins": {
          "in": {
            "activeChild": "memory.activeChild"
          },
          "out": {
            "memory.activeChild": "pins.activeChild"
          }
        },
        "children": [
          {
            "emitter": {
              "memory.blocks": "memory.constants.initialBlocks",
              "memory.gallery": "[]",
              "memory.selectedGalleryIndexes": "[]",
              "memory.events": "[{ type: 'began game', time: transformers.makeTimestamp(io.time) }]"
            }
          },
          {
            "pins": {
              "in": {
                "value": "!memory.ageForm.done"
              }
            },
            "children": [
              {
                "pins": {
                  "in": {
                    "htmlService": "io.html",
                    "memoryValues": "memory.ageForm",
                    "assetName": "'form'",
                    "templateName": "'ageForm'"
                  },
                  "out": {
                    "io.html": "pins.htmlService",
                    "memory.ageForm": "pins.memoryValues"
                  }
                },
                "processor": "updateHtmlTemplate"
              }
            ],
            "switch": "doWhile"
          },
          {
            "emitter": {
              "memory.events": "GE.appendToArray(memory.events, { type: 'filled form', time: transformers.makeTimestamp(io.time) })"
            }
          },
          {
            "pins": {
              "in": {
                "value": "!io.html.receive.blocksForm || !io.html.receive.blocksForm.values.done"
              }
            },
            "children": [
              {
                "pins": {
                  "in": {
                    "shapes": "transformers.translateShapes(transformers.inverseVector(memory.gridTranslation), transformers.makeMovableBlockShapes(memory.constants.grid, memory.blocks, transformers.rgbColorString(memory.constants.blockColor), memory.constants.blockSize))",
                    "shape": "memory.mouseDetection.shape",
                    "mousePosition": "io.mouse.position",
                    "mouseDown": "io.mouse.down",
                    "state": "memory.mouseDetection.state",
                    "dragStartPosition": "memory.mouseDetection.dragStartPosition"
                  },
                  "out": {
                    "memory.mouseDetection.state": "pins.state",
                    "memory.mouseDetection.dragStartPosition": "pins.dragStartPosition",
                    "memory.mouseDetection.shape": "pins.shape"
                  }
                },
                "processor": "detectMouse"
              },
              {
                "emitter": {
                  "io.canvas.shapes": "transformers.drawShapes(transformers.translateShapes(transformers.inverseVector(memory.gridTranslation), transformers.makeBlockShapes(memory.constants.grid, GE.difference(memory.blocks, memory.highlightedBlocks), transformers.rgbColorString(memory.constants.blockColor), memory.constants.blockSize)))"
                }
              },
              {
                "emitter": {
                  "io.canvas.shapes": "transformers.drawShapes(transformers.translateShapes(transformers.inverseVector(memory.gridTranslation), transformers.makeBlockShapes(memory.constants.grid, memory.highlightedBlocks, transformers.rgbColorString(memory.constants.highlightedBlockColor), memory.constants.blockSize)))"
                }
              },
              {
                "emitter": {
                  "io.canvas.shapes": "transformers.drawShape({ layer: 'gallery', type: 'rectangle', position: memory.constants.galleryGrid.upperLeft, size: transformers.gridSizeInPixels(memory.constants.galleryGrid), fillStyle: 'grey', strokeStyle: 'white' })"
                }
              },
              {
                "emitter": {
                  "memory.targetGridTranslation": "transformers.subtractVectors(transformers.meanOfCoordinates(transformers.listBlockCenters(memory.constants.grid, memory.blocks)), transformers.gridCenter(memory.constants.grid))"
                }
              },
              {
                "pins": {
                  "in": {
                    "value": "memory.targetGridTranslation && transformers.distanceBetweenPoints(memory.gridTranslation, memory.targetGridTranslation) > memory.constants.minGridTranslation"
                  }
                },
                "children": [
                  {
                    "emitter": {
                      "memory.gridTranslation": "transformers.interpolateVector(memory.gridTranslation, memory.targetGridTranslation, 0.5)"
                    }
                  }
                ],
                "switch": "if"
              },
              {
                "pins": {
                  "in": {
                    "value": "memory.mouseDetection.state"
                  }
                },
                "children": [
                  {
                    "name": "drag",
                    "pins": {
                      "in": {
                        "value": "io.mouse.position != null"
                      }
                    },
                    "children": [
                      {
                        "emitter": {
                          "io.mouse.cursor": "'move'",
                          "io.canvas.shapes": "transformers.drawShape(transformers.makeDraggedShape(memory.constants.blockSize, transformers.rgbColorString(transformers.cyclicInterpolate(memory.constants.highlightedBlockColor, memory.constants.blockColor, memory.dragFrameCounter / memory.constants.dragHighlightPeriod)), io.mouse.position))",
                          "memory.dragFrameCounter": "(memory.dragFrameCounter + 1) % memory.constants.dragHighlightPeriod"
                        }
                      }
                    ],
                    "switch": "if"
                  },
                  {
                    "name": "startDrag",
                    "emitter": {
                      "memory.blocks": "GE.removeFromArray(memory.blocks, memory.mouseDetection.shape.meta)",
                      "memory.dragFrameCounter": 0
                    }
                  },
                  {
                    "name": "endDrag",
                    "emitter": {
                      "memory.blockGroupsToBeHighlighted": "transformers.makeBlockGroupsToBeHighlighted(memory.blocks, transformers.findDroppedPosition(memory.constants.grid, memory.blocks, transformers.translatePoint(memory.gridTranslation, io.mouse.position)))",
                      "memory.blocks": "GE.appendToArray(memory.blocks, transformers.findDroppedPosition(memory.constants.grid, memory.blocks, transformers.translatePoint(memory.gridTranslation, io.mouse.position)))",
                      "memory.events": "GE.appendToArray(memory.events, { type: 'moved tile', time: transformers.makeTimestamp(io.time), shape: transformers.serializeBlocks(GE.appendToArray(memory.blocks, transformers.findDroppedPosition(memory.constants.grid, memory.blocks, transformers.translatePoint(memory.gridTranslation, io.mouse.position)))) })"
                    }
                  },
                  {
                    "name": "hover",
                    "emitter": {
                      "io.mouse.cursor": "'pointer'"
                    }
                  }
                ],
                "switch": "when"
              },
              {
                "emitter": {
                  "io.html.send.blocksForm": "{ asset: 'blocksForm', values: { done: false, galleryShapeCount: memory.gallery.length, canAddShape: memory.gallery.length < 12, ready: memory.gallery.length >= 5 } }"
                }
              },
              {
                "pins": {
                  "in": {
                    "value": "memory.blockGroupsToBeHighlighted.length > 0"
                  }
                },
                "children": [
                  {
                    "emitter": {
                      "memory.highlightedBlocks": "_.first(memory.blockGroupsToBeHighlighted)",
                      "memory.blockGroupsToBeHighlighted": "_.rest(memory.blockGroupsToBeHighlighted)"
                    }
                  },
                  {
                    "emitter": {
                      "memory.highlightedBlocks": "[]"
                    }
                  }
                ],
                "switch": "if"
              },
              {
                "pins": {
                  "in": {
                    "value": "io.html.receive.blocksForm && io.html.receive.blocksForm.values.addShape"
                  }
                },
                "children": [
                  {
                    "emitter": {
                      "memory.gallery": "GE.appendToArray(memory.gallery, memory.blocks)",
                      "memory.events": "GE.appendToArray(memory.events, { type: 'added shape to gallery', time: transformers.makeTimestamp(io.time), shape: transformers.serializeBlocks(memory.blocks) })"
                    }
                  }
                ],
                "switch": "if"
              },
              {
                "pins": {
                  "in": {
                    "value": "memory.gallery.length > 0"
                  }
                },
                "children": [
                  {
                    "emitter": {
                      "io.canvas.shapes": "transformers.drawShapes(transformers.translateShapes(transformers.inverseVector(transformers.findCenterOfCells(memory.constants.galleryGrid, _.last(memory.gallery))), transformers.makeBlockShapes(memory.constants.galleryGrid, _.last(memory.gallery), transformers.rgbColorString(memory.constants.blockColor), memory.constants.galleryBlockSize)))"
                    }
                  }
                ],
                "switch": "if"
              }
            ],
            "switch": "doWhile"
          },
          {
            "emitter": {
              "memory.selectionGrids": "transformers.makeSelectionGalleryGrids(memory.constants.selectionGrid, memory.constants.galleryGrid, memory.gallery)",
              "memory.events": "GE.appendToArray(memory.events, { type: 'began gallery selection', time: transformers.makeTimestamp(io.time) })"
            }
          },
          {
            "pins": {
              "in": {
                "value": "!io.html.receive.selectionForm || !io.html.receive.selectionForm.values.done"
              }
            },
            "children": [
              {
                "splitter": {
                  "from": "memory.selectionGrids",
                  "bindTo": "selectionGrid",
                  "index": "selectionGridIndex"
                },
                "children": [
                  {
                    "emitter": {
                      "io.canvas.shapes": "transformers.drawShapes(transformers.makeSelectionGalleryShapes(memory.selectionGrids, memory.selectedGalleryIndexes))"
                    }
                  },
                  {
                    "emitter": {
                      "io.canvas.shapes": "transformers.drawShapes(transformers.translateShapes(transformers.inverseVector(transformers.findCenterOfCells(bindings.selectionGrid, memory.gallery[bindings.selectionGridIndex])), transformers.makeBlockShapes(bindings.selectionGrid, memory.gallery[bindings.selectionGridIndex], transformers.rgbColorString(memory.constants.blockColor), memory.constants.galleryBlockSize)))"
                    }
                  }
                ]
              },
              {
                "pins": {
                  "in": {
                    "shapes": "_.map(memory.selectionGrids, transformers.makeGridCoveringRectangle, transformers)",
                    "shape": "memory.mouseDetection.shape",
                    "mousePosition": "io.mouse.position",
                    "mouseDown": "io.mouse.down",
                    "state": "memory.mouseDetection.state",
                    "dragStartPosition": "memory.mouseDetection.dragStartPosition"
                  },
                  "out": {
                    "memory.mouseDetection.state": "pins.state",
                    "memory.mouseDetection.dragStartPosition": "pins.dragStartPosition",
                    "memory.mouseDetection.shape": "pins.shape"
                  }
                },
                "processor": "detectMouse"
              },
              {
                "pins": {
                  "in": {
                    "value": "memory.mouseDetection.state"
                  }
                },
                "children": [
                  {
                    "name": "hover",
                    "emitter": {
                      "io.mouse.cursor": "'pointer'"
                    }
                  },
                  {
                    "name": "click",
                    "emitter": {
                      "memory.selectedGalleryIndexes": "GE.toggleValueInArray(memory.selectedGalleryIndexes, memory.mouseDetection.shape.meta)",
                      "memory.events": "GE.appendToArray(memory.events, { type: 'selected shape', time: transformers.makeTimestamp(io.time), shape: transformers.serializeBlocks(memory.gallery[memory.mouseDetection.shape.meta]) })"
                    }
                  }
                ],
                "switch": "when"
              },
              {
                "emitter": {
                  "io.html.send.selectionForm": "{ asset: 'selectionForm', values: { done: false, ready: memory.selectedGalleryIndexes.length >= 1 } }"
                }
              }
            ],
            "switch": "doWhile"
          },
          {
            "emitter": {
              "memory.events": "GE.appendToArray(memory.events, { type: 'completed selection', time: transformers.makeTimestamp(io.time) })"
            }
          },
          {
            "emitter": {
              "io.http.requests.playerTracking": "{ url: 'http://localhost/', data: transformers.makeTrackingString({ age: memory.ageForm.age, gender: memory.ageForm.gender}, memory.events), method: 'POST', contentType: 'application/json; charset=UTF-8',  }"
            }
          },
          {
            "pins": {
              "in": {
                "value": "!io.html.receive.thanksForm || !io.html.receive.thanksForm.values.done"
              }
            },
            "children": [
              {
                "emitter": {
                  "io.html.send.thanksForm": "{ asset: 'thanksForm', values: { done: false } }"
                }
              }
            ],
            "switch": "doWhile"
          }
        ],
        "switch": "doInSequence"
      }
    ],
    "switch": "doInParallel"
  },
  "processors": {
    "changeParameterThroughKeyboard": {
      "pinDefs": {
        "parameter": {
          "direction": "inout"
        },
        "keysDown": null,
        "keyMap": null
      },
      "update": "for (var keyCode in pins.keyMap) {\n  if (pins.keysDown[keyCode]) {\n    var value = pins.keyMap[keyCode];\n    if (_.isString(value) && value.length > 0 && (value[0] == '+' || value[0] == '-')) {\n      pins.parameter += Number(value);\n    } else {\n      pins.parameter = value;\n    }\n    break;\n  }\n}"
    },
    "detectMouse": {
      "pinDefs": {
        "shapes": null,
        "shape": {
          "direction": "inout"
        },
        "mousePosition": null,
        "mouseDown": null,
        "state": {
          "direction": "inout"
        },
        "dragStartPosition": {
          "direction": "inout"
        },
        "minimumDragDistance": {
          "default": "5"
        }
      },
      "update": "if (!pins.state)\n  pins.state = 'none';\nswitch (pins.state) {\ncase 'none':\n  if (pins.mousePosition) {\n    for (var i in pins.shapes) {\n      if (transformers.pointIntersectsShape(pins.mousePosition, pins.shapes[i])) {\n        log(GE.logLevels.INFO, 'Entering hover mode. Old state = ' + pins.state);\n        pins.state = 'hover';\n        pins.shape = pins.shapes[i];\n        break;\n      }\n    }\n  }\n  break;\ncase 'hover':\n  if (!pins.mousePosition || !transformers.pointIntersectsShape(pins.mousePosition, pins.shape)) {\n    pins.state = 'none';\n    pins.shape = null;\n    log(GE.logLevels.INFO, 'Leaving hover mode');\n  } else if (pins.mouseDown) {\n    pins.dragStartPosition = pins.mousePosition;\n    pins.state = 'pressed';\n    log(GE.logLevels.INFO, 'Entering presed mode');\n  }\n  break;\ncase 'pressed':\n  if (!pins.mouseDown) {\n    pins.state = 'click';\n    pins.dragStartPosition = null;\n    log(GE.logLevels.INFO, 'Leaving pressed mode');\n  } else if (Vector.create(pins.dragStartPosition).distanceFrom(Vector.create(pins.mousePosition)) >= pins.minimumDragDistance) {\n    pins.state = 'startDrag';\n    pins.dragStartPosition = null;\n    log(GE.logLevels.INFO, 'Entering drag mode');\n  }\n  break;\ncase 'click':\n  pins.state = 'hover';\n  break;\ncase 'startDrag':\n  pins.state = 'drag';\n  break;\ncase 'drag':\n  if (!pins.mouseDown) {\n    pins.state = 'endDrag';\n    pins.dragStartPosition = null;\n    log(GE.logLevels.INFO, 'Leaving drag mode');\n  }\n  break;\ncase 'endDrag':\n  pins.state = 'hover';\n  break;\ndefault:\n  throw new Error('Unknown state \\'' + pins.state + '\\'');\n}"
    },
    "updateHtmlTemplate": {
      "pinDefs": {
        "htmlService": {
          "direction": "inout"
        },
        "memoryValues": {
          "direction": "inout"
        },
        "assetName": null,
        "templateName": null
      },
      "update": "if (!pins.htmlService.receive[pins.templateName]) {\n  pins.htmlService.send[pins.templateName] = {\n    asset: pins.assetName,\n    values: pins.memoryValues\n  };\n} else {\n  pins.memoryValues = pins.htmlService.receive[pins.templateName].values;\n  pins.htmlService.send[pins.templateName] = pins.htmlService.receive[pins.templateName];\n}"
    }
  },
  "switches": {
    "doInParallel": {
      "doc": "Just to place children under it"
    },
    "doInSequence": {
      "pinDefs": {
        "activeChild": {
          "direction": "inout",
          "default": 0
        }
      },
      "listActiveChildren": "return [pins.activeChild];",
      "handleSignals": "if (signals[pins.activeChild] == GE.signals.DONE)\n  pins.activeChild++;\nif (pins.activeChild > children.length - 1) {\n  pins.activeChild = 0;\n  return GE.signals.DONE;\n}"
    },
    "doForSomeTime": {
      "pinDefs": {
        "time": null,
        "timer": {
          "direction": "inout"
        }
      },
      "listActiveChildren": "return children;",
      "handleSignals": "if (pins.timer++ >= pins.time) {\n  pins.timer = 0;\n  return GE.signals.DONE;\n}"
    },
    "doWhile": {
      "pinDefs": {
        "value": null
      },
      "listActiveChildren": "return !!pins.value ? children : [];",
      "handleSignals": "if (!pins.value)\n  return GE.signals.DONE;"
    },
    "when": {
      "pinDefs": {
        "value": null
      },
      "listActiveChildren": "return transformers.childByName(children, pins.value);"
    },
    "if": {
      "pinDefs": {
        "value": null
      },
      "listActiveChildren": "return pins.value ? [0] : children.length > 1 ? [1] : [];"
    },
    "sandwich": {
      "pinDefs": {
        "condition": null,
        "started": {
          "direction": "inout"
        }
      },
      "listActiveChildren": "if (!pins.track) {\n  if (!pins.condition) {\n    return [0];\n  } else {\n    pins.track = true;\n    return [1];\n  }\n} else {\n  if (pins.condition) {\n    return [1];\n  } else {\n    pins.track = false;\n    return [2];\n  }\n}"
    }
  },
  "transformers": {
    "drawShape": {
      "args": [
        "shape",
        "oldShapes"
      ],
      "body": "var shapes = oldShapes || {};\nshapes[_.uniqueId()] = shape;\nreturn shapes;"
    },
    "pointIntersectsShape": {
      "args": [
        "point",
        "shape"
      ],
      "body": "if (!shape.fillStyle && !shape.strokeStyle)\n  return false;\nswitch (shape.type) {\ncase 'circle':\n  var center = Vector.create(shape.center);\n  if (shape.translation)\n    center = center.add(shape.translation);\n  var lineWidth = shape.lineWidth || 1;\n  var scale = shape.scale || 1;\n  var minDistance = shape.fillStyle ? 0 : shape.radius - lineWidth;\n  var maxDistance = shape.strokeStyle ? shape.radius + lineWidth : shape.radius;\n  var distance = center.distanceFrom(Vector.create(point));\n  return distance >= minDistance * scale && distance <= maxDistance * scale;\ncase 'rectangle':\n  var pointInShapeFrame = Vector.create(point);\n  if (shape.translation)\n    pointInShapeFrame = pointInShapeFrame.subtract(shape.translation);\n  return pointInShapeFrame.elements[0] >= shape.position[0] && pointInShapeFrame.elements[0] <= shape.position[0] + shape.size[0] && pointInShapeFrame.elements[1] >= shape.position[1] && pointInShapeFrame.elements[1] <= shape.position[1] + shape.size[1];\ndefault:\n  throw new Error('Shape type \\'' + shape.type + '\\' is not supported');\n}"
    },
    "removeElement": {
      "args": [
        "tab",
        "index"
      ],
      "body": "var newArray = [];\nfor (var i = 0; i < tab.length; i++) {\n  if (i != index)\n    newArray.push(tab[i]);\n}\nreturn newArray;"
    },
    "gridCellAtPoint": {
      "args": [
        "grid",
        "point"
      ],
      "body": "if (point === null)\n  return null;\nvar gridPos = [\n    Math.floor((point[0] - grid.upperLeft[0]) / grid.cellSize[0]),\n    Math.floor((point[1] - grid.upperLeft[1]) / grid.cellSize[1])\n  ];\nif (grid.type != 'infinite' && (gridPos[0] < 0 || gridPos[0] > grid.gridSize[0] || gridPos[1] < 0 || gridPos[1] > grid.gridSize[1]))\n  return null;\nelse\n  return gridPos;"
    },
    "gridCellToPoint": {
      "args": [
        "grid",
        "cell",
        "proportions"
      ],
      "body": "return [\n  (cell[0] + proportions[0]) * grid.cellSize[0] + grid.upperLeft[0],\n  (cell[1] + proportions[1]) * grid.cellSize[1] + grid.upperLeft[1]\n];"
    },
    "gridCellUpperLeft": {
      "args": [
        "grid",
        "cell"
      ],
      "body": "return transformers.gridCellToPoint(grid, cell, [\n  0,\n  0\n]);"
    },
    "gridCellCenter": {
      "args": [
        "grid",
        "cell"
      ],
      "body": "return transformers.gridCellToPoint(grid, cell, [\n  0.5,\n  0.5\n]);"
    },
    "gridCellRectangle": {
      "args": [
        "grid",
        "cell",
        "meta"
      ],
      "body": "return {\n  type: 'rectangle',\n  position: transformers.gridCellUpperLeft(grid, cell),\n  size: grid.cellSize,\n  meta: meta\n};"
    },
    "gridSizeInPixels": {
      "args": [
        "grid"
      ],
      "body": "return [\n  grid.cellSize[0] * grid.gridSize[0],\n  grid.cellSize[1] * grid.gridSize[1]\n];"
    },
    "gridIndexToCell": {
      "args": [
        "grid",
        "index"
      ],
      "body": "return [\n  index % grid.gridSize[0],\n  Math.floor(index / grid.gridSize[0])\n];"
    },
    "calculateRotationAngle": {
      "args": [
        "center",
        "mousePosition"
      ],
      "body": "var h = [\n    mousePosition[0] - center[0],\n    mousePosition[1] - center[1]\n  ];\nvar omDistance = Math.sqrt(h[0] * h[0] + h[1] * h[1]);\nvar ratio = -h[1] / omDistance;\nvar angle = 0;\nif (omDistance !== 0) {\n  var absValueAngle = Math.acos(ratio) * 180 / Math.PI;\n  if (h[0] <= 0) {\n    angle = -absValueAngle;\n  } else {\n    angle = absValueAngle;\n  }\n}\nreturn angle;"
    },
    "calculateRotationOffset": {
      "args": [
        "rotation",
        "center",
        "mousePosition"
      ],
      "body": "return rotation - transformers.calculateRotationAngle(center, mousePosition);"
    },
    "calculateRotation": {
      "args": [
        "rotationOffset",
        "center",
        "mousePosition"
      ],
      "body": "return transformers.calculateRotationAngle(center, mousePosition) + rotationOffset;"
    },
    "childByName": {
      "args": [
        "children",
        "value"
      ],
      "body": "var childIndex = GE.indexOf(children, value);\nreturn childIndex != -1 ? [childIndex] : [];"
    },
    "makeFilledRectangle": {
      "args": [
        "grid",
        "cell",
        "meta"
      ],
      "body": "return _.extend(transformers.gridCellRectangle(grid, cell, meta), {\n  strokeStyle: 'white',\n  fillStyle: 'white'\n});"
    },
    "makeGridCoveringRectangle": {
      "args": [
        "grid",
        "meta"
      ],
      "body": "return {\n  meta: meta,\n  type: 'rectangle',\n  position: grid.upperLeft,\n  size: transformers.gridSizeInPixels(grid),\n  strokeStyle: 'white',\n  fillStyle: 'white'\n};"
    },
    "meanOfCoordinates": {
      "args": [
        "coordinates"
      ],
      "body": "var sum = _.reduce(coordinates, function (memo, cell) {\n    return [\n      memo[0] + cell[0],\n      memo[1] + cell[1]\n    ];\n  }, [\n    0,\n    0\n  ]);\nreturn [\n  sum[0] / coordinates.length,\n  sum[1] / coordinates.length\n];"
    },
    "findCenterOfCells": {
      "args": [
        "grid",
        "cells"
      ],
      "body": "if (cells.length == 0)\n  return [\n    0,\n    0\n  ];\nvar gridCenter = transformers.gridCenter(grid);\nvar sum = _.reduce(cells, function (memo, cell) {\n    return [\n      memo[0] + cell[0] + 0.5,\n      memo[1] + cell[1] + 0.5\n    ];\n  }, [\n    0,\n    0\n  ]);\nreturn [\n  sum[0] * grid.cellSize[0] / cells.length - gridCenter[0],\n  sum[1] * grid.cellSize[1] / cells.length - gridCenter[1]\n];"
    },
    "listBlockCenters": {
      "args": [
        "grid",
        "blocks"
      ],
      "body": "return _.map(blocks, function (block) {\n  return [\n    (block[0] + 0.5) * grid.cellSize[0],\n    (block[1] + 0.5) * grid.cellSize[1]\n  ];\n});"
    },
    "gridCenter": {
      "args": [
        "grid"
      ],
      "body": "return [\n  grid.cellSize[0] * grid.gridSize[0] / 2,\n  grid.cellSize[1] * grid.gridSize[1] / 2\n];"
    },
    "makeBlockShapes": {
      "args": [
        "grid",
        "blocks",
        "blockColor",
        "blockSize"
      ],
      "body": "var that = transformers;\nreturn _.map(blocks, function (block) {\n  return _.extend(that.gridCellRectangle(grid, block, block), {\n    layer: 'blocks',\n    fillStyle: blockColor,\n    size: blockSize\n  });\n});"
    },
    "makeMovableBlockShapes": {
      "args": [
        "grid",
        "blocks",
        "blockColor",
        "blockSize"
      ],
      "body": "var that = transformers;\nvar movableBlocks = _.filter(blocks, function (block) {\n    return that.canMoveBlock(blocks, block);\n  });\nreturn _.map(movableBlocks, function (block) {\n  return _.extend(that.gridCellRectangle(grid, block, block), {\n    layer: 'blocks',\n    fillStyle: blockColor,\n    size: blockSize\n  });\n});"
    },
    "makeDraggedShape": {
      "args": [
        "size",
        "color",
        "mousePosition"
      ],
      "body": "return {\n  layer: 'drag',\n  type: 'rectangle',\n  position: [\n    mousePosition[0] - size[0] / 2,\n    mousePosition[1] - size[1] / 2\n  ],\n  size: size,\n  fillStyle: color\n};"
    },
    "drawShapes": {
      "args": [
        "shapes"
      ],
      "body": "var that = transformers;\nreturn _.reduce(shapes, function (memo, shape) {\n  return that.drawShape(shape, memo);\n}, {});"
    },
    "blocksAreNeighbors": {
      "args": [
        "a",
        "b"
      ],
      "body": "var diff = [\n    Math.abs(a[0] - b[0]),\n    Math.abs(a[1] - b[1])\n  ];\nreturn diff[0] == 1 && diff[1] == 0 || diff[0] == 0 && diff[1] == 1;"
    },
    "makeAdjacencyList": {
      "args": [
        "blocks"
      ],
      "body": "var adjList = _.map(blocks, function () {\n    return [];\n  });\nfor (var i = 0; i < blocks.length - 1; i++) {\n  for (var j = i + 1; j < blocks.length; j++) {\n    if (transformers.blocksAreNeighbors(blocks[i], blocks[j])) {\n      adjList[i].push(j);\n      adjList[j].push(i);\n    }\n  }\n}\nreturn adjList;"
    },
    "visitBlocks": {
      "args": [
        "adjList",
        "startingIndices"
      ],
      "body": "var visited = [startingIndices];\nwhile (true) {\n  var toVisit = _.reduce(visited[visited.length - 1], function (memo, visitingIndex) {\n      return memo.concat(adjList[visitingIndex]);\n    }, []);\n  toVisit = _.uniq(toVisit);\n  toVisit = _.difference.apply(_, [toVisit].concat(visited));\n  if (toVisit.length > 0) {\n    visited.push(toVisit);\n  } else {\n    return visited;\n  }\n}"
    },
    "canMoveBlock": {
      "args": [
        "blocks",
        "block"
      ],
      "body": "var blocksWithout = transformers.removeElement(blocks, GE.indexOf(blocks, block));\nvar adjList = transformers.makeAdjacencyList(blocksWithout);\nvar visited = transformers.visitBlocks(adjList, [0]);\nreturn _.flatten(visited).length == blocksWithout.length;"
    },
    "findFreeBlockPositions": {
      "args": [
        "blocks"
      ],
      "body": "var freePositions = [];\n_.each(blocks, function (block) {\n  freePositions.push([\n    block[0] + 1,\n    block[1]\n  ]);\n  freePositions.push([\n    block[0] - 1,\n    block[1]\n  ]);\n  freePositions.push([\n    block[0],\n    block[1] + 1\n  ]);\n  freePositions.push([\n    block[0],\n    block[1] - 1\n  ]);\n});\nfreePositions = GE.uniq(freePositions);\nreturn GE.difference(freePositions, blocks);"
    },
    "distanceBetweenPoints": {
      "args": [
        "a",
        "b"
      ],
      "body": "return Vector.create(a).distanceFrom(Vector.create(b));"
    },
    "translateShapes": {
      "args": [
        "translation",
        "shapes"
      ],
      "body": "var newShapes = _.map(shapes, function (shape) {\n    return _.extend(shape, {\n      position: [\n        shape.position[0] + translation[0],\n        shape.position[1] + translation[1]\n      ]\n    });\n  });\nreturn newShapes;"
    },
    "translatePoint": {
      "args": [
        "translation",
        "point"
      ],
      "body": "return [\n  point[0] + translation[0],\n  point[1] + translation[1]\n];"
    },
    "inverseVector": {
      "args": [
        "vector"
      ],
      "body": "return [\n  -vector[0],\n  -vector[1]\n];"
    },
    "subtractVectors": {
      "args": [
        "a",
        "b"
      ],
      "body": "return [\n  a[0] - b[0],\n  a[1] - b[1]\n];"
    },
    "makeSelectionGalleryGrids": {
      "args": [
        "selectionGrid",
        "galleryGrid",
        "gallery"
      ],
      "body": "var that = transformers;\nreturn _.map(_.range(gallery.length), function (index) {\n  var cell = that.gridIndexToCell(selectionGrid, index);\n  return {\n    type: 'infinite',\n    'upperLeft': that.gridCellUpperLeft(selectionGrid, cell),\n    'cellSize': galleryGrid.cellSize,\n    'gridSize': galleryGrid.gridSize\n  };\n});"
    },
    "makeSelectionGalleryShapes": {
      "args": [
        "selectionGrids",
        "selectedGalleryIndexes"
      ],
      "body": "var that = transformers;\nreturn _.map(selectionGrids, function (selectionGrid, index) {\n  return _.extend(that.makeGridCoveringRectangle(selectionGrid, index), {\n    fillStyle: GE.contains(selectedGalleryIndexes, index) ? 'red' : 'grey',\n    strokeStyle: 'white',\n    layer: 'gallery'\n  });\n});"
    },
    "serializeBlocks": {
      "args": [
        "blocks"
      ],
      "body": "var min = _.reduce(blocks, function (memo, block) {\n    return [\n      Math.min(memo[0], block[0]),\n      Math.min(memo[1], block[1])\n    ];\n  }, [\n    Infinity,\n    Infinity\n  ]);\nvar rowNumbers = _.map(_.range(10), function () {\n    return 0;\n  });\n_.each(blocks, function (block) {\n  var index = block[1] - min[1];\n  rowNumbers[index] = rowNumbers[index] | 1 << 9 - (block[0] - min[0]);\n});\nreturn rowNumbers;"
    },
    "makeTimestamp": {
      "args": [
        "ms"
      ],
      "body": "return new Date(ms).toUTCString();"
    },
    "findDroppedPosition": {
      "args": [
        "grid",
        "blocks",
        "mousePosition"
      ],
      "body": "var that = transformers;\nvar hoveredCell = transformers.gridCellAtPoint(grid, mousePosition);\nif (!hoveredCell)\n  return blocks;\nvar freeBlockPositions = transformers.findFreeBlockPositions(blocks);\nreturn _.min(freeBlockPositions, function (block) {\n  return that.distanceBetweenPoints(hoveredCell, block);\n});"
    },
    "makeBlockGroupsToBeHighlighted": {
      "args": [
        "blocks",
        "newPosition"
      ],
      "body": "log(GE.logLevels.INFO, 'makeBlockGroupsToBeHighlighted', arguments);\nvar newBlocks = GE.appendToArray(blocks, newPosition);\nvar adjList = transformers.makeAdjacencyList(newBlocks);\nvar visitedBlockIndexes = _.rest(transformers.visitBlocks(adjList, [newBlocks.length - 1]));\nreturn _.map(visitedBlockIndexes, function (blockIndexes) {\n  return _.map(blockIndexes, function (index) {\n    return newBlocks[index];\n  });\n});"
    },
    "adjustShapesByMeta": {
      "args": [
        "shapes",
        "meta",
        "properties"
      ],
      "body": "return _.map(shapes, function (shape) {\n  if (_.isEqual(shape.meta, meta)) {\n    return _.extend(GE.clone(shape), properties);\n  } else {\n    return shape;\n  }\n});"
    },
    "interpolateVector": {
      "args": [
        "start",
        "end",
        "fraction"
      ],
      "body": "return _.map(_.zip(start, end), function (pair) {\n  return pair[0] + fraction * (pair[1] - pair[0]);\n});"
    },
    "cyclicInterpolate": {
      "args": [
        "start",
        "end",
        "fraction"
      ],
      "body": "return fraction < 0.5 ? transformers.interpolateVector(start, end, fraction / 0.5) : transformers.interpolateVector(end, start, (fraction - 0.5) / 0.5);"
    },
    "rgbColorString": {
      "args": [
        "colorArray"
      ],
      "body": "var flooredArray = _.map(colorArray, function (value) {\n    return Math.floor(value);\n  });\nreturn 'rgb(' + flooredArray.join(', ') + ')';"
    },
    "makeTrackingString": {
      "args": [
        "player",
        "events"
      ],
      "body": "return JSON.stringify({\n  player: player,\n  events: events\n});"
    }
  },
  "assets": {
    "colour": "data:application/javascript;base64,LyoKCkNvbG91ci5qcwoKT2JqZWN0cyBmb3IgaGFuZGxpbmcgYW5kIHByb2Nlc3NpbmcgY29sb3VycwoKQ3JlYXRlZCBieSBTdGVwaGVuIE1vcmxleSAtIGh0dHA6Ly9jb2RlLnN0ZXBoZW5tb3JsZXkub3JnLyAtIGFuZCByZWxlYXNlZCB1bmRlcgp0aGUgdGVybXMgb2YgdGhlIENDMCAxLjAgVW5pdmVyc2FsIGxlZ2FsIGNvZGU6CgpodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9wdWJsaWNkb21haW4vemVyby8xLjAvbGVnYWxjb2RlCgoqLwoKLyogQW4gYWJzdHJhY3QgQ29sb3VyIGltcGxlbWVudGF0aW9uLiBDb25jcmV0ZSBDb2xvdXIgaW1wbGVtZW50YXRpb25zIHNob3VsZCB1c2UKICogYW4gaW5zdGFuY2Ugb2YgdGhpcyBmdW5jdGlvbiBhcyB0aGVpciBwcm90b3R5cGUsIGFuZCBpbXBsZW1lbnQgdGhlIGdldFJHQiBhbmQKICogZ2V0SFNMIGZ1bmN0aW9ucy4gZ2V0UkdCIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgUkdCCiAqIGNvbXBvbmVudHMgb2YgdGhpcyBDb2xvdXIsIHdpdGggdGhlIHJlZCwgZ3JlZW4sIGFuZCBibHVlIGNvbXBvbmVudHMgaW4gdGhlCiAqIHJhbmdlIFswLDI1NV0gYW5kIHRoZSBhbHBoYSBjb21wb25lbnQgaW4gdGhlIHJhbmdlIFswLDEwMF0uIGdldEhTTCBzaG91bGQKICogcmV0dXJuIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIEhTTCBjb21wb25lbnRzIG9mIHRoaXMgQ29sb3VyLCB3aXRoIHRoZSBodWUKICogY29tcG9uZW50IGluIHRoZSByYW5nZSBbMCwzNjApLCB0aGUgc2F0dXJhdGlvbiBhbmQgbGlnaHRuZXNzIGNvbXBvbmVudHMgaW4KICogdGhlIHJhbmdlIFswLDEwMF0sIGFuZCB0aGUgYWxwaGEgY29tcG9uZW50IGluIHRoZSByYW5nZSBbMCwxXS4KICovCmZ1bmN0aW9uIENvbG91cigpewoKICAvKiBSZXR1cm5zIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIFJHQkEgY29tcG9uZW50cyBvZiB0aGlzIENvbG91ci4gVGhlIHJlZCwKICAgKiBncmVlbiwgYW5kIGJsdWUgY29tcG9uZW50cyBhcmUgY29udmVydGVkIHRvIGludGVnZXJzIGluIHRoZSByYW5nZSBbMCwyNTVdLgogICAqIFRoZSBhbHBoYSBpcyBhIHZhbHVlIGluIHRoZSByYW5nZSBbMCwxXS4KICAgKi8KICB0aGlzLmdldEludGVnZXJSR0IgPSBmdW5jdGlvbigpewoKICAgIC8vIGdldCB0aGUgUkdCIGNvbXBvbmVudHMgb2YgdGhpcyBjb2xvdXIKICAgIHZhciByZ2IgPSB0aGlzLmdldFJHQigpOwoKICAgIC8vIHJldHVybiB0aGUgaW50ZWdlciBjb21wb25lbnRzCiAgICByZXR1cm4gewogICAgICAncicgOiBNYXRoLnJvdW5kKHJnYi5yKSwKICAgICAgJ2cnIDogTWF0aC5yb3VuZChyZ2IuZyksCiAgICAgICdiJyA6IE1hdGgucm91bmQocmdiLmIpLAogICAgICAnYScgOiByZ2IuYQogICAgfTsKCiAgfTsKCiAgLyogUmV0dXJucyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBSR0JBIGNvbXBvbmVudHMgb2YgdGhpcyBDb2xvdXIuIFRoZSByZWQsCiAgICogZ3JlZW4sIGFuZCBibHVlIGNvbXBvbmVudHMgYXJlIGNvbnZlcnRlZCB0byBudW1iZXJzIGluIHRoZSByYW5nZSBbMCwxMDBdLgogICAqIFRoZSBhbHBoYSBpcyBhIHZhbHVlIGluIHRoZSByYW5nZSBbMCwxXS4KICAgKi8KICB0aGlzLmdldFBlcmNlbnRhZ2VSR0IgPSBmdW5jdGlvbigpewoKICAgIC8vIGdldCB0aGUgUkdCIGNvbXBvbmVudHMgb2YgdGhpcyBjb2xvdXIKICAgIHZhciByZ2IgPSB0aGlzLmdldFJHQigpOwoKICAgIC8vIHJldHVybiB0aGUgcGVyY2VudGFnZSBjb21wb25lbnRzCiAgICByZXR1cm4gewogICAgICAncicgOiAxMDAgKiByZ2IuciAvIDI1NSwKICAgICAgJ2cnIDogMTAwICogcmdiLmcgLyAyNTUsCiAgICAgICdiJyA6IDEwMCAqIHJnYi5iIC8gMjU1LAogICAgICAnYScgOiByZ2IuYQogICAgfTsKCiAgfTsKCiAgLyogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBDb2xvdXIgYXMgYSBDU1MgaGV4YWRlY2ltYWwgUkdCIGNvbG91cgogICAqIHZhbHVlIC0gdGhhdCBpcywgYSBzdHJpbmcgb2YgdGhlIGZvcm0gI1JSR0dCQiB3aGVyZSBlYWNoIG9mIFJSLCBHRywgYW5kIEJCCiAgICogYXJlIHR3by1kaWdpdCBoZXhhZGVjaW1hbCBudW1iZXJzLgogICAqLwogIHRoaXMuZ2V0Q1NTSGV4YWRlY2ltYWxSR0IgPSBmdW5jdGlvbigpewoKICAgIC8vIGdldCB0aGUgaW50ZWdlciBSR0IgY29tcG9uZW50cwogICAgdmFyIHJnYiA9IHRoaXMuZ2V0SW50ZWdlclJHQigpOwoKICAgIC8vIGRldGVybWluZSB0aGUgaGV4YWRlY2ltYWwgZXF1aXZhbGVudHMKICAgIHZhciByMTYgPSByZ2Iuci50b1N0cmluZygxNik7CiAgICB2YXIgZzE2ID0gcmdiLmcudG9TdHJpbmcoMTYpOwogICAgdmFyIGIxNiA9IHJnYi5iLnRvU3RyaW5nKDE2KTsKCiAgICAvLyByZXR1cm4gdGhlIENTUyBSR0IgY29sb3VyIHZhbHVlCiAgICByZXR1cm4gJyMnCiAgICAgICAgKyAocjE2Lmxlbmd0aCA9PSAyID8gcjE2IDogJzAnICsgcjE2KQogICAgICAgICsgKGcxNi5sZW5ndGggPT0gMiA/IGcxNiA6ICcwJyArIGcxNikKICAgICAgICArIChiMTYubGVuZ3RoID09IDIgPyBiMTYgOiAnMCcgKyBiMTYpOwoKICB9OwoKICAvKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIENvbG91ciBhcyBhIENTUyBpbnRlZ2VyIFJHQiBjb2xvdXIKICAgKiB2YWx1ZSAtIHRoYXQgaXMsIGEgc3RyaW5nIG9mIHRoZSBmb3JtIHJnYihyLGcsYikgd2hlcmUgZWFjaCBvZiByLCBnLCBhbmQgYgogICAqIGFyZSBpbnRlZ2VycyBpbiB0aGUgcmFuZ2UgWzAsMjU1XS4KICAgKi8KICB0aGlzLmdldENTU0ludGVnZXJSR0IgPSBmdW5jdGlvbigpewoKICAgIC8vIGdldCB0aGUgaW50ZWdlciBSR0IgY29tcG9uZW50cwogICAgdmFyIHJnYiA9IHRoaXMuZ2V0SW50ZWdlclJHQigpOwoKICAgIC8vIHJldHVybiB0aGUgQ1NTIFJHQiBjb2xvdXIgdmFsdWUKICAgIHJldHVybiAncmdiKCcgKyByZ2IuciArICcsJyArIHJnYi5nICsgJywnICsgcmdiLmIgKyAnKSc7CgogIH07CgogIC8qIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgQ29sb3VyIGFzIGEgQ1NTIGludGVnZXIgUkdCQSBjb2xvdXIKICAgKiB2YWx1ZSAtIHRoYXQgaXMsIGEgc3RyaW5nIG9mIHRoZSBmb3JtIHJnYmEocixnLGIsYSkgd2hlcmUgZWFjaCBvZiByLCBnLCBhbmQKICAgKiBiIGFyZSBpbnRlZ2VycyBpbiB0aGUgcmFuZ2UgWzAsMjU1XSBhbmQgYSBpcyBpbiB0aGUgcmFuZ2UgWzAsMV0uCiAgICovCiAgdGhpcy5nZXRDU1NJbnRlZ2VyUkdCQSA9IGZ1bmN0aW9uKCl7CgogICAgLy8gZ2V0IHRoZSBpbnRlZ2VyIFJHQiBjb21wb25lbnRzCiAgICB2YXIgcmdiID0gdGhpcy5nZXRJbnRlZ2VyUkdCKCk7CgogICAgLy8gcmV0dXJuIHRoZSBDU1MgaW50ZWdlciBSR0JBIGNvbG91ciB2YWx1ZQogICAgcmV0dXJuICdyZ2IoJyArIHJnYi5yICsgJywnICsgcmdiLmcgKyAnLCcgKyByZ2IuYiArICcsJyArIHJnYi5hICsgJyknOwoKICB9OwoKICAvKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIENvbG91ciBhcyBhIENTUyBwZXJjZW50YWdlIFJHQiBjb2xvdXIKICAgKiB2YWx1ZSAtIHRoYXQgaXMsIGEgc3RyaW5nIG9mIHRoZSBmb3JtIHJnYihyJSxnJSxiJSkgd2hlcmUgZWFjaCBvZiByLCBnLCBhbmQKICAgKiBiIGFyZSBpbiB0aGUgcmFuZ2UgWzAsMTAwXS4KICAgKi8KICB0aGlzLmdldENTU1BlcmNlbnRhZ2VSR0IgPSBmdW5jdGlvbigpewoKICAgIC8vIGdldCB0aGUgcGVyY2VudGFnZSBSR0IgY29tcG9uZW50cwogICAgdmFyIHJnYiA9IHRoaXMuZ2V0UGVyY2VudGFnZVJHQigpOwoKICAgIC8vIHJldHVybiB0aGUgQ1NTIFJHQiBjb2xvdXIgdmFsdWUKICAgIHJldHVybiAncmdiKCcgKyByZ2IuciArICclLCcgKyByZ2IuZyArICclLCcgKyByZ2IuYiArICclKSc7CgogIH07CgogIC8qIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgQ29sb3VyIGFzIGEgQ1NTIHBlcmNlbnRhZ2UgUkdCQSBjb2xvdXIKICAgKiB2YWx1ZSAtIHRoYXQgaXMsIGEgc3RyaW5nIG9mIHRoZSBmb3JtIHJnYmEociUsZyUsYiUsYSkgd2hlcmUgZWFjaCBvZiByLCBnLAogICAqIGFuZCBiIGFyZSBpbiB0aGUgcmFuZ2UgWzAsMTAwXSBhbmQgYSBpcyBpbiB0aGUgcmFuZ2UgWzAsMV0uCiAgICovCiAgdGhpcy5nZXRDU1NQZXJjZW50YWdlUkdCQSA9IGZ1bmN0aW9uKCl7CgogICAgLy8gZ2V0IHRoZSBwZXJjZW50YWdlIFJHQiBjb21wb25lbnRzCiAgICB2YXIgcmdiID0gdGhpcy5nZXRQZXJjZW50YWdlUkdCKCk7CgogICAgLy8gcmV0dXJuIHRoZSBDU1MgcGVyY2VudGFnZSBSR0JBIGNvbG91ciB2YWx1ZQogICAgcmV0dXJuICdyZ2IoJyArIHJnYi5yICsgJyUsJyArIHJnYi5nICsgJyUsJyArIHJnYi5iICsgJyUsJyArIHJnYi5hICsgJyknOwoKICB9OwoKICAvKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIENvbG91ciBhcyBhIENTUyBIU0wgY29sb3VyIHZhbHVlIC0gdGhhdAogICAqIGlzLCBhIHN0cmluZyBvZiB0aGUgZm9ybSBoc2woaCxzJSxsJSkgd2hlcmUgaCBpcyBpbiB0aGUgcmFuZ2UgWzAsMzYwKSBhbmQKICAgKiBzIGFuZCBsIGFyZSBpbiB0aGUgcmFuZ2UgWzAsMTAwXS4KICAgKi8KICB0aGlzLmdldENTU0hTTCA9IGZ1bmN0aW9uKCl7CgogICAgLy8gZ2V0IHRoZSBIU0wgY29tcG9uZW50cwogICAgdmFyIGhzbCA9IHRoaXMuZ2V0SFNMKCk7CgogICAgLy8gcmV0dXJuIHRoZSBDU1MgSFNMIGNvbG91ciB2YWx1ZQogICAgcmV0dXJuICdoc2woJyArIGhzbC5oICsgJywnICsgaHNsLnMgKyAnJSwnICsgaHNsLmwgKyAnJSknOwoKICB9OwoKICAvKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIENvbG91ciBhcyBhIENTUyBIU0xBIGNvbG91ciB2YWx1ZSAtIHRoYXQKICAgKiBpcywgYSBzdHJpbmcgb2YgdGhlIGZvcm0gaHNsYShoLHMlLGwlLGEpIHdoZXJlIGggaXMgaW4gdGhlIHJhbmdlIFswLDM2MCksCiAgICogcyBhbmQgbCBhcmUgaW4gdGhlIHJhbmdlIFswLDEwMF0sIGFuZCBhIGlzIGluIHRoZSByYW5nZSBbMCwxXS4KICAgKi8KICB0aGlzLmdldENTU0hTTEEgPSBmdW5jdGlvbigpewoKICAgIC8vIGdldCB0aGUgSFNMIGNvbXBvbmVudHMKICAgIHZhciBoc2wgPSB0aGlzLmdldEhTTCgpOwoKICAgIC8vIHJldHVybiB0aGUgQ1NTIEhTTCBjb2xvdXIgdmFsdWUKICAgIHJldHVybiAnaHNsKCcgKyBoc2wuaCArICcsJyArIGhzbC5zICsgJyUsJyArIGhzbC5sICsgJyUsJyArIGhzbC5hICsgJyknOwoKICB9OwoKICAvKiBTZXRzIHRoZSBjb2xvdXIgb2YgdGhlIHNwZWNpZmllZCBub2RlIHRvIHRoaXMgQ29sb3VyLiBUaGlzIGZ1bmN0aW9uIHNldHMKICAgKiB0aGUgQ1NTICdjb2xvcicgcHJvcGVydHkgZm9yIHRoZSBub2RlLiBUaGUgcGFyYW1ldGVyIGlzOgogICAqCiAgICogbm9kZSAtIHRoZSBub2RlIHdob3NlIGNvbG91ciBzaG91bGQgYmUgc2V0CiAgICovCiAgdGhpcy5zZXROb2RlQ29sb3VyID0gZnVuY3Rpb24obm9kZSl7CgogICAgLy8gc2V0IHRoZSBjb2xvdXIgb2YgdGhlIG5vZGUKICAgIG5vZGUuc3R5bGUuY29sb3IgPSB0aGlzLmdldENTU0hleGFkZWNpbWFsUkdCKCk7CgogIH07CgogIC8qIFNldHMgdGhlIGJhY2tncm91bmQgY29sb3VyIG9mIHRoZSBzcGVjaWZpZWQgbm9kZSB0byB0aGlzIENvbG91ci4gVGhpcwogICAqIGZ1bmN0aW9uIHNldHMgdGhlIENTUyAnYmFja2dyb3VuZC1jb2xvcicgcHJvcGVydHkgZm9yIHRoZSBub2RlLiBUaGUKICAgKiBwYXJhbWV0ZXIgaXM6CiAgICoKICAgKiBub2RlIC0gdGhlIG5vZGUgd2hvc2UgYmFja2dyb3VuZCBjb2xvdXIgc2hvdWxkIGJlIHNldAogICAqLwogIHRoaXMuc2V0Tm9kZUJhY2tncm91bmRDb2xvdXIgPSBmdW5jdGlvbihub2RlKXsKCiAgICAvLyBzZXQgdGhlIGJhY2tncm91bmQgY29sb3VyIG9mIHRoZSBub2RlCiAgICBub2RlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZ2V0Q1NTSGV4YWRlY2ltYWxSR0IoKTsKCiAgfTsKCn0KCi8qIENyZWF0ZXMgYSBjb2xvdXIgc3BlY2lmaWVkIGluIHRoZSBSR0IgY29sb3VyIHNwYWNlLCB3aXRoIGFuIG9wdGlvbmFsIGFscGhhCiAqIGNvbXBvbmVudC4gVGhlIHBhcmFtZXRlcnMgYXJlOgogKgogKiByIC0gdGhlIHJlZCBjb21wb25lbnQsIGNsaXBwZWQgdG8gdGhlIHJhbmdlIFswLDI1NV0KICogZyAtIHRoZSBncmVlbiBjb21wb25lbnQsIGNsaXBwZWQgdG8gdGhlIHJhbmdlIFswLDI1NV0KICogYiAtIHRoZSBibHVlIGNvbXBvbmVudCwgY2xpcHBlZCB0byB0aGUgcmFuZ2UgWzAsMjU1XQogKiBhIC0gdGhlIGFscGhhIGNvbXBvbmVudCwgY2xpcHBlZCB0byB0aGUgcmFuZ2UgWzAsMV0gLSB0aGlzIHBhcmFtZXRlciBpcwogKiAgICAgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIDEKICovClJHQkNvbG91ci5wcm90b3R5cGUgPSBuZXcgQ29sb3VyKCk7CmZ1bmN0aW9uIFJHQkNvbG91cihyLCBnLCBiLCBhKXsKCiAgLy8gc3RvcmUgdGhlIGFscGhhIGNvbXBvbmVudCBhZnRlciBjbGlwcGluZyBpdCBpZiBuZWNlc3NhcnkKICB2YXIgYWxwaGEgPSAoYSA9PT0gdW5kZWZpbmVkID8gMSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGEpKSk7CgogIC8vIHN0b3JlIHRoZSBSR0IgY29tcG9uZW50cyBhZnRlciBjbGlwcGluZyB0aGVtIGlmIG5lY2Vzc2FyeQogIHZhciByZ2IgPQogICAgICB7CiAgICAgICAgJ3InIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByKSksCiAgICAgICAgJ2cnIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBnKSksCiAgICAgICAgJ2InIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBiKSkKICAgICAgfTsKCiAgLy8gaW5pdGlhbGlzZSB0aGUgSFNWIGFuZCBIU0wgY29tcG9uZW50cyB0byBudWxsCiAgdmFyIGhzdiA9IG51bGw7CiAgdmFyIGhzbCA9IG51bGw7CgogIC8qIFJldHVybnMgdGhlIEhTViBvciBIU0wgaHVlIGNvbXBvbmVudCBvZiB0aGlzIFJHQkNvbG91ci4gVGhlIGh1ZSBpcyBpbiB0aGUKICAgKiByYW5nZSBbMCwzNjApLiBUaGUgcGFyYW1ldGVycyBhcmU6CiAgICoKICAgKiBtYXhpbXVtIC0gdGhlIG1heGltdW0gb2YgdGhlIFJHQiBjb21wb25lbnQgdmFsdWVzCiAgICogcmFuZ2UgICAtIHRoZSByYW5nZSBvZiB0aGUgUkdCIGNvbXBvbmVudCB2YWx1ZXMKICAgKi8KICBmdW5jdGlvbiBnZXRIdWUobWF4aW11bSwgcmFuZ2UpewoKICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIHJhbmdlIGlzIHplcm8KICAgIGlmIChyYW5nZSA9PSAwKXsKCiAgICAgIC8vIHNldCB0aGUgaHVlIHRvIHplcm8gKGFueSBodWUgaXMgYWNjZXB0YWJsZSBhcyB0aGUgY29sb3VyIGlzIGdyZXkpCiAgICAgIHZhciBodWUgPSAwOwoKICAgIH1lbHNlewoKICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG9mIHRoZSBjb21wb25lbnRzIGhhcyB0aGUgaGlnaGVzdCB2YWx1ZSBhbmQgc2V0IHRoZSBodWUKICAgICAgc3dpdGNoIChtYXhpbXVtKXsKCiAgICAgICAgLy8gcmVkIGhhcyB0aGUgaGlnaGVzdCB2YWx1ZQogICAgICAgIGNhc2UgcmdiLnI6CiAgICAgICAgICB2YXIgaHVlID0gKHJnYi5nIC0gcmdiLmIpIC8gcmFuZ2UgKiA2MDsKICAgICAgICAgIGlmIChodWUgPCAwKSBodWUgKz0gMzYwOwogICAgICAgICAgYnJlYWs7CgogICAgICAgIC8vIGdyZWVuIGhhcyB0aGUgaGlnaGVzdCB2YWx1ZQogICAgICAgIGNhc2UgcmdiLmc6CiAgICAgICAgICB2YXIgaHVlID0gKHJnYi5iIC0gcmdiLnIpIC8gcmFuZ2UgKiA2MCArIDEyMDsKICAgICAgICAgIGJyZWFrOwoKICAgICAgICAvLyBibHVlIGhhcyB0aGUgaGlnaGVzdCB2YWx1ZQogICAgICAgIGNhc2UgcmdiLmI6CiAgICAgICAgICB2YXIgaHVlID0gKHJnYi5yIC0gcmdiLmcpIC8gcmFuZ2UgKiA2MCArIDI0MDsKICAgICAgICAgIGJyZWFrOwoKICAgICAgfQoKICAgIH0KCiAgICAvLyByZXR1cm4gdGhlIGh1ZQogICAgcmV0dXJuIGh1ZTsKCiAgfQoKICAvKiBDYWxjdWxhdGVzIGFuZCBzdG9yZXMgdGhlIEhTViBjb21wb25lbnRzIG9mIHRoaXMgUkdCQ29sb3VyIHNvIHRoYXQgdGhleSBjYW4KICAgKiBiZSByZXR1cm5lZCBiZSB0aGUgZ2V0SFNWIGZ1bmN0aW9uLgogICAqLwogIGZ1bmN0aW9uIGNhbGN1bGF0ZUhTVigpewoKICAgIC8vIGdldCB0aGUgbWF4aW11bSBhbmQgcmFuZ2Ugb2YgdGhlIFJHQiBjb21wb25lbnQgdmFsdWVzCiAgICB2YXIgbWF4aW11bSA9IE1hdGgubWF4KHJnYi5yLCByZ2IuZywgcmdiLmIpOwogICAgdmFyIHJhbmdlICAgPSBtYXhpbXVtIC0gTWF0aC5taW4ocmdiLnIsIHJnYi5nLCByZ2IuYik7CgogICAgLy8gc3RvcmUgdGhlIEhTViBjb21wb25lbnRzCiAgICBoc3YgPQogICAgICAgIHsKICAgICAgICAgICdoJyA6IGdldEh1ZShtYXhpbXVtLCByYW5nZSksCiAgICAgICAgICAncycgOiAobWF4aW11bSA9PSAwID8gMCA6IDEwMCAqIHJhbmdlIC8gbWF4aW11bSksCiAgICAgICAgICAndicgOiBtYXhpbXVtIC8gMi41NQogICAgICAgIH07CgogIH0KCiAgLyogQ2FsY3VsYXRlcyBhbmQgc3RvcmVzIHRoZSBIU0wgY29tcG9uZW50cyBvZiB0aGlzIFJHQkNvbG91ciBzbyB0aGF0IHRoZXkgY2FuCiAgICogYmUgcmV0dXJuZWQgYmUgdGhlIGdldEhTTCBmdW5jdGlvbi4KICAgKi8KICBmdW5jdGlvbiBjYWxjdWxhdGVIU0woKXsKCiAgICAvLyBnZXQgdGhlIG1heGltdW0gYW5kIHJhbmdlIG9mIHRoZSBSR0IgY29tcG9uZW50IHZhbHVlcwogICAgdmFyIG1heGltdW0gPSBNYXRoLm1heChyZ2IuciwgcmdiLmcsIHJnYi5iKTsKICAgIHZhciByYW5nZSAgID0gbWF4aW11bSAtIE1hdGgubWluKHJnYi5yLCByZ2IuZywgcmdiLmIpOwoKICAgIC8vIGRldGVybWluZSB0aGUgbGlnaHRuZXNzIGluIHRoZSByYW5nZSBbMCwxXQogICAgdmFyIGwgPSBtYXhpbXVtIC8gMjU1IC0gcmFuZ2UgLyA1MTA7CgogICAgLy8gc3RvcmUgdGhlIEhTTCBjb21wb25lbnRzCiAgICBoc2wgPQogICAgICAgIHsKICAgICAgICAgICdoJyA6IGdldEh1ZShtYXhpbXVtLCByYW5nZSksCiAgICAgICAgICAncycgOiAocmFuZ2UgPT0gMCA/IDAgOiByYW5nZSAvIDIuNTUgLyAobCA8IDAuNSA/IGwgKiAyIDogMiAtIGwgKiAyKSksCiAgICAgICAgICAnbCcgOiAxMDAgKiBsCiAgICAgICAgfTsKCiAgfQoKICAvKiBSZXR1cm5zIHRoZSBSR0IgYW5kIGFscGhhIGNvbXBvbmVudHMgb2YgdGhpcyBSR0JDb2xvdXIgYXMgYW4gb2JqZWN0IHdpdGggciwKICAgKiBnLCBiLCBhbmQgYSBwcm9wZXJ0aWVzLiByLCBnLCBhbmQgYiBhcmUgaW4gdGhlIHJhbmdlIFswLDI1NV0gYW5kIGEgaXMgaW4KICAgKiB0aGUgcmFuZ2UgWzAsMV0uCiAgICovCiAgdGhpcy5nZXRSR0IgPSBmdW5jdGlvbigpewoKICAgIC8vIHJldHVybiB0aGUgUkdCIGNvbXBvbmVudHMKICAgIHJldHVybiB7CiAgICAgICdyJyA6IHJnYi5yLAogICAgICAnZycgOiByZ2IuZywKICAgICAgJ2InIDogcmdiLmIsCiAgICAgICdhJyA6IGFscGhhCiAgICB9OwoKICB9OwoKICAvKiBSZXR1cm5zIHRoZSBIU1YgYW5kIGFscGhhIGNvbXBvbmVudHMgb2YgdGhpcyBSR0JDb2xvdXIgYXMgYW4gb2JqZWN0IHdpdGggaCwKICAgKiBzLCB2LCBhbmQgYSBwcm9wZXJ0aWVzLiBoIGlzIGluIHRoZSByYW5nZSBbMCwzNjApLCBzIGFuZCB2IGFyZSBpbiB0aGUgcmFuZ2UKICAgKiBbMCwxMDBdLCBhbmQgYSBpcyBpbiB0aGUgcmFuZ2UgWzAsMV0uCiAgICovCiAgdGhpcy5nZXRIU1YgPSBmdW5jdGlvbigpewoKICAgIC8vIGNhbGN1bGF0ZSB0aGUgSFNWIGNvbXBvbmVudHMgaWYgbmVjZXNzYXJ5CiAgICBpZiAoaHN2ID09IG51bGwpIGNhbGN1bGF0ZUhTVigpOwoKICAgIC8vIHJldHVybiB0aGUgSFNWIGNvbXBvbmVudHMKICAgIHJldHVybiB7CiAgICAgICdoJyA6IGhzdi5oLAogICAgICAncycgOiBoc3YucywKICAgICAgJ3YnIDogaHN2LnYsCiAgICAgICdhJyA6IGFscGhhCiAgICB9OwoKICB9OwoKICAvKiBSZXR1cm5zIHRoZSBIU0wgYW5kIGFscGhhIGNvbXBvbmVudHMgb2YgdGhpcyBSR0JDb2xvdXIgYXMgYW4gb2JqZWN0IHdpdGggaCwKICAgKiBzLCBsLCBhbmQgYSBwcm9wZXJ0aWVzLiBoIGlzIGluIHRoZSByYW5nZSBbMCwzNjApLCBzIGFuZCBsIGFyZSBpbiB0aGUgcmFuZ2UKICAgKiBbMCwxMDBdLCBhbmQgYSBpcyBpbiB0aGUgcmFuZ2UgWzAsMV0uCiAgICovCiAgdGhpcy5nZXRIU0wgPSBmdW5jdGlvbigpewoKICAgIC8vIGNhbGN1bGF0ZSB0aGUgSFNWIGNvbXBvbmVudHMgaWYgbmVjZXNzYXJ5CiAgICBpZiAoaHNsID09IG51bGwpIGNhbGN1bGF0ZUhTTCgpOwoKICAgIC8vIHJldHVybiB0aGUgSFNMIGNvbXBvbmVudHMKICAgIHJldHVybiB7CiAgICAgICdoJyA6IGhzbC5oLAogICAgICAncycgOiBoc2wucywKICAgICAgJ2wnIDogaHNsLmwsCiAgICAgICdhJyA6IGFscGhhCiAgICB9OwoKICB9OwoKfQoKLyogQ3JlYXRlcyBhIGNvbG91ciBzcGVjaWZpZWQgaW4gdGhlIEhTViBjb2xvdXIgc3BhY2UsIHdpdGggYW4gb3B0aW9uYWwgYWxwaGEKICogY29tcG9uZW50LiBUaGUgcGFyYW1ldGVycyBhcmU6CiAqCiAqIGggLSB0aGUgaHVlIGNvbXBvbmVudCwgd3JhcHBlZCB0byB0aGUgcmFuZ2UgWzAsMzYwKQogKiBzIC0gdGhlIHNhdHVyYXRpb24gY29tcG9uZW50LCBjbGlwcGVkIHRvIHRoZSByYW5nZSBbMCwxMDBdCiAqIHYgLSB0aGUgdmFsdWUgY29tcG9uZW50LCBjbGlwcGVkIHRvIHRoZSByYW5nZSBbMCwxMDBdCiAqIGEgLSB0aGUgYWxwaGEgY29tcG9uZW50LCBjbGlwcGVkIHRvIHRoZSByYW5nZSBbMCwxXSAtIHRoaXMgcGFyYW1ldGVyIGlzCiAqICAgICBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gMQogKi8KSFNWQ29sb3VyLnByb3RvdHlwZSA9IG5ldyBDb2xvdXIoKTsKZnVuY3Rpb24gSFNWQ29sb3VyKGgsIHMsIHYsIGEpewoKICAvLyBzdG9yZSB0aGUgYWxwaGEgY29tcG9uZW50IGFmdGVyIGNsaXBwaW5nIGl0IGlmIG5lY2Vzc2FyeQogIHZhciBhbHBoYSA9IChhID09PSB1bmRlZmluZWQgPyAxIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYSkpKTsKCiAgLy8gc3RvcmUgdGhlIEhTViBjb21wb25lbnRzIGFmdGVyIGNsaXBwaW5nIG9yIHdyYXBwaW5nIHRoZW0gaWYgbmVjZXNzYXJ5CiAgdmFyIGhzdiA9CiAgICAgIHsKICAgICAgICAnaCcgOiAoaCAlIDM2MCArIDM2MCkgJSAzNjAsCiAgICAgICAgJ3MnIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCBzKSksCiAgICAgICAgJ3YnIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCB2KSkKICAgICAgfTsKCiAgLy8gaW5pdGlhbGlzZSB0aGUgUkdCIGFuZCBIU0wgY29tcG9uZW50cyB0byBudWxsCiAgdmFyIHJnYiA9IG51bGw7CiAgdmFyIGhzbCA9IG51bGw7CgogIC8qIENhbGN1bGF0ZXMgYW5kIHN0b3JlcyB0aGUgUkdCIGNvbXBvbmVudHMgb2YgdGhpcyBIU1ZDb2xvdXIgc28gdGhhdCB0aGV5IGNhbgogICAqIGJlIHJldHVybmVkIGJlIHRoZSBnZXRSR0IgZnVuY3Rpb24uCiAgICovCiAgZnVuY3Rpb24gY2FsY3VsYXRlUkdCKCl7CgogICAgLy8gY2hlY2sgd2hldGhlciB0aGUgc2F0dXJhdGlvbiBpcyB6ZXJvCiAgICBpZiAoaHN2LnMgPT0gMCl7CgogICAgICAvLyBzZXQgdGhlIGNvbG91ciB0byB0aGUgYXBwcm9wcmlhdGUgc2hhZGUgb2YgZ3JleQogICAgICB2YXIgciA9IGhzdi52OwogICAgICB2YXIgZyA9IGhzdi52OwogICAgICB2YXIgYiA9IGhzdi52OwoKICAgIH1lbHNlewoKICAgICAgLy8gc2V0IHNvbWUgdGVtcG9yYXJ5IHZhbHVlcwogICAgICB2YXIgZiAgPSBoc3YuaCAvIDYwIC0gTWF0aC5mbG9vcihoc3YuaCAvIDYwKTsKICAgICAgdmFyIHAgID0gaHN2LnYgKiAoMSAtIGhzdi5zIC8gMTAwKTsKICAgICAgdmFyIHEgID0gaHN2LnYgKiAoMSAtIGhzdi5zIC8gMTAwICogZik7CiAgICAgIHZhciB0ICA9IGhzdi52ICogKDEgLSBoc3YucyAvIDEwMCAqICgxIC0gZikpOwoKICAgICAgLy8gc2V0IHRoZSBSR0IgY29sb3VyIGNvbXBvbmVudHMgdG8gdGhlaXIgdGVtcG9yYXJ5IHZhbHVlcwogICAgICBzd2l0Y2ggKE1hdGguZmxvb3IoaHN2LmggLyA2MCkpewogICAgICAgIGNhc2UgMDogdmFyIHIgPSBoc3YudjsgdmFyIGcgPSB0OyB2YXIgYiA9IHA7IGJyZWFrOwogICAgICAgIGNhc2UgMTogdmFyIHIgPSBxOyB2YXIgZyA9IGhzdi52OyB2YXIgYiA9IHA7IGJyZWFrOwogICAgICAgIGNhc2UgMjogdmFyIHIgPSBwOyB2YXIgZyA9IGhzdi52OyB2YXIgYiA9IHQ7IGJyZWFrOwogICAgICAgIGNhc2UgMzogdmFyIHIgPSBwOyB2YXIgZyA9IHE7IHZhciBiID0gaHN2LnY7IGJyZWFrOwogICAgICAgIGNhc2UgNDogdmFyIHIgPSB0OyB2YXIgZyA9IHA7IHZhciBiID0gaHN2LnY7IGJyZWFrOwogICAgICAgIGNhc2UgNTogdmFyIHIgPSBoc3YudjsgdmFyIGcgPSBwOyB2YXIgYiA9IHE7IGJyZWFrOwogICAgICB9CgogICAgfQoKICAgIC8vIHN0b3JlIHRoZSBSR0IgY29tcG9uZW50cwogICAgcmdiID0KICAgICAgICB7CiAgICAgICAgICAncicgOiByICogMi41NSwKICAgICAgICAgICdnJyA6IGcgKiAyLjU1LAogICAgICAgICAgJ2InIDogYiAqIDIuNTUKICAgICAgICB9OwoKICB9CgogIC8qIENhbGN1bGF0ZXMgYW5kIHN0b3JlcyB0aGUgSFNMIGNvbXBvbmVudHMgb2YgdGhpcyBIU1ZDb2xvdXIgc28gdGhhdCB0aGV5IGNhbgogICAqIGJlIHJldHVybmVkIGJlIHRoZSBnZXRIU0wgZnVuY3Rpb24uCiAgICovCiAgZnVuY3Rpb24gY2FsY3VsYXRlSFNMKCl7CgogICAgLy8gZGV0ZXJtaW5lIHRoZSBsaWdodG5lc3MgaW4gdGhlIHJhbmdlIFswLDEwMF0KICAgIHZhciBsID0gKDIgLSBoc3YucyAvIDEwMCkgKiBoc3YudiAvIDI7CgogICAgLy8gc3RvcmUgdGhlIEhTTCBjb21wb25lbnRzCiAgICBoc2wgPQogICAgICAgIHsKICAgICAgICAgICdoJyA6IGhzdi5oLAogICAgICAgICAgJ3MnIDogaHN2LnMgKiBoc3YudiAvIChsIDwgNTAgPyBsICogMiA6IDIwMCAtIGwgKiAyKSwKICAgICAgICAgICdsJyA6IGwKICAgICAgICB9OwoKICAgIC8vIGNvcnJlY3QgYSBkaXZpc2lvbi1ieS16ZXJvIGVycm9yCiAgICBpZiAoaXNOYU4oaHNsLnMpKSBoc2wucyA9IDA7CgogIH0KCiAgLyogUmV0dXJucyB0aGUgUkdCIGFuZCBhbHBoYSBjb21wb25lbnRzIG9mIHRoaXMgSFNWQ29sb3VyIGFzIGFuIG9iamVjdCB3aXRoIHIsCiAgICogZywgYiwgYW5kIGEgcHJvcGVydGllcy4gciwgZywgYW5kIGIgYXJlIGluIHRoZSByYW5nZSBbMCwyNTVdIGFuZCBhIGlzIGluCiAgICogdGhlIHJhbmdlIFswLDFdLgogICAqLwogIHRoaXMuZ2V0UkdCID0gZnVuY3Rpb24oKXsKCiAgICAvLyBjYWxjdWxhdGUgdGhlIFJHQiBjb21wb25lbnRzIGlmIG5lY2Vzc2FyeQogICAgaWYgKHJnYiA9PSBudWxsKSBjYWxjdWxhdGVSR0IoKTsKCiAgICAvLyByZXR1cm4gdGhlIFJHQiBjb21wb25lbnRzCiAgICByZXR1cm4gewogICAgICAncicgOiByZ2IuciwKICAgICAgJ2cnIDogcmdiLmcsCiAgICAgICdiJyA6IHJnYi5iLAogICAgICAnYScgOiBhbHBoYQogICAgfTsKCiAgfTsKCiAgLyogUmV0dXJucyB0aGUgSFNWIGFuZCBhbHBoYSBjb21wb25lbnRzIG9mIHRoaXMgSFNWQ29sb3VyIGFzIGFuIG9iamVjdCB3aXRoIGgsCiAgICogcywgdiwgYW5kIGEgcHJvcGVydGllcy4gaCBpcyBpbiB0aGUgcmFuZ2UgWzAsMzYwKSwgcyBhbmQgdiBhcmUgaW4gdGhlIHJhbmdlCiAgICogWzAsMTAwXSwgYW5kIGEgaXMgaW4gdGhlIHJhbmdlIFswLDFdLgogICAqLwogIHRoaXMuZ2V0SFNWID0gZnVuY3Rpb24oKXsKCiAgICAvLyByZXR1cm4gdGhlIEhTViBjb21wb25lbnRzCiAgICByZXR1cm4gewogICAgICAnaCcgOiBoc3YuaCwKICAgICAgJ3MnIDogaHN2LnMsCiAgICAgICd2JyA6IGhzdi52LAogICAgICAnYScgOiBhbHBoYQogICAgfTsKCiAgfTsKCiAgLyogUmV0dXJucyB0aGUgSFNMIGFuZCBhbHBoYSBjb21wb25lbnRzIG9mIHRoaXMgSFNWQ29sb3VyIGFzIGFuIG9iamVjdCB3aXRoIGgsCiAgICogcywgbCwgYW5kIGEgcHJvcGVydGllcy4gaCBpcyBpbiB0aGUgcmFuZ2UgWzAsMzYwKSwgcyBhbmQgbCBhcmUgaW4gdGhlIHJhbmdlCiAgICogWzAsMTAwXSwgYW5kIGEgaXMgaW4gdGhlIHJhbmdlIFswLDFdLgogICAqLwogIHRoaXMuZ2V0SFNMID0gZnVuY3Rpb24oKXsKCiAgICAvLyBjYWxjdWxhdGUgdGhlIEhTTCBjb21wb25lbnRzIGlmIG5lY2Vzc2FyeQogICAgaWYgKGhzbCA9PSBudWxsKSBjYWxjdWxhdGVIU0woKTsKCiAgICAvLyByZXR1cm4gdGhlIEhTTCBjb21wb25lbnRzCiAgICByZXR1cm4gewogICAgICAnaCcgOiBoc2wuaCwKICAgICAgJ3MnIDogaHNsLnMsCiAgICAgICdsJyA6IGhzbC5sLAogICAgICAnYScgOiBhbHBoYQogICAgfTsKCiAgfTsKCn0KCi8qIENyZWF0ZXMgYSBjb2xvdXIgc3BlY2lmaWVkIGluIHRoZSBIU0wgY29sb3VyIHNwYWNlLCB3aXRoIGFuIG9wdGlvbmFsIGFscGhhCiAqIGNvbXBvbmVudC4gVGhlIHBhcmFtZXRlcnMgYXJlOgogKgogKiBoIC0gdGhlIGh1ZSBjb21wb25lbnQsIHdyYXBwZWQgdG8gdGhlIHJhbmdlIFswLDM2MCkKICogcyAtIHRoZSBzYXR1cmF0aW9uIGNvbXBvbmVudCwgY2xpcHBlZCB0byB0aGUgcmFuZ2UgWzAsMTAwXQogKiBsIC0gdGhlIGxpZ2h0bmVzcyBjb21wb25lbnQsIGNsaXBwZWQgdG8gdGhlIHJhbmdlIFswLDEwMF0KICogYSAtIHRoZSBhbHBoYSBjb21wb25lbnQsIGNsaXBwZWQgdG8gdGhlIHJhbmdlIFswLDFdIC0gdGhpcyBwYXJhbWV0ZXIgaXMKICogICAgIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAxCiAqLwpIU0xDb2xvdXIucHJvdG90eXBlID0gbmV3IENvbG91cigpOwpmdW5jdGlvbiBIU0xDb2xvdXIoaCwgcywgbCwgYSl7CgogIC8vIHN0b3JlIHRoZSBhbHBoYSBjb21wb25lbnQgYWZ0ZXIgY2xpcHBpbmcgaXQgaWYgbmVjZXNzYXJ5CiAgdmFyIGFscGhhID0gKGEgPT09IHVuZGVmaW5lZCA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBhKSkpOwoKICAvLyBzdG9yZSB0aGUgSFNMIGNvbXBvbmVudHMgYWZ0ZXIgY2xpcHBpbmcgb3Igd3JhcHBpbmcgdGhlbSBpZiBuZWNlc3NhcnkKICB2YXIgaHNsID0KICAgICAgewogICAgICAgICdoJyA6IChoICUgMzYwICsgMzYwKSAlIDM2MCwKICAgICAgICAncycgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIHMpKSwKICAgICAgICAnbCcgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIGwpKQogICAgICB9OwoKICAvLyBpbml0aWFsaXNlIHRoZSBSR0IgYW5kIEhTViBjb21wb25lbnRzIHRvIG51bGwKICB2YXIgcmdiID0gbnVsbDsKICB2YXIgaHN2ID0gbnVsbDsKCiAgLyogQ2FsY3VsYXRlcyBhbmQgc3RvcmVzIHRoZSBSR0IgY29tcG9uZW50cyBvZiB0aGlzIEhTTENvbG91ciBzbyB0aGF0IHRoZXkgY2FuCiAgICogYmUgcmV0dXJuZWQgYmUgdGhlIGdldFJHQiBmdW5jdGlvbi4KICAgKi8KICBmdW5jdGlvbiBjYWxjdWxhdGVSR0IoKXsKCiAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBzYXR1cmF0aW9uIGlzIHplcm8KICAgIGlmIChoc2wucyA9PSAwKXsKCiAgICAgIC8vIHN0b3JlIHRoZSBSR0IgY29tcG9uZW50cyByZXByZXNlbnRpbmcgdGhlIGFwcHJvcHJpYXRlIHNoYWRlIG9mIGdyZXkKICAgICAgcmdiID0KICAgICAgICAgIHsKICAgICAgICAgICAgJ3InIDogaHNsLmwgKiAyLjU1LAogICAgICAgICAgICAnZycgOiBoc2wubCAqIDIuNTUsCiAgICAgICAgICAgICdiJyA6IGhzbC5sICogMi41NQogICAgICAgICAgfTsKCiAgICB9ZWxzZXsKCiAgICAgIC8vIHNldCBzb21lIHRlbXBvcmFyeSB2YWx1ZXMKICAgICAgdmFyIHAgPSBoc2wubCA8IDUwCiAgICAgICAgICAgID8gaHNsLmwgKiAoMSArIGhzbC5zIC8gMTAwKQogICAgICAgICAgICA6IGhzbC5sICsgaHNsLnMgLSBoc2wubCAqIGhzbC5zIC8gMTAwOwogICAgICB2YXIgcSA9IDIgKiBoc2wubCAtIHA7CgogICAgICAvLyBpbml0aWFsaXNlIHRoZSBSR0IgY29tcG9uZW50cwogICAgICByZ2IgPQogICAgICAgICAgewogICAgICAgICAgICAncicgOiAoaCArIDEyMCkgLyA2MCAlIDYsCiAgICAgICAgICAgICdnJyA6IGggLyA2MCwKICAgICAgICAgICAgJ2InIDogKGggKyAyNDApIC8gNjAgJSA2CiAgICAgICAgICB9OwoKICAgICAgLy8gbG9vcCBvdmVyIHRoZSBSR0IgY29tcG9uZW50cwogICAgICBmb3IgKHZhciBrZXkgaW4gcmdiKXsKCiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHByb3BlcnR5IGlzIG5vdCBpbmhlcml0ZWQgZnJvbSB0aGUgcm9vdCBvYmplY3QKICAgICAgICBpZiAocmdiLmhhc093blByb3BlcnR5KGtleSkpewoKICAgICAgICAgIC8vIHNldCB0aGUgY29tcG9uZW50IHRvIGl0cyB2YWx1ZSBpbiB0aGUgcmFuZ2UgWzAsMTAwXQogICAgICAgICAgaWYgKHJnYltrZXldIDwgMSl7CiAgICAgICAgICAgIHJnYltrZXldID0gcSArIChwIC0gcSkgKiByZ2Jba2V5XTsKICAgICAgICAgIH1lbHNlIGlmIChyZ2Jba2V5XSA8IDMpewogICAgICAgICAgICByZ2Jba2V5XSA9IHA7CiAgICAgICAgICB9ZWxzZSBpZiAocmdiW2tleV0gPCA0KXsKICAgICAgICAgICAgcmdiW2tleV0gPSBxICsgKHAgLSBxKSAqICg0IC0gcmdiW2tleV0pOwogICAgICAgICAgfWVsc2V7CiAgICAgICAgICAgIHJnYltrZXldID0gcTsKICAgICAgICAgIH0KCiAgICAgICAgICAvLyBzZXQgdGhlIGNvbXBvbmVudCB0byBpdHMgdmFsdWUgaW4gdGhlIHJhbmdlIFswLDI1NV0KICAgICAgICAgIHJnYltrZXldICo9IDIuNTU7CgogICAgICAgIH0KCiAgICAgIH0KCiAgICB9CgogIH0KCiAgLyogQ2FsY3VsYXRlcyBhbmQgc3RvcmVzIHRoZSBIU1YgY29tcG9uZW50cyBvZiB0aGlzIEhTTENvbG91ciBzbyB0aGF0IHRoZXkgY2FuCiAgICogYmUgcmV0dXJuZWQgYmUgdGhlIGdldEhTTCBmdW5jdGlvbi4KICAgKi8KICBmdW5jdGlvbiBjYWxjdWxhdGVIU1YoKXsKCiAgICAvLyBzZXQgYSB0ZW1wb3JhcnkgdmFsdWUKICAgIHZhciB0ID0gaHNsLnMgKiAoaHNsLmwgPCA1MCA/IGhzbC5sIDogMTAwIC0gaHNsLmwpIC8gMTAwOwoKICAgIC8vIHN0b3JlIHRoZSBIU1YgY29tcG9uZW50cwogICAgaHN2ID0KICAgICAgICB7CiAgICAgICAgICAnaCcgOiBoc2wuaCwKICAgICAgICAgICdzJyA6IDIwMCAqIHQgLyAoaHNsLmwgKyB0KSwKICAgICAgICAgICd2JyA6IHQgKyBoc2wubAogICAgICAgIH07CgogICAgLy8gY29ycmVjdCBhIGRpdmlzaW9uLWJ5LXplcm8gZXJyb3IKICAgIGlmIChpc05hTihoc3YucykpIGhzdi5zID0gMDsKCiAgfQoKICAvKiBSZXR1cm5zIHRoZSBSR0IgYW5kIGFscGhhIGNvbXBvbmVudHMgb2YgdGhpcyBIU0xDb2xvdXIgYXMgYW4gb2JqZWN0IHdpdGggciwKICAgKiBnLCBiLCBhbmQgYSBwcm9wZXJ0aWVzLiByLCBnLCBhbmQgYiBhcmUgaW4gdGhlIHJhbmdlIFswLDI1NV0gYW5kIGEgaXMgaW4KICAgKiB0aGUgcmFuZ2UgWzAsMV0uCiAgICovCiAgdGhpcy5nZXRSR0IgPSBmdW5jdGlvbigpewoKICAgIC8vIGNhbGN1bGF0ZSB0aGUgUkdCIGNvbXBvbmVudHMgaWYgbmVjZXNzYXJ5CiAgICBpZiAocmdiID09IG51bGwpIGNhbGN1bGF0ZVJHQigpOwoKICAgIC8vIHJldHVybiB0aGUgUkdCIGNvbXBvbmVudHMKICAgIHJldHVybiB7CiAgICAgICdyJyA6IHJnYi5yLAogICAgICAnZycgOiByZ2IuZywKICAgICAgJ2InIDogcmdiLmIsCiAgICAgICdhJyA6IGFscGhhCiAgICB9OwoKICB9OwoKICAvKiBSZXR1cm5zIHRoZSBIU1YgYW5kIGFscGhhIGNvbXBvbmVudHMgb2YgdGhpcyBIU0xDb2xvdXIgYXMgYW4gb2JqZWN0IHdpdGggaCwKICAgKiBzLCB2LCBhbmQgYSBwcm9wZXJ0aWVzLiBoIGlzIGluIHRoZSByYW5nZSBbMCwzNjApLCBzIGFuZCB2IGFyZSBpbiB0aGUgcmFuZ2UKICAgKiBbMCwxMDBdLCBhbmQgYSBpcyBpbiB0aGUgcmFuZ2UgWzAsMV0uCiAgICovCiAgdGhpcy5nZXRIU1YgPSBmdW5jdGlvbigpewoKICAgIC8vIGNhbGN1bGF0ZSB0aGUgSFNWIGNvbXBvbmVudHMgaWYgbmVjZXNzYXJ5CiAgICBpZiAoaHN2ID09IG51bGwpIGNhbGN1bGF0ZUhTVigpOwoKICAgIC8vIHJldHVybiB0aGUgSFNWIGNvbXBvbmVudHMKICAgIHJldHVybiB7CiAgICAgICdoJyA6IGhzdi5oLAogICAgICAncycgOiBoc3YucywKICAgICAgJ3YnIDogaHN2LnYsCiAgICAgICdhJyA6IGFscGhhCiAgICB9OwoKICB9OwoKICAvKiBSZXR1cm5zIHRoZSBIU0wgYW5kIGFscGhhIGNvbXBvbmVudHMgb2YgdGhpcyBIU0xDb2xvdXIgYXMgYW4gb2JqZWN0IHdpdGggaCwKICAgKiBzLCBsLCBhbmQgYSBwcm9wZXJ0aWVzLiBoIGlzIGluIHRoZSByYW5nZSBbMCwzNjApLCBzIGFuZCBsIGFyZSBpbiB0aGUgcmFuZ2UKICAgKiBbMCwxMDBdLCBhbmQgYSBpcyBpbiB0aGUgcmFuZ2UgWzAsMV0uCiAgICovCiAgdGhpcy5nZXRIU0wgPSBmdW5jdGlvbigpewoKICAgIC8vIHJldHVybiB0aGUgSFNMIGNvbXBvbmVudHMKICAgIHJldHVybiB7CiAgICAgICdoJyA6IGhzbC5oLAogICAgICAncycgOiBoc2wucywKICAgICAgJ2wnIDogaHNsLmwsCiAgICAgICdhJyA6IGFscGhhCiAgICB9OwoKICB9OwoKfQo=",
    "form": "data:text/html;base64,PGRpdiBpZD0id3JhcCI+CiAgICA8aDE+UGxlYXNlIGVudGVyIGEgbGl0dGxlIGluZm9ybWF0aW9uIGFib3V0IHlvdXJzZWxmIGludG8gdGhlIGJveGVzIGJlbG93LjwvaDE+CjxoNT4oQ2xpY2sgImNvbnRpbnVlIiB3aGVuIGNvbXBsZXRlKTwvaDU+Cgo8aDI+CjxwPllvdXIgYWdlIGlzPC9wPgo8L2gyPgoKCjxpbnB1dCBjbGFzcz0iSW5wdXRGaWVsZCIgZGF0YS12YWx1ZT0iZGF0YS5hZ2UiLz4KCgo8aDI+CjxwPllvdXIgZ2VuZGVyIGlzPC9wPgo8L2gyPgoKPGlucHV0IGlkPSJyYWRpb01hbGUiIHR5cGU9InJhZGlvIiBuYW1lPSJnZW5kZXIiIGRhdGEtY2hlY2tlZD0iZGF0YS5nZW5kZXIiIHZhbHVlPSJtYWxlIi8+CjxsYWJlbCBmb3I9InJhZGlvTWFsZSI+TWFsZTwvbGFiZWw+Cjxicj4KPGlucHV0IGlkPSJyYWRpb0ZlbWFsZSIgdHlwZT0icmFkaW8iIG5hbWU9ImdlbmRlciIgZGF0YS1jaGVja2VkPSJkYXRhLmdlbmRlciIgdmFsdWU9ImZlbWFsZSIvPgo8bGFiZWwgZm9yPSJyYWRpb0ZlbWFsZSI+RmVtYWxlPC9sYWJlbD4KPGJyPjxicj4KPGJ1dHRvbiBjbGFzcz0iUmVkQnV0dG9uIiBkYXRhLW9uLWNsaWNrPSJkYXRhLmRvbmUiPkNvbnRpbnVlPC9idXR0b24+CjwvZGl2Pg==",
    "blocksForm": "data:text/html;base64,CjxkaXYgaWQ9ImFkZFNoYXBlIj48YnV0dG9uIGNsYXNzPSJhZGRTaGFwZUJ1dHRvbiIgZGF0YS1zaG93PSJkYXRhLmNhbkFkZFNoYXBlIiBkYXRhLW9uLWNsaWNrPSJkYXRhLmFkZFNoYXBlIj5BZGQgc2hhcGUgdG8gZ2FsbGVyeTwvYnV0dG9uPgo8L2Rpdj4KCgo8ZGl2IGNsYXNzPSJpbmZvcyI+CjxoMj4KPHA+WW91IGhhdmUgPHNwYW4gZGF0YS10ZXh0PSJkYXRhLmdhbGxlcnlTaGFwZUNvdW50Ij48L3NwYW4+IHNoYXBlcyBpbiB5b3VyIGdhbGxlcnkuPC9wPgo8L2gyPgo8L2Rpdj4KCjxkaXYgaWQ9IndyYXBEb25lIgo8ZGl2IGlkPSJkb25lIiBkYXRhLXNob3c9ImRhdGEucmVhZHkiPgoKICAgICAgICA8YnV0dG9uIGNsYXNzPSJkb25lQnV0dG9uIiAgZGF0YS1vbi1jbGljaz0iZGF0YS5kb25lIj5DaG9vc2UgeW91ciBmYXZvcml0ZSBzaGFwZXM8L2J1dHRvbj4KPC9kaXY+CjwvZGl2PgogICAgCgoK",
    "formCss": "data:text/css;base64,I2dhbWVDb250ZW50IHsKCWNvbG9yOiB3aGl0ZTsKCWZvbnQtZmFtaWx5OiBBcmlhbDsKCWZvbnQtc2l6ZTogMjBweDsKfQoKI2dhbWVDb250ZW50IGlucHV0LCBidXR0b24gewoJY29sb3I6IGJsYWNrOwoJZm9udC1mYW1pbHk6IEFyaWFsOwoJZm9udC1zaXplOiAyMHB4Owp9Cgojd3JhcCB7CiAgICBtYXJnaW4tdG9wOiA1MHB4OyAgCiAgICBtYXJnaW4tYm90dG9tOiAxMDBweDsgIAogICAgbWFyZ2luLXJpZ2h0OiAxMjBweDsgIAogICAgbWFyZ2luLWxlZnQ6IDEyMHB4OyAgCn0KCi50aXRsZSB7CiAgICBjb2xvcjogZ3JlZW55ZWxsb3c7Cn0KCmgxewogICAgZm9udC1zaXplOiAxLjVlbTsKICAgIHRleHQtYWxpZ246IGNlbnRlcjsKfQoKaDJ7CiAgICBmb250LXNpemU6IDEuMGVtOwogICAgY29sb3I6Z3JlZW55ZWxsb3c7Cn0KCmgzewogICAgY29sb3I6IGdyZWVueWVsbG93OwogICAgdGV4dC1hbGlnbjogY2VudGVyOwogICAgZm9udC1zaXplOiAxLjVlbTsKfQpoNHsKICAgIGNvbG9yOiBncmVlbnllbGxvdzsKICAgIHRleHQtYWxpZ246IGNlbnRlcjsKICAgIGZvbnQtc2l6ZTogMWVtOwogICAKfQpoNXsKICAgIGZvbnQtc3R5bGU6IGl0YWxpYzsKICAgIHRleHQtYWxpZ246IGNlbnRlcjsKICAgIGNvbG9yOiBvcmFuZ2U7Cn0KCi5JbnB1dEZpZWxkewogICAgd2lkdGg6IDEwMHB4OwogICAgYm9yZGVyOiAycHggc29saWQgZ3JlZW55ZWxsb3c7CgogICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7CgogICAgcGFkZGluZy1sZWZ0OiAgMTBweDsKICAgIHBhZGRpbmctcmlnaHQ6IDEwcHg7CiAgICBwYWRkaW5nLXRvcDogM3B4OwogICAgcGFkZGluZy1ib3R0b206IDNweDsKfQoKLklucHV0RmllbGQ6aG92ZXIgewogICAgYm9yZGVyOiAycHggZG90dGVkIG9yYW5nZTsKfQoKaW5wdXQsIHNlbGVjdCwgSW5wdXRGaWVsZCB7CiAgICBjb2xvcjogcmVkOwp9CgouUmVkQnV0dG9uewogICAgYmFja2dyb3VuZC1jb2xvcjogYnJvd247CiAgICBib3JkZXI6IDJweCBzb2xpZCBvcmFuZ2U7CiAgICBjb2xvcjp3aGl0ZTsKfQoKLlJlZEJ1dHRvbjpob3ZlcnsKICAgIGJvcmRlcjogMnB4IGRvdHRlZCBvcmFuZ2U7IAp9CgouYWRkU2hhcGVCdXR0b24gewogICAgYmFja2dyb3VuZC1jb2xvcjogYnJvd247CiAgICBib3JkZXI6IDJweCBzb2xpZCBvcmFuZ2U7CiAgICBjb2xvcjp3aGl0ZTsKICAgIGZvbnQtc2l6ZTogMC43ZW07Cn0KLmFkZFNoYXBlQnV0dG9uOmhvdmVyewogICAgYm9yZGVyOiAycHggZG90dGVkIG9yYW5nZTsgCn0KCiNhZGRTaGFwZXsKICAgIGZsb2F0OiByaWdodDsKICAgIG1hcmdpbi10b3A6IDE2OHB4OwogICAgbWFyZ2luLXJpZ2h0OiAxMHB4OwogICAgCn0KCgouaW5mb3N7CiAgICBmbG9hdDogbm9uZTsKICAgIHRleHQtYWxpZ246IGNlbnRlcjsKICAgIG1hcmdpbi10b3A6IDQ2MHB4OwogICAgZm9udC1zaXplOiAwLjhlbTsKCiAgIAp9Cgojd3JhcERvbmV7CiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7CiAgICBtYXJnaW4tdG9wOiAwcHg7CiAgICBtYXJnaW4tbGVmdDogMHB4OwogICAKICAgCn0KCiNkb25lewogICB0ZXh0LWFsaWduOiBjZW50ZXI7Cn0KLmRvbmVCdXR0b257CiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBicm93bjsKICAgIGJvcmRlcjogMnB4IHNvbGlkIG9yYW5nZTsKICAgIGNvbG9yOndoaXRlOwogICAgZm9udC1zaXplOiAxZW07CiAgICBtYXJnaW4tdG9wOiAtNXB4OwoKCn0KCi5kb25lQnV0dG9uOmhvdmVyewogICAgYm9yZGVyOiAycHggZG90dGVkIG9yYW5nZTsgCn0KCiNwbGVhc2V7CiAgICBwYWRkaW5nLWxlZnQ6IDI4cHg7CiAgICBtYXJnaW4tdG9wOiAtNXB4Owp9CgojZG9uZTJ7CiAgICBtYXJnaW4tdG9wOiAzODBweDsKICAgIHRleHQtYWxpZ246IGNlbnRlcjsKfQojZG9uZTJCdXR0b257CiAgICBtYXJnaW4tdG9wOiAtMjBweDsKfQoKI3RoYW5rc1dyYXB7CiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7CiAgICBtYXJnaW4tdG9wOiAyMDBweDsKfQo=",
    "selectionForm": "data:text/html;base64,PGRpdiBpZD0icGxlYXNlIj4KICAgIDxoND48cD5QbGVhc2Ugc2VsZWN0IHlvdXIgZmF2b3JpdGUgc2hhcGVzIGJ5IGNsaWNraW5nIG9uIHRoZW0uPC9wPjwvaDQ+CjwvZGl2PgoKPGRpdiBpZD0iZG9uZTIiZGF0YS1zaG93PSJkYXRhLnJlYWR5Ij4KICAgIDxoND48cD5BcmUgeW91IGRvbmU/PC9wPjwvaDQ+CiAgICA8ZGl2IGlkPSJkb25lMkJ1dHRvbiI+Cgk8YnV0dG9uIGNsYXNzPSJSZWRCdXR0b24iIGRhdGEtb24tY2xpY2s9ImRhdGEuZG9uZSI+RG9uZTwvYnV0dG9uPgogICAgICAgIAogICAgPC9kaXY+CjwvZGl2Pgo=",
    "thanksForm": "data:text/html;base64,PGRpdiBpZD0idGhhbmtzV3JhcCI+CiAgICA8aDM+PHA+VGhhbmtzIGZvciBwbGF5aW5nITwvcD48L2gzPgoKPGJ1dHRvbiBjbGFzcz0iUmVkQnV0dG9uIiBkYXRhLW9uLWNsaWNrPSJkYXRhLmRvbmUiPlBsYXkgYWdhaW48L2J1dHRvbj4KPC9kaXY+"
  }
}