{
  "name": "Stupendous Side-Scrolling Space Shooter",
  "fileVersion": 0.1,
    "memory": {
    "starfield": [],
    "hero": {
      "position": [
        50,
        270
      ]
    },
    "topLevelActiveChild": 0,
    "enemies": [
      {
        "type": "big",
        "position": [800, 270],
        "health": 1
      }
    ],
    "heroLasers": []
  },
  "board": {
    "switch": "Do in Parallel",
    "comment": "",
    "children": [
      {
        "comment": "Draw the black of space",
        "emitter": {
          "io.canvas.shapes": "transformers.drawShape({ type: 'rectangle', layer: 'space', position: [0, 0], size: io.canvas.size, fillStyle: 'black' })"
        }
      },
      {
        "comment": "Draw player's spaceship",
        "emitter": {
          "io.canvas.shapes": "transformers.drawShape({ type: 'image', asset: 'hero', layer: 'ships', position: memory.hero.position })"
        }
      },
      {
        "comment": "Draw starfield",
        "emitter": {
          "io.canvas.shapes": "transformers.drawStarfield(memory.starfield)"
        }
      },
      {
        "switch": "Do in Sequence",
        "comment": "First initialize the starfield, then keep updating it",
        "pins": {
          "in": {
            "activeChild": "memory.topLevelActiveChild"
          },
          "out": {
            "memory.topLevelActiveChild": "pins.activeChild"
          }
        },
        "children": [
          {
            "comment": "Let there be stars!",
            "emitter": {
              "memory.starfield": "transformers.initializeStarfield(50, io.canvas.size)"
            }
          },
          {
            "switch": "Do Forever",
            "comment": "",
            "children": [
              {
                "comment": "Update starfield",
                "emitter": {
                  "memory.starfield": "transformers.updateStarfield(memory.starfield, io.canvas.size)"
                }
              }
            ]
          }
        ]
      },
      {
        "processor": "Move thing with arrow keys",
        "comment": "Move the hero with arrow keys",
        "pins": {
          "in": {
            "position": "memory.hero.position",
            "keysDown": "io.keyboard.keysDown"
          },
          "out": {
            "memory.position": "params.position"
          }
        }
      },
      {
        "splitter": {
          "from": "memory.enemies",
          "bindTo": "enemy"
        },
        "children": [
          {
            "comment": "Draw enemy",
            "emitter": {
              "io.shapes": "transformers.drawShape({ type: 'image', asset: 'bindings.enemy.type', position: 'bindings.enemy.position' })"
            }
          },
          { 
            "switch": "If",
            "comment": "If the enemy is still alive",
            "pins": {
              "in": {
                "value": "bindings.enemy.health > 0"
              }
            },
            "children": [
              {
                "switch": "Do in Parallel",
                "comment": "Move the enemy and check collisions",
                "children": [
                  {
                    "comment": "Move enemy",
                    "emitter": {
                      "bindings.enemy.position": "transformers.moveEnemy(bindings.enemy)"
                    }
                  }
                ]
              },
              { 
                "comment": "Remove enemy",
                "emitter": {
                  "bindings.enemy": "null"
                } 
              }
            ]
          }
        ]
      },
      {
        "comment": "Handle firing",
        "emitter": {
          "memory.heroLasers": "GE.appendToArray(memory.heroLasers, _.contains(keyboard.keysDown, 38) && [ [memory.hero.position ] ] || [])"
        }
      }
    ]
  },
  "io": {
    "layers": [
      {
        "name": "space",
        "type": "canvas",
        "$$hashKey": "02O"
      },
      {
        "name": "stars",
        "type": "canvas",
        "$$hashKey": "02S"
      },
      {
        "name": "ships",
        "type": "canvas",
        "$$hashKey": "02W"
      }
    ]
  },
  "processors": {
    "Change Parameter through Keyboard": {
      "pinDefs": {
        "parameter": {
          "direction": "inout"
        },
        "keysDown": null,
        "keyMap": null
      },
      "update": "for (var keyCode in pins.keyMap) {\n  if (pins.keysDown[keyCode]) {\n    var value = pins.keyMap[keyCode];\n    if (_.isString(value) && value.length > 0 && (value[0] == '+' || value[0] == '-')) {\n      pins.parameter += Number(value);\n    } else {\n      pins.parameter = value;\n    }\n    break;\n  }\n}"
    },
    "Move thing with arrow keys": {
      "pinDefs": {
        "parameter": {
          "keysDown": null,
          "position": {
            "direction": "inout"
          },
          "speed": {
            "default": 1
          }
        }
      },
      "update": "if(_.contains(pins.keysDown, 37)) pins.position[0] -= pins.speed;\nif(_.contains(pins.keysDown, 39)) pins.position[0] += pins.speed;\nif(_.contains(pins.keysDown, 38)) pins.position[1] -= pins.speed;\nif(_.contains(pins.keysDown, 38)) pins.position[1] += pins.speed;"
    },
    "Detect Mouse": {
      "pinDefs": {
        "shapes": null,
        "shape": {
          "direction": "inout"
        },
        "mousePosition": null,
        "mouseDown": null,
        "state": {
          "direction": "inout"
        },
        "dragStartPosition": {
          "direction": "inout"
        },
        "minimumDragDistance": {
          "default": "5"
        }
      },
      "update": "if (!pins.state)\n  pins.state = 'none';\nswitch (pins.state) {\ncase 'none':\n  if (pins.mousePosition) {\n    for (var i in pins.shapes) {\n      if (transformers.povarVarersectsShape(pins.mousePosition, pins.shapes[i])) {\n        log(GE.logLevels.INFO, 'Entering hover mode. Old state = ' + pins.state);\n        pins.state = 'hover';\n        pins.shape = pins.shapes[i];\n        break;\n      }\n    }\n  }\n  break;\ncase 'hover':\n  if (!pins.mousePosition || !transformers.povarVarersectsShape(pins.mousePosition, pins.shape)) {\n    pins.state = 'none';\n    pins.shape = null;\n    log(GE.logLevels.INFO, 'Leaving hover mode');\n  } else if (pins.mouseDown) {\n    pins.dragStartPosition = pins.mousePosition;\n    pins.state = 'pressed';\n    log(GE.logLevels.INFO, 'Entering presed mode');\n  }\n  break;\ncase 'pressed':\n  if (!pins.mouseDown) {\n    pins.state = 'click';\n    pins.dragStartPosition = null;\n    log(GE.logLevels.INFO, 'Leaving pressed mode');\n  } else if (Vector.create(pins.dragStartPosition).distanceFrom(Vector.create(pins.mousePosition)) >= pins.minimumDragDistance) {\n    pins.state = 'startDrag';\n    pins.dragStartPosition = null;\n    log(GE.logLevels.INFO, 'Entering drag mode');\n  }\n  break;\ncase 'click':\n  pins.state = 'hover';\n  break;\ncase 'startDrag':\n  pins.state = 'drag';\n  break;\ncase 'drag':\n  if (!pins.mouseDown) {\n    pins.state = 'endDrag';\n    pins.dragStartPosition = null;\n    log(GE.logLevels.INFO, 'Leaving drag mode');\n  }\n  break;\ncase 'endDrag':\n  pins.state = 'hover';\n  break;\ndefault:\n  throw new Error('Unknown state \\'' + pins.state + '\\'');\n}"
    }
  },
  "switches": {
    "Do in Parallel": {
      "doc": "Just to place children under it",
      "listActiveChildren": "return children;",
      "handleSignals": ""
    },
    "Do in Sequence": {
      "pinDefs": {
        "activeChild": {
          "direction": "inout",
          "default": 0
        }
      },
      "listActiveChildren": "return [pins.activeChild];",
      "handleSignals": "if (signals[pins.activeChild] == GE.signals.DONE)\n  pins.activeChild++;\nif (pins.activeChild > children.length - 1) {\n  pins.activeChild = 0;\n  return GE.signals.DONE;\n}"
    },
    "Do for Some Time": {
      "pinDefs": {
        "time": null,
        "timer": {
          "direction": "inout"
        }
      },
      "listActiveChildren": "return children;",
      "handleSignals": "if (pins.timer++ >= pins.time) {\n  pins.timer = 0;\n  return GE.signals.DONE;\n}"
    },
    "Do While": {
      "pinDefs": {
        "value": null
      },
      "listActiveChildren": "return !!pins.value ? children : [];",
      "handleSignals": "if (!pins.value)\n  return GE.signals.DONE;"
    },
    "Do Forever": {
      "pinDefs": {},
      "listActiveChildren": "return children;",
      "handleSignals": ""
    },
    "When": {
      "pinDefs": {
        "value": null
      },
      "listActiveChildren": "return transformers.childByName(children, pins.value);"
    },
    "If": {
      "pinDefs": {
        "value": null
      },
      "listActiveChildren": "return pins.value ? [0] : children.length > 1 ? [1] : [];"
    },
    "Sandwhich": {
      "pinDefs": {
        "condition": null,
        "started": {
          "direction": "inout"
        }
      },
      "listActiveChildren": "if (!pins.track) {\n  if (!pins.condition) {\n    return [0];\n  } else {\n    pins.track = true;\n    return [1];\n  }\n} else {\n  if (pins.condition) {\n    return [1];\n  } else {\n    pins.track = false;\n    return [2];\n  }\n}"
    }
  },
  "transformers": {
    "drawShape": {
      "args": [
        "shape",
        "oldShapes"
      ],
      "body": "var shapes = oldShapes || {};\nshapes[_.uniqueId()] = shape;\nreturn shapes;"
    },
    "drawShapes": {
      "args": [
        "shapes"
      ],
      "body": "var that = transformers;\nreturn _.reduce(shapes, function (memo, shape) {\n  return that.drawShape(shape, memo);\n}, {});"
    },
    "pointIntersectsShape": {
      "args": [
        "point",
        "shape"
      ],
      "body": "if (!shape.fillStyle && !shape.strokeStyle)\n  return false;\nswitch (shape.type) {\ncase 'circle':\n  var center = Vector.create(shape.center);\n  if (shape.translation)\n    center = center.add(shape.translation);\n  var lineWidth = shape.lineWidth || 1;\n  var scale = shape.scale || 1;\n  var minDistance = shape.fillStyle ? 0 : shape.radius - lineWidth;\n  var maxDistance = shape.strokeStyle ? shape.radius + lineWidth : shape.radius;\n  var distance = center.distanceFrom(Vector.create(point));\n  return distance >= minDistance * scale && distance <= maxDistance * scale;\ncase 'rectangle':\n  var pointInShapeFrame = Vector.create(point);\n  if (shape.translation)\n    pointInShapeFrame = pointInShapeFrame.subtract(shape.translation);\n  return pointInShapeFrame.elements[0] >= shape.position[0] && pointInShapeFrame.elements[0] <= shape.position[0] + shape.size[0] && pointInShapeFrame.elements[1] >= shape.position[1] && pointInShapeFrame.elements[1] <= shape.position[1] + shape.size[1];\ndefault:\n  throw new Error('Shape type \\'' + shape.type + '\\' is not supported');\n}"
    },
    "removeElement": {
      "args": [
        "tab",
        "index"
      ],
      "body": "var newArray = [];\nfor (var i = 0; i < tab.length; i++) {\n  if (i != index)\n    newArray.push(tab[i]);\n}\nreturn newArray;"
    },
    "replace": {
      "args": [
        "oldPiece",
        "newPiece",
        "pieces"
      ],
      "body": "for (var i in pieces) {\n  var piece = pieces[i];\n  if (piece.col === oldPiece.col && piece.row === oldPiece.row) {\n    result = pieces.slice(0, i).concat(newPiece).concat(pieces.slice(i + 1, pieces.length));\n    return result;\n  }\n}\nreturn pieces;"
    },
    "coordinatesToString": {
      "args": [
        "coordinates"
      ],
      "body": "var x = coordinates[0] || coordinates.x;\nvar y = coordinates[1] || coordinates.y;\nreturn '[' + x + ', ' + y + ']';"
    },
    "pieceToString": {
      "args": [
        "piece"
      ],
      "body": "if (piece)\n  return '{col:' + piece.col + ', row:' + piece.row + ', type:' + piece.type + '}';\nelse\n  return piece;"
    },
    "piecesToString": {
      "args": [
        "pieces"
      ],
      "body": "var prvared = '{';\nfor (var i in pieces) {\n  var piece = pieces[i];\n  if (prvared !== '{') {\n    prvared += ', ';\n  }\n  prvared += transformers.pieceToString(piece);\n}\nprvared += '}';\nreturn prvared;"
    },
    "distance": {
      "args": [
        "povar1",
        "povar2"
      ],
      "body": "var povar1x = povar1[0] || povar1.x;\nvar povar1y = povar1[1] || povar1.y;\nvar povar2x = povar2[0] || povar2.x;\nvar povar2y = povar2[1] || povar2.y;\nvar diffX = povar1x - povar2x;\nvar diffY = povar1y - povar2y;\nreturn Math.sqrt(diffX * diffX + diffY * diffY);"
    },
    "calculateRotationAngle": {
      "args": [
        "center",
        "mousePosition"
      ],
      "body": "var h = [\n    mousePosition[0] - center[0],\n    mousePosition[1] - center[1]\n  ];\nvar omDistance = Math.sqrt(h[0] * h[0] + h[1] * h[1]);\nvar ratio = -h[1] / omDistance;\nvar angle = 0;\nif (omDistance !== 0) {\n  var absValueAngle = Math.acos(ratio) * 180 / Math.PI;\n  if (h[0] <= 0) {\n    angle = -absValueAngle;\n  } else {\n    angle = absValueAngle;\n  }\n}\nreturn angle;"
    },
    "calculateRotationOffset": {
      "args": [
        "rotation",
        "center",
        "mousePosition"
      ],
      "body": "return rotation - transformers.calculateRotationAngle(center, mousePosition);"
    },
    "calculateRotation": {
      "args": [
        "rotationOffset",
        "center",
        "mousePosition"
      ],
      "body": "return transformers.calculateRotationAngle(center, mousePosition) + rotationOffset;"
    },
    "childByName": {
      "args": [
        "children",
        "value"
      ],
      "body": "var childIndex = GE.indexOf(children, value);\nreturn childIndex != -1 ? [childIndex] : [];"
    },
    "initializeStarfield": {
      "args": [
        "count",
        "screenSize"
      ],
      "body": "var stars = []; for(var i = 0; i < count; i++) { stars.push({ position: [Math.random()*io.canvas.size[0], Math.random()*io.canvas.size[1]], velocity: 5 }); } return stars;"
    },
    "updateStarfield": {
      "args": [
        "starfield",
        "screenSize"
      ],
      "body": "var stars = []; \nfor(var i = 0; i < starfield.length; i++) { \n    var star = starfield[i]; \n    if(star.position[0] < 0) {\n        memory.stars.push({ \n            position: [io.canvas.size[0], Math.random() * io.canvas.size[1]]\n        });\n    }\n    else { \n        stars.push({ position: [star.position[0] - star.velocity, star.position[1]], velocity: star.velocity }); \n    } \n}\nreturn stars;"
    },
    "drawStarfield": {
      "args": [
        "starfield"
      ],
      "body": "var shapes = []; for(var i = 0; i < starfield.length; i++) { var star = starfield[i]; shapes.push({ type: 'image', asset: 'star', layer: 'stars', position: star.position }); } return transformers.drawShapes(shapes);"
    },
    "moveEnemy": {
      "args": [
        "enemy",
        "time"
      ],
      "body": "return [ enemy.position[0] - 1, enemy.position[1] + 10 * Math.sin(time / 1000) ];"
    }
  },
  "assets": {}
}