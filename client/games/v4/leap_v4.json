{
  "name": "Leap",
  "fileVersion": 0.4,
  "circuits": {
    "main": {
      "memory": {
        "blocks": [],
        "mouseDetection": {
          "state": null,
          "dragStartPosition": null,
          "shape": null
        },
        "activeChild": 0,
        "gridTranslation": [
          0,
          0
        ],
        "targetGridTranslation": null,
        "ageForm": {
          "gender": "male",
          "age": 33,
          "done": false
        },
        "blocksForm": {
          "done": false
        },
        "gallery": [],
        "selectionGrids": [],
        "selectedGalleryIndexes": [],
        "blockGroupsToBeHighlighted": [],
        "highlightedBlocks": [],
        "dragFrameCounter": 0,
        "events": [],
        "constants": {
          "grid": {
            "type": "infinite",
            "upperLeft": [
              205,
              0
            ],
            "cellSize": [
              55,
              55
            ],
            "gridSize": [
              10,
              10
            ]
          },
          "galleryGrid": {
            "type": "infinite",
            "upperLeft": [
              800,
              10
            ],
            "cellSize": [
              15,
              15
            ],
            "gridSize": [
              10,
              10
            ]
          },
          "selectionGrid": {
            "type": "fixed",
            "upperLeft": [
              30,
              50
            ],
            "cellSize": [
              150,
              150
            ],
            "gridSize": [
              6,
              3
            ]
          },
          "initialBlocks": [
            [
              0,
              0
            ],
            [
              1,
              0
            ],
            [
              2,
              0
            ],
            [
              3,
              0
            ],
            [
              4,
              0
            ],
            [
              5,
              0
            ],
            [
              6,
              0
            ],
            [
              7,
              0
            ],
            [
              8,
              0
            ],
            [
              9,
              0
            ]
          ],
          "blockColor": [
            129,
            231,
            0
          ],
          "highlightedBlockColor": [
            89,
            133,
            59
          ],
          "dragHighlightPeriod": 30,
          "blockSize": [
            50,
            50
          ],
          "galleryBlockSize": [
            12,
            12
          ],
          "minGridTranslation": 1
        }
      },
      "board": {
        "children": [
          {
            "emitter": {
              "io.canvas.bg": "[{ type: 'rectangle', position: [0, 0], size: io.canvas.size, fillStyle: 'black' }]"
            },
            "comment": "Draw the background",
            "name": null,
            "path": [
              "0"
            ]
          },
          {
            "pins": {
              "in": {
                "activeChild": "memory.activeChild"
              },
              "out": {
                "memory.activeChild": "pins.activeChild"
              }
            },
            "children": [
              {
                "emitter": {
                  "memory.blocks": "memory.constants.initialBlocks",
                  "memory.gallery": "[]",
                  "memory.selectedGalleryIndexes": "[]",
                  "memory.events": "[{ type: 'began game', time: transformers.makeTimestamp(io.time) }]"
                },
                "comment": "Set initial memory",
                "path": [
                  "1",
                  "0"
                ]
              },
              {
                "processor": "Send RedMetrics Event",
                "pins": {
                  "in": {
                    "type": "\"start\"",
                    "redMetricsEvents": "io.metrics.events"
                  },
                  "out": {
                    "io.metrics.events": "pins.redMetricsEvents"
                  }
                },
                "children": [],
                "path": [
                  "1",
                  "1"
                ],
                "comment": "Send start event",
                "name": null
              },
              {
                "pins": {
                  "in": {
                    "value": "!io.html.ageForm || !io.html.ageForm.values.done"
                  },
                  "out": {}
                },
                "children": [
                  {
                    "emitter": {
                      "io.html.ageForm": "{\n    asset: \"form\"\n}"
                    },
                    "path": [
                      "1",
                      "2",
                      "0"
                    ],
                    "comment": "Show the age form",
                    "name": null
                  }
                ],
                "switch": "Do While",
                "comment": "Until they filled in the form",
                "path": [
                  "1",
                  "2"
                ],
                "name": null
              },
              {
                "switch": "Do All",
                "pins": {
                  "in": {},
                  "out": {}
                },
                "children": [
                  {
                    "emitter": {
                      "memory.ageForm": "io.html.ageForm.values"
                    },
                    "path": [
                      "1",
                      "3",
                      "0"
                    ],
                    "comment": "Copy age form to memory",
                    "name": null
                  },
                  {
                    "processor": "Send RedMetrics Event",
                    "pins": {
                      "in": {
                        "type": "\"filled form\"",
                        "redMetricsEvents": "io.metrics.events"
                      },
                      "out": {
                        "io.metrics.events": "pins.redMetricsEvents"
                      }
                    },
                    "children": [],
                    "path": [
                      "1",
                      "3",
                      "1"
                    ],
                    "comment": "Send filled form event",
                    "name": null
                  },
                  {
                    "processor": "Update Player in RedMetrics",
                    "pins": {
                      "in": {
                        "birthdate": "io.html.ageForm.values.age && (new Date(new Date().getFullYear() - io.html.ageForm.values.age, 0, 1))",
                        "gender": "io.html.ageForm.values.gender && io.html.ageForm.values.gender.toUpperCase()",
                        "redMetricsPlayer": "io.metrics.player"
                      },
                      "out": {
                        "io.metrics.player": "pins.redMetricsPlayer"
                      }
                    },
                    "children": [],
                    "path": [
                      "1",
                      "3",
                      "2"
                    ],
                    "comment": "Update player",
                    "name": null
                  },
                  {
                    "emitter": {
                      "io.html.ageForm": "undefined"
                    },
                    "path": [
                      "1",
                      "3",
                      "3"
                    ],
                    "comment": "Remove form",
                    "name": null
                  }
                ],
                "path": [
                  "1",
                  "3"
                ],
                "comment": "After age form filled",
                "name": null
              },
              {
                "pins": {
                  "in": {
                    "value": "!io.html.blocksForm || !io.html.blocksForm.values.done"
                  },
                  "out": {}
                },
                "children": [
                  {
                    "pins": {
                      "in": {
                        "shapes": "transformers.translateShapes(transformers.inverseVector(memory.gridTranslation), transformers.makeMovableBlockShapes(memory.constants.grid, memory.blocks, transformers.rgbColorString(memory.constants.blockColor), memory.constants.blockSize))",
                        "shape": "memory.mouseDetection.shape",
                        "mousePosition": "io.mouse.position",
                        "mouseDown": "io.mouse.down",
                        "state": "memory.mouseDetection.state",
                        "dragStartPosition": "memory.mouseDetection.dragStartPosition"
                      },
                      "out": {
                        "memory.mouseDetection.shape": "pins.shape",
                        "memory.mouseDetection.state": "pins.state",
                        "memory.mouseDetection.dragStartPosition": "pins.dragStartPosition"
                      }
                    },
                    "processor": "Detect Mouse",
                    "comment": "Detect mouse interaction with shapes",
                    "children": [],
                    "path": [
                      "1",
                      "4",
                      "0"
                    ]
                  },
                  {
                    "emitter": {
                      "io.canvas.blocks": "transformers.translateShapes(transformers.inverseVector(memory.gridTranslation), transformers.makeBlockShapes(memory.constants.grid, RW.difference(memory.blocks, memory.highlightedBlocks), transformers.rgbColorString(memory.constants.blockColor), memory.constants.blockSize))"
                    },
                    "comment": "Draw normal blocks",
                    "name": null,
                    "muted": false,
                    "path": [
                      "1",
                      "4",
                      "1"
                    ]
                  },
                  {
                    "emitter": {
                      "io.canvas.blocks": "transformers.translateShapes(transformers.inverseVector(memory.gridTranslation), transformers.makeBlockShapes(memory.constants.grid, memory.highlightedBlocks, transformers.rgbColorString(memory.constants.highlightedBlockColor), memory.constants.blockSize))"
                    },
                    "comment": "Draw highlighted blocks",
                    "name": null,
                    "muted": false,
                    "path": [
                      "1",
                      "4",
                      "2"
                    ]
                  },
                  {
                    "emitter": {
                      "io.canvas.gallery": "[{ type: 'rectangle', position: memory.constants.galleryGrid.upperLeft, size: transformers.gridSizeInPixels(memory.constants.galleryGrid), fillStyle: 'grey', strokeStyle: 'white', order: -1 }]"
                    },
                    "comment": "Draw gallery box",
                    "name": null,
                    "path": [
                      "1",
                      "4",
                      "3"
                    ],
                    "muted": false
                  },
                  {
                    "emitter": {
                      "memory.targetGridTranslation": "transformers.subtractVectors(transformers.meanOfCoordinates(transformers.listBlockCenters(memory.constants.grid, memory.blocks)), transformers.gridCenter(memory.constants.grid))"
                    },
                    "comment": "Update grid centering",
                    "path": [
                      "1",
                      "4",
                      "4"
                    ]
                  },
                  {
                    "pins": {
                      "in": {
                        "value": "memory.targetGridTranslation && transformers.distanceBetweenPoints(memory.gridTranslation, memory.targetGridTranslation) > memory.constants.minGridTranslation"
                      },
                      "out": {}
                    },
                    "children": [
                      {
                        "emitter": {
                          "memory.gridTranslation": "transformers.interpolateVector(memory.gridTranslation, memory.targetGridTranslation, 0.5)"
                        },
                        "comment": "Interpolate grid centering",
                        "path": [
                          "1",
                          "4",
                          "5",
                          "0"
                        ]
                      }
                    ],
                    "switch": "If",
                    "comment": "If we need to interpolate the grid centering",
                    "path": [
                      "1",
                      "4",
                      "5"
                    ]
                  },
                  {
                    "pins": {
                      "in": {
                        "value": "memory.mouseDetection.state"
                      }
                    },
                    "children": [
                      {
                        "name": "drag",
                        "comment": "If the mouse position is valid",
                        "pins": {
                          "in": {
                            "value": "io.mouse.position != null"
                          }
                        },
                        "children": [
                          {
                            "comment": "Draw the dragged shape and the 'move' mouse cursor",
                            "emitter": {
                              "io.mouse.cursor": "'move'",
                              "io.canvas.drag": "[transformers.makeDraggedShape(memory.constants.blockSize, transformers.rgbColorString(transformers.cyclicInterpolate(memory.constants.highlightedBlockColor, memory.constants.blockColor, memory.dragFrameCounter / memory.constants.dragHighlightPeriod)), io.mouse.position)]",
                              "memory.dragFrameCounter": "(memory.dragFrameCounter + 1) % memory.constants.dragHighlightPeriod"
                            },
                            "name": null,
                            "path": [
                              "1",
                              "4",
                              "6",
                              "0",
                              "0"
                            ]
                          }
                        ],
                        "switch": "If",
                        "path": [
                          "1",
                          "4",
                          "6",
                          "0"
                        ]
                      },
                      {
                        "name": "startDrag",
                        "comment": "Take the dragged block out of the list of normal blocks",
                        "emitter": {
                          "memory.blocks": "RW.removeFromArray(memory.blocks, memory.mouseDetection.shape.meta)",
                          "memory.dragFrameCounter": 0
                        },
                        "path": [
                          "1",
                          "4",
                          "6",
                          "1"
                        ]
                      },
                      {
                        "name": "endDrag",
                        "comment": "Put the block back in place, and start the highlighting",
                        "emitter": {
                          "memory.blockGroupsToBeHighlighted": "transformers.makeBlockGroupsToBeHighlighted(memory.blocks, transformers.findDroppedPosition(memory.constants.grid, memory.blocks, transformers.translatePoint(memory.gridTranslation, io.mouse.position)))",
                          "memory.blocks": "RW.appendToArray(memory.blocks, transformers.findDroppedPosition(memory.constants.grid, memory.blocks, transformers.translatePoint(memory.gridTranslation, io.mouse.position)))",
                          "memory.events": "RW.appendToArray(memory.events, { type: 'moved tile', time: transformers.makeTimestamp(io.time), shape: transformers.serializeBlocks(RW.appendToArray(memory.blocks, transformers.findDroppedPosition(memory.constants.grid, memory.blocks, transformers.translatePoint(memory.gridTranslation, io.mouse.position)))) })"
                        },
                        "path": [
                          "1",
                          "4",
                          "6",
                          "2"
                        ]
                      },
                      {
                        "name": "hover",
                        "comment": "Show the 'pointer' mouse cursor",
                        "emitter": {
                          "io.mouse.cursor": "'pointer'"
                        },
                        "path": [
                          "1",
                          "4",
                          "6",
                          "3"
                        ]
                      }
                    ],
                    "switch": "Switch on child name",
                    "comment": "Depending on the mouse detection state",
                    "path": [
                      "1",
                      "4",
                      "6"
                    ]
                  },
                  {
                    "emitter": {
                      "io.html.blocksForm": "{ asset: 'blocksForm', values: { done: false, galleryShapeCount: memory.gallery.length, canAddShape: memory.gallery.length < 12, ready: memory.gallery.length >= 5 } }"
                    },
                    "comment": "Draw the HTML form",
                    "path": [
                      "1",
                      "4",
                      "7"
                    ],
                    "name": null
                  },
                  {
                    "pins": {
                      "in": {
                        "value": "memory.blockGroupsToBeHighlighted.length > 0"
                      },
                      "out": {}
                    },
                    "children": [
                      {
                        "emitter": {
                          "memory.highlightedBlocks": "_.first(memory.blockGroupsToBeHighlighted)",
                          "memory.blockGroupsToBeHighlighted": "_.rest(memory.blockGroupsToBeHighlighted)"
                        },
                        "comment": "Update highlighted groups",
                        "path": [
                          "1",
                          "4",
                          "8",
                          "0"
                        ]
                      },
                      {
                        "emitter": {
                          "memory.highlightedBlocks": "[]"
                        },
                        "comment": "Otherwise remove highlighting",
                        "path": [
                          "1",
                          "4",
                          "8",
                          "1"
                        ]
                      }
                    ],
                    "switch": "If",
                    "comment": "If groups need to be highlighted",
                    "path": [
                      "1",
                      "4",
                      "8"
                    ]
                  },
                  {
                    "switch": "When",
                    "pins": {
                      "in": {
                        "value": "io.html.blocksForm && io.html.blocksForm.values.addShape"
                      },
                      "out": {}
                    },
                    "children": [
                      {
                        "emitter": {
                          "memory.gallery": "RW.appendToArray(memory.gallery, memory.blocks)"
                        },
                        "comment": "Save the shape in the gallery",
                        "path": [
                          "1",
                          "4",
                          "9",
                          "0"
                        ],
                        "name": null
                      },
                      {
                        "processor": "Send RedMetrics Event",
                        "pins": {
                          "in": {
                            "type": "\"added shape to gallery\"",
                            "customData": "memory.blocks",
                            "redMetricsEvents": "io.metrics.events"
                          },
                          "out": {
                            "io.metrics.events": "pins.redMetricsEvents"
                          }
                        },
                        "children": [],
                        "path": [
                          "1",
                          "4",
                          "9",
                          "1"
                        ],
                        "comment": "Send added shape event",
                        "name": null
                      }
                    ],
                    "path": [
                      "1",
                      "4",
                      "9"
                    ],
                    "comment": "When they press the add button",
                    "name": null
                  },
                  {
                    "pins": {
                      "in": {
                        "value": "memory.gallery.length > 0"
                      },
                      "out": {}
                    },
                    "children": [
                      {
                        "emitter": {
                          "io.canvas.gallery": "transformers.translateShapes(transformers.inverseVector(transformers.findCenterOfCells(memory.constants.galleryGrid, _.last(memory.gallery))), transformers.makeBlockShapes(memory.constants.galleryGrid, _.last(memory.gallery), transformers.rgbColorString(memory.constants.blockColor), memory.constants.galleryBlockSize))"
                        },
                        "comment": "Draw the last gallery shape",
                        "name": null,
                        "path": [
                          "1",
                          "4",
                          "10",
                          "0"
                        ],
                        "muted": false
                      }
                    ],
                    "switch": "If",
                    "comment": "If the gallery isn't empty",
                    "path": [
                      "1",
                      "4",
                      "10"
                    ]
                  }
                ],
                "switch": "Do While",
                "comment": "Until they have created all their forms",
                "path": [
                  "1",
                  "4"
                ],
                "name": null
              },
              {
                "switch": "Do All",
                "pins": {
                  "in": {},
                  "out": {}
                },
                "children": [
                  {
                    "processor": "Send RedMetrics Event",
                    "pins": {
                      "in": {
                        "type": "\"found shapes\"",
                        "redMetricsEvents": "io.metrics.events"
                      },
                      "out": {
                        "io.metrics.events": "pins.redMetricsEvents"
                      }
                    },
                    "children": [],
                    "path": [
                      "1",
                      "5",
                      "0"
                    ],
                    "comment": "Send found shapes event",
                    "name": null
                  },
                  {
                    "emitter": {
                      "io.html.blocksForm": "undefined"
                    },
                    "path": [
                      "1",
                      "5",
                      "1"
                    ],
                    "comment": "Remove blocks form",
                    "name": null
                  },
                  {
                    "emitter": {
                      "memory.selectionGrids": "transformers.makeSelectionGalleryGrids(memory.constants.selectionGrid, memory.constants.galleryGrid, memory.gallery)",
                      "memory.events": "RW.appendToArray(memory.events, { type: 'began gallery selection', time: transformers.makeTimestamp(io.time) })"
                    },
                    "comment": "Make grids for gallery selection",
                    "path": [
                      "1",
                      "5",
                      "2"
                    ],
                    "name": null
                  }
                ],
                "path": [
                  "1",
                  "5"
                ],
                "comment": "After all shapes are found",
                "name": null
              },
              {
                "pins": {
                  "in": {
                    "value": "!io.html.selectionForm || !io.html.selectionForm.values.done"
                  },
                  "out": {}
                },
                "children": [
                  {
                    "splitter": {
                      "from": "memory.selectionGrids",
                      "bindTo": "selectionGrid",
                      "index": "selectionGridIndex"
                    },
                    "children": [
                      {
                        "emitter": {
                          "io.canvas.gallery": "transformers.makeSelectionGalleryShapes(memory.selectionGrids, memory.selectedGalleryIndexes)"
                        },
                        "comment": "Draw the selection grid",
                        "name": null,
                        "path": [
                          "1",
                          "6",
                          "0",
                          "0"
                        ]
                      },
                      {
                        "emitter": {
                          "io.canvas.blocks": "transformers.translateShapes(transformers.inverseVector(transformers.findCenterOfCells(bindings.selectionGrid, memory.gallery[bindings.selectionGridIndex])), transformers.makeBlockShapes(bindings.selectionGrid, memory.gallery[bindings.selectionGridIndex], transformers.rgbColorString(memory.constants.blockColor), memory.constants.galleryBlockSize))"
                        },
                        "comment": "Draw the blocks on the grid",
                        "name": null,
                        "path": [
                          "1",
                          "6",
                          "0",
                          "1"
                        ]
                      }
                    ],
                    "comment": "For each selection grid",
                    "path": [
                      "1",
                      "6",
                      "0"
                    ]
                  },
                  {
                    "pins": {
                      "in": {
                        "shapes": "_.map(memory.selectionGrids, transformers.makeGridCoveringRectangle, transformers)",
                        "shape": "memory.mouseDetection.shape",
                        "mousePosition": "io.mouse.position",
                        "mouseDown": "io.mouse.down",
                        "state": "memory.mouseDetection.state",
                        "dragStartPosition": "memory.mouseDetection.dragStartPosition"
                      },
                      "out": {
                        "memory.mouseDetection.shape": "pins.shape",
                        "memory.mouseDetection.state": "pins.state",
                        "memory.mouseDetection.dragStartPosition": "pins.dragStartPosition"
                      }
                    },
                    "processor": "Detect Mouse",
                    "comment": "Listen to mouse selection",
                    "children": [],
                    "path": [
                      "1",
                      "6",
                      "1"
                    ]
                  },
                  {
                    "pins": {
                      "in": {
                        "value": "memory.mouseDetection.state"
                      }
                    },
                    "children": [
                      {
                        "name": "hover",
                        "comment": "Show the 'pointer' cursor",
                        "emitter": {
                          "io.mouse.cursor": "'pointer'"
                        },
                        "path": [
                          "1",
                          "6",
                          "2",
                          "0"
                        ]
                      },
                      {
                        "switch": "Do All",
                        "pins": {
                          "in": {},
                          "out": {}
                        },
                        "children": [
                          {
                            "name": null,
                            "comment": "Toggle the gallery as being selected or not",
                            "emitter": {
                              "memory.selectedGalleryIndexes": "RW.toggleValueInArray(memory.selectedGalleryIndexes, memory.mouseDetection.shape.meta)"
                            },
                            "path": [
                              "1",
                              "6",
                              "2",
                              "1",
                              "0"
                            ]
                          },
                          {
                            "processor": "Send RedMetrics Event",
                            "pins": {
                              "in": {
                                "type": "\"selected shape\"",
                                "customData": "{\n    shape: memory.gallery[memory.mouseDetection.shape.meta]\n}",
                                "redMetricsEvents": "memory.events"
                              },
                              "out": {
                                "memory.events": "pins.redMetricsEvents"
                              }
                            },
                            "children": [],
                            "path": [
                              "1",
                              "6",
                              "2",
                              "1",
                              "1"
                            ],
                            "comment": "Send selected gallery shape event",
                            "name": null
                          }
                        ],
                        "path": [
                          "1",
                          "6",
                          "2",
                          "1"
                        ],
                        "name": "click"
                      }
                    ],
                    "switch": "Switch on child name",
                    "comment": "Depending on the mouse state...",
                    "path": [
                      "1",
                      "6",
                      "2"
                    ]
                  },
                  {
                    "emitter": {
                      "io.html.selectionForm": "{ asset: 'selectionForm', values: { done: false, ready: memory.selectedGalleryIndexes.length >= 1 } }"
                    },
                    "comment": "Draw selection HTML form",
                    "path": [
                      "1",
                      "6",
                      "3"
                    ],
                    "name": null
                  }
                ],
                "switch": "Do While",
                "comment": "Until the selection is finished",
                "path": [
                  "1",
                  "6"
                ],
                "name": null
              },
              {
                "processor": "Send RedMetrics Event",
                "pins": {
                  "in": {
                    "type": "\"completed selection\"",
                    "customData": "",
                    "redMetricsEvents": "io.metrics.events"
                  },
                  "out": {
                    "io.metrics.events": "pins.redMetricsEvents"
                  }
                },
                "children": [],
                "path": [
                  "1",
                  "7"
                ],
                "comment": "Send Completed Selection event",
                "name": null
              },
              {
                "pins": {
                  "in": {
                    "value": "!io.html.thanksForm || !io.html.thanksForm.values.done"
                  },
                  "out": {}
                },
                "children": [
                  {
                    "emitter": {
                      "io.html.thanksForm": "{ asset: 'thanksForm', values: { done: false } }"
                    },
                    "comment": "Draw the thank you form",
                    "path": [
                      "1",
                      "8",
                      "0"
                    ],
                    "name": null
                  },
                  {
                    "emitter": {
                      "io.html.selectionForm": "undefined"
                    },
                    "path": [
                      "1",
                      "8",
                      "1"
                    ],
                    "comment": "Remove the selection form",
                    "name": null
                  }
                ],
                "switch": "Do While",
                "comment": "Until the player hits the button",
                "path": [
                  "1",
                  "8"
                ],
                "name": null
              },
              {
                "emitter": {
                  "io.html.thanksForm": "undefined"
                },
                "path": [
                  "1",
                  "9"
                ],
                "comment": "Play again",
                "name": null
              }
            ],
            "switch": "Do One at a Time",
            "comment": "Step through the game",
            "path": [
              "1"
            ]
          }
        ],
        "switch": "Do All",
        "comment": "Play the game",
        "pins": {
          "in": {},
          "out": {}
        },
        "path": []
      },
      "io": {
        "layers": [
          {
            "name": "bg",
            "type": "canvas"
          },
          {
            "name": "gallery",
            "type": "canvas"
          },
          {
            "name": "blocks",
            "type": "canvas"
          },
          {
            "name": "drag",
            "type": "canvas"
          },
          {
            "name": "ageForm",
            "type": "html"
          },
          {
            "name": "blocksForm",
            "type": "html"
          },
          {
            "name": "selectionForm",
            "type": "html"
          },
          {
            "name": "thanksForm",
            "type": "html"
          }
        ],
        "channels": []
      }
    }
  },
  "processors": {
    "Change Parameter through Keyboard": {
      "pinDefs": {
        "parameter": {
          "direction": "inout"
        },
        "keysDown": null,
        "keyMap": null
      },
      "update": "for (var keyCode in pins.keyMap) {\n  if (pins.keysDown[keyCode]) {\n    var value = pins.keyMap[keyCode];\n    if (_.isString(value) && value.length > 0 && (value[0] == '+' || value[0] == '-')) {\n      pins.parameter += Number(value);\n    } else {\n      pins.parameter = value;\n    }\n    break;\n  }\n}"
    },
    "Move thing with arrow keys": {
      "pinDefs": {
        "keysDown": {
          "direction": "in",
          "default": ""
        },
        "position": {
          "direction": "inout",
          "default": null
        },
        "speed": {
          "direction": "in",
          "default": "1"
        }
      },
      "update": "if(pins.keysDown[37]) pins.position[0] -= pins.speed;\nif(pins.keysDown[39]) pins.position[0] += pins.speed;\nif(pins.keysDown[38]) pins.position[1] -= pins.speed;\nif(pins.keysDown[40]) pins.position[1] += pins.speed;"
    },
    "Detect Mouse": {
      "pinDefs": {
        "shapes": null,
        "shape": {
          "direction": "inout"
        },
        "mousePosition": null,
        "mouseDown": null,
        "state": {
          "direction": "inout"
        },
        "dragStartPosition": {
          "direction": "inout"
        },
        "minimumDragDistance": {
          "default": "5"
        }
      },
      "update": "if (!pins.state)\n  pins.state = 'none';\nswitch (pins.state) {\ncase 'none':\n  if (pins.mousePosition) {\n    for (var i in pins.shapes) {\n      if (transformers.pointIntersectsShape(pins.mousePosition, pins.shapes[i])) {\n        log(RW.logLevels.INFO, 'Entering hover mode. Old state = ' + pins.state);\n        pins.state = 'hover';\n        pins.shape = pins.shapes[i];\n        break;\n      }\n    }\n  }\n  break;\ncase 'hover':\n  if (!pins.mousePosition || !transformers.pointIntersectsShape(pins.mousePosition, pins.shape)) {\n    pins.state = 'none';\n    pins.shape = null;\n    log(RW.logLevels.INFO, 'Leaving hover mode');\n  } else if (pins.mouseDown) {\n    pins.dragStartPosition = pins.mousePosition;\n    pins.state = 'pressed';\n    log(RW.logLevels.INFO, 'Entering presed mode');\n  }\n  break;\ncase 'pressed':\n  if (!pins.mouseDown) {\n    pins.state = 'click';\n    pins.dragStartPosition = null;\n    log(RW.logLevels.INFO, 'Leaving pressed mode');\n  } else if (Vector.create(pins.dragStartPosition).distanceFrom(Vector.create(pins.mousePosition)) >= pins.minimumDragDistance) {\n    pins.state = 'startDrag';\n    pins.dragStartPosition = null;\n    log(RW.logLevels.INFO, 'Entering drag mode');\n  }\n  break;\ncase 'click':\n  pins.state = 'hover';\n  break;\ncase 'startDrag':\n  pins.state = 'drag';\n  break;\ncase 'drag':\n  if (!pins.mouseDown) {\n    pins.state = 'endDrag';\n    pins.dragStartPosition = null;\n    log(RW.logLevels.INFO, 'Leaving drag mode');\n  }\n  break;\ncase 'endDrag':\n  pins.state = 'hover';\n  break;\ndefault:\n  throw new Error('Unknown state \\'' + pins.state + '\\'');\n}"
    },
    "Update HTML Template": {
      "pinDefs": {
        "htmlService": {
          "direction": "inout"
        },
        "memoryValues": {
          "direction": "inout"
        },
        "assetName": null,
        "templateName": null
      },
      "update": "if (!pins.htmlService.receive[pins.templateName]) {\n  pins.htmlService.send[pins.templateName] = {\n    asset: pins.assetName,\n    values: pins.memoryValues\n  };\n} else {\n  pins.memoryValues = pins.htmlService.receive[pins.templateName].values;\n  pins.htmlService.send[pins.templateName] = pins.htmlService.receive[pins.templateName];\n}"
    }
  },
  "switches": {
    "Do One at a Time": {
      "pinDefs": {
        "activeChild": {
          "direction": "inout",
          "default": 0
        }
      },
      "listActiveChildren": "return [children[pins.activeChild]];",
      "handleSignals": "if (signals[pins.activeChild] == RW.signals.DONE)\n  pins.activeChild++;\nif (pins.activeChild > children.length - 1) {\n  pins.activeChild = 0;\n  return RW.signals.DONE;\n}"
    },
    "Do for Some Time": {
      "pinDefs": {
        "time": null,
        "timer": {
          "direction": "inout"
        }
      },
      "listActiveChildren": "return children;",
      "handleSignals": "if (pins.timer++ >= pins.time) {\n  pins.timer = 0;\n  return RW.signals.DONE;\n}"
    },
    "Do While": {
      "pinDefs": {
        "value": null
      },
      "listActiveChildren": "return !!pins.value ? children : [];",
      "handleSignals": "if (!pins.value)\n  return RW.signals.DONE;"
    },
    "Do Forever": {
      "pinDefs": {},
      "listActiveChildren": "return children;",
      "handleSignals": ""
    },
    "If": {
      "pinDefs": {
        "value": null
      },
      "listActiveChildren": "return pins.value ? [children[0]] : children.length > 1 ? [children[1]] : [];"
    },
    "Sandwhich": {
      "pinDefs": {
        "condition": null,
        "started": {
          "direction": "inout"
        }
      },
      "listActiveChildren": "if (!pins.track) {\n  if (!pins.condition) {\n    return [children[0]];\n  } else {\n    pins.track = true;\n    return [children[1]];\n  }\n} else {\n  if (pins.condition) {\n    return [children[1]];\n  } else {\n    pins.track = false;\n    return [children[2]];\n  }\n}"
    },
    "Limit Rate": {
      "pinDefs": {
        "currentTime": null,
        "minTime": null,
        "lastTime": {
          "direction": "inout"
        }
      },
      "listActiveChildren": "return pins.currentTime - pins.lastTime >= pins.minTime ? children : [];",
      "handleSignals": "if(signals[0] == RW.signals.DONE) pins.lastTime = pins.currentTime;"
    },
    "Switch on child name": {
      "pinDefs": {
        "value": {
          "direction": "in",
          "default": ""
        }
      },
      "listActiveChildren": "if(RW.indexOf(children, pins.value) == -1) return [];\nelse return [pins.value];"
    }
  },
  "transformers": {
    "drawShape": {
      "args": [
        "shape",
        "oldShapes"
      ],
      "body": "var shapes = oldShapes || {};\nshapes[_.uniqueId()] = shape;\nreturn shapes;"
    },
    "pointIntersectsShape": {
      "args": [
        "point",
        "shape"
      ],
      "body": "if (!shape.fillStyle && !shape.strokeStyle)\n  return false;\nswitch (shape.type) {\ncase 'circle':\n  var center = Vector.create(shape.center);\n  if (shape.translation)\n    center = center.add(shape.translation);\n  var lineWidth = shape.lineWidth || 1;\n  var scale = shape.scale || 1;\n  var minDistance = shape.fillStyle ? 0 : shape.radius - lineWidth;\n  var maxDistance = shape.strokeStyle ? shape.radius + lineWidth : shape.radius;\n  var distance = center.distanceFrom(Vector.create(point));\n  return distance >= minDistance * scale && distance <= maxDistance * scale;\ncase 'rectangle':\n  var pointInShapeFrame = Vector.create(point);\n  if (shape.translation)\n    pointInShapeFrame = pointInShapeFrame.subtract(shape.translation);\n  return pointInShapeFrame.elements[0] >= shape.position[0] && pointInShapeFrame.elements[0] <= shape.position[0] + shape.size[0] && pointInShapeFrame.elements[1] >= shape.position[1] && pointInShapeFrame.elements[1] <= shape.position[1] + shape.size[1];\ndefault:\n  throw new Error('Shape type \\'' + shape.type + '\\' is not supported');\n}"
    },
    "removeElement": {
      "args": [
        "tab",
        "index"
      ],
      "body": "var newArray = [];\nfor (var i = 0; i < tab.length; i++) {\n  if (i != index)\n    newArray.push(tab[i]);\n}\nreturn newArray;"
    },
    "gridCellAtPoint": {
      "args": [
        "grid",
        "point"
      ],
      "body": "if (point === null)\n  return null;\nvar gridPos = [\n    Math.floor((point[0] - grid.upperLeft[0]) / grid.cellSize[0]),\n    Math.floor((point[1] - grid.upperLeft[1]) / grid.cellSize[1])\n  ];\nif (grid.type != 'infinite' && (gridPos[0] < 0 || gridPos[0] > grid.gridSize[0] || gridPos[1] < 0 || gridPos[1] > grid.gridSize[1]))\n  return null;\nelse\n  return gridPos;"
    },
    "gridCellToPoint": {
      "args": [
        "grid",
        "cell",
        "proportions"
      ],
      "body": "return [\n  (cell[0] + proportions[0]) * grid.cellSize[0] + grid.upperLeft[0],\n  (cell[1] + proportions[1]) * grid.cellSize[1] + grid.upperLeft[1]\n];"
    },
    "gridCellUpperLeft": {
      "args": [
        "grid",
        "cell"
      ],
      "body": "return transformers.gridCellToPoint(grid, cell, [\n  0,\n  0\n]);"
    },
    "gridCellCenter": {
      "args": [
        "grid",
        "cell"
      ],
      "body": "return transformers.gridCellToPoint(grid, cell, [\n  0.5,\n  0.5\n]);"
    },
    "gridCellRectangle": {
      "args": [
        "grid",
        "cell",
        "meta"
      ],
      "body": "return {\n  type: 'rectangle',\n  position: transformers.gridCellUpperLeft(grid, cell),\n  size: grid.cellSize,\n  meta: meta\n};"
    },
    "gridSizeInPixels": {
      "args": [
        "grid"
      ],
      "body": "return [\n  grid.cellSize[0] * grid.gridSize[0],\n  grid.cellSize[1] * grid.gridSize[1]\n];"
    },
    "gridIndexToCell": {
      "args": [
        "grid",
        "index"
      ],
      "body": "return [\n  index % grid.gridSize[0],\n  Math.floor(index / grid.gridSize[0])\n];"
    },
    "calculateRotationAngle": {
      "args": [
        "center",
        "mousePosition"
      ],
      "body": "var h = [\n    mousePosition[0] - center[0],\n    mousePosition[1] - center[1]\n  ];\nvar omDistance = Math.sqrt(h[0] * h[0] + h[1] * h[1]);\nvar ratio = -h[1] / omDistance;\nvar angle = 0;\nif (omDistance !== 0) {\n  var absValueAngle = Math.acos(ratio) * 180 / Math.PI;\n  if (h[0] <= 0) {\n    angle = -absValueAngle;\n  } else {\n    angle = absValueAngle;\n  }\n}\nreturn angle;"
    },
    "calculateRotationOffset": {
      "args": [
        "rotation",
        "center",
        "mousePosition"
      ],
      "body": "return rotation - transformers.calculateRotationAngle(center, mousePosition);"
    },
    "calculateRotation": {
      "args": [
        "rotationOffset",
        "center",
        "mousePosition"
      ],
      "body": "return transformers.calculateRotationAngle(center, mousePosition) + rotationOffset;"
    },
    "childByName": {
      "args": [
        "children",
        "value"
      ],
      "body": "var childIndex = RW.indexOf(children, value);\nreturn childIndex != -1 ? [childIndex] : [];"
    },
    "makeFilledRectangle": {
      "args": [
        "grid",
        "cell",
        "meta"
      ],
      "body": "return _.extend(transformers.gridCellRectangle(grid, cell, meta), {\n  strokeStyle: 'white',\n  fillStyle: 'white'\n});"
    },
    "makeGridCoveringRectangle": {
      "args": [
        "grid",
        "meta"
      ],
      "body": "return {\n  meta: meta,\n  type: 'rectangle',\n  position: grid.upperLeft,\n  size: transformers.gridSizeInPixels(grid),\n  strokeStyle: 'white',\n  fillStyle: 'white'\n};"
    },
    "meanOfCoordinates": {
      "args": [
        "coordinates"
      ],
      "body": "var sum = _.reduce(coordinates, function (memo, cell) {\n    return [\n      memo[0] + cell[0],\n      memo[1] + cell[1]\n    ];\n  }, [\n    0,\n    0\n  ]);\nreturn [\n  sum[0] / coordinates.length,\n  sum[1] / coordinates.length\n];"
    },
    "findCenterOfCells": {
      "args": [
        "grid",
        "cells"
      ],
      "body": "if (cells.length == 0)\n  return [\n    0,\n    0\n  ];\nvar gridCenter = transformers.gridCenter(grid);\nvar sum = _.reduce(cells, function (memo, cell) {\n    return [\n      memo[0] + cell[0] + 0.5,\n      memo[1] + cell[1] + 0.5\n    ];\n  }, [\n    0,\n    0\n  ]);\nreturn [\n  sum[0] * grid.cellSize[0] / cells.length - gridCenter[0],\n  sum[1] * grid.cellSize[1] / cells.length - gridCenter[1]\n];"
    },
    "listBlockCenters": {
      "args": [
        "grid",
        "blocks"
      ],
      "body": "return _.map(blocks, function (block) {\n  return [\n    (block[0] + 0.5) * grid.cellSize[0],\n    (block[1] + 0.5) * grid.cellSize[1]\n  ];\n});"
    },
    "gridCenter": {
      "args": [
        "grid"
      ],
      "body": "return [\n  grid.cellSize[0] * grid.gridSize[0] / 2,\n  grid.cellSize[1] * grid.gridSize[1] / 2\n];"
    },
    "makeBlockShapes": {
      "args": [
        "grid",
        "blocks",
        "blockColor",
        "blockSize"
      ],
      "body": "var that = transformers;\nreturn _.map(blocks, function (block) {\n  return _.extend(that.gridCellRectangle(grid, block, block), {\n    layer: 'blocks',\n    fillStyle: blockColor,\n    size: blockSize\n  });\n});"
    },
    "makeMovableBlockShapes": {
      "args": [
        "grid",
        "blocks",
        "blockColor",
        "blockSize"
      ],
      "body": "var that = transformers;\nvar movableBlocks = _.filter(blocks, function (block) {\n    return that.canMoveBlock(blocks, block);\n  });\nreturn _.map(movableBlocks, function (block) {\n  return _.extend(that.gridCellRectangle(grid, block, block), {\n    layer: 'blocks',\n    fillStyle: blockColor,\n    size: blockSize\n  });\n});"
    },
    "makeDraggedShape": {
      "args": [
        "size",
        "color",
        "mousePosition"
      ],
      "body": "return {\n  layer: 'drag',\n  type: 'rectangle',\n  position: [\n    mousePosition[0] - size[0] / 2,\n    mousePosition[1] - size[1] / 2\n  ],\n  size: size,\n  fillStyle: color\n};"
    },
    "drawShapes": {
      "args": [
        "shapes"
      ],
      "body": "var that = transformers;\nreturn _.reduce(shapes, function (memo, shape) {\n  return that.drawShape(shape, memo);\n}, {});"
    },
    "blocksAreNeighbors": {
      "args": [
        "a",
        "b"
      ],
      "body": "var diff = [\n    Math.abs(a[0] - b[0]),\n    Math.abs(a[1] - b[1])\n  ];\nreturn diff[0] == 1 && diff[1] == 0 || diff[0] == 0 && diff[1] == 1;"
    },
    "makeAdjacencyList": {
      "args": [
        "blocks"
      ],
      "body": "var adjList = _.map(blocks, function () {\n    return [];\n  });\nfor (var i = 0; i < blocks.length - 1; i++) {\n  for (var j = i + 1; j < blocks.length; j++) {\n    if (transformers.blocksAreNeighbors(blocks[i], blocks[j])) {\n      adjList[i].push(j);\n      adjList[j].push(i);\n    }\n  }\n}\nreturn adjList;"
    },
    "visitBlocks": {
      "args": [
        "adjList",
        "startingIndices"
      ],
      "body": "var visited = [startingIndices];\nwhile (true) {\n  var toVisit = _.reduce(visited[visited.length - 1], function (memo, visitingIndex) {\n      return memo.concat(adjList[visitingIndex]);\n    }, []);\n  toVisit = _.uniq(toVisit);\n  toVisit = _.difference.apply(_, [toVisit].concat(visited));\n  if (toVisit.length > 0) {\n    visited.push(toVisit);\n  } else {\n    return visited;\n  }\n}"
    },
    "canMoveBlock": {
      "args": [
        "blocks",
        "block"
      ],
      "body": "var blocksWithout = transformers.removeElement(blocks, RW.indexOf(blocks, block));\nvar adjList = transformers.makeAdjacencyList(blocksWithout);\nvar visited = transformers.visitBlocks(adjList, [0]);\nreturn _.flatten(visited).length == blocksWithout.length;"
    },
    "findFreeBlockPositions": {
      "args": [
        "blocks"
      ],
      "body": "var freePositions = [];\n_.each(blocks, function (block) {\n  freePositions.push([\n    block[0] + 1,\n    block[1]\n  ]);\n  freePositions.push([\n    block[0] - 1,\n    block[1]\n  ]);\n  freePositions.push([\n    block[0],\n    block[1] + 1\n  ]);\n  freePositions.push([\n    block[0],\n    block[1] - 1\n  ]);\n});\nfreePositions = RW.uniq(freePositions);\nreturn RW.difference(freePositions, blocks);"
    },
    "distanceBetweenPoints": {
      "args": [
        "a",
        "b"
      ],
      "body": "return Vector.create(a).distanceFrom(Vector.create(b));"
    },
    "translateShapes": {
      "args": [
        "translation",
        "shapes"
      ],
      "body": "var newShapes = _.map(shapes, function (shape) {\n    return _.extend(shape, {\n      position: [\n        shape.position[0] + translation[0],\n        shape.position[1] + translation[1]\n      ]\n    });\n  });\nreturn newShapes;"
    },
    "translatePoint": {
      "args": [
        "translation",
        "point"
      ],
      "body": "return [\n  point[0] + translation[0],\n  point[1] + translation[1]\n];"
    },
    "inverseVector": {
      "args": [
        "vector"
      ],
      "body": "return [\n  -vector[0],\n  -vector[1]\n];"
    },
    "subtractVectors": {
      "args": [
        "a",
        "b"
      ],
      "body": "return [\n  a[0] - b[0],\n  a[1] - b[1]\n];"
    },
    "makeSelectionGalleryGrids": {
      "args": [
        "selectionGrid",
        "galleryGrid",
        "gallery"
      ],
      "body": "var that = transformers;\nreturn _.map(_.range(gallery.length), function (index) {\n  var cell = that.gridIndexToCell(selectionGrid, index);\n  return {\n    type: 'infinite',\n    'upperLeft': that.gridCellUpperLeft(selectionGrid, cell),\n    'cellSize': galleryGrid.cellSize,\n    'gridSize': galleryGrid.gridSize\n  };\n});"
    },
    "makeSelectionGalleryShapes": {
      "args": [
        "selectionGrids",
        "selectedGalleryIndexes"
      ],
      "body": "var that = transformers;\nreturn _.map(selectionGrids, function (selectionGrid, index) {\n  return _.extend(that.makeGridCoveringRectangle(selectionGrid, index), {\n    fillStyle: RW.contains(selectedGalleryIndexes, index) ? 'red' : 'grey',\n    strokeStyle: 'white',\n    layer: 'gallery'\n  });\n});"
    },
    "serializeBlocks": {
      "args": [
        "blocks"
      ],
      "body": "var min = _.reduce(blocks, function (memo, block) {\n    return [\n      Math.min(memo[0], block[0]),\n      Math.min(memo[1], block[1])\n    ];\n  }, [\n    Infinity,\n    Infinity\n  ]);\nvar rowNumbers = _.map(_.range(10), function () {\n    return 0;\n  });\n_.each(blocks, function (block) {\n  var index = block[1] - min[1];\n  rowNumbers[index] = rowNumbers[index] | 1 << 9 - (block[0] - min[0]);\n});\nreturn rowNumbers;"
    },
    "makeTimestamp": {
      "args": [
        "ms"
      ],
      "body": "return new Date(ms).toUTCString();"
    },
    "findDroppedPosition": {
      "args": [
        "grid",
        "blocks",
        "mousePosition"
      ],
      "body": "var that = transformers;\nvar hoveredCell = transformers.gridCellAtPoint(grid, mousePosition);\nif (!hoveredCell)\n  return blocks;\nvar freeBlockPositions = transformers.findFreeBlockPositions(blocks);\nreturn _.min(freeBlockPositions, function (block) {\n  return that.distanceBetweenPoints(hoveredCell, block);\n});"
    },
    "makeBlockGroupsToBeHighlighted": {
      "args": [
        "blocks",
        "newPosition"
      ],
      "body": "log(RW.logLevels.INFO, 'makeBlockGroupsToBeHighlighted', arguments);\nvar newBlocks = RW.appendToArray(blocks, newPosition);\nvar adjList = transformers.makeAdjacencyList(newBlocks);\nvar visitedBlockIndexes = _.rest(transformers.visitBlocks(adjList, [newBlocks.length - 1]));\nreturn _.map(visitedBlockIndexes, function (blockIndexes) {\n  return _.map(blockIndexes, function (index) {\n    return newBlocks[index];\n  });\n});"
    },
    "adjustShapesByMeta": {
      "args": [
        "shapes",
        "meta",
        "properties"
      ],
      "body": "return _.map(shapes, function (shape) {\n  if (_.isEqual(shape.meta, meta)) {\n    return _.extend(RW.clone(shape), properties);\n  } else {\n    return shape;\n  }\n});"
    },
    "interpolateVector": {
      "args": [
        "start",
        "end",
        "fraction"
      ],
      "body": "return _.map(_.zip(start, end), function (pair) {\n  return pair[0] + fraction * (pair[1] - pair[0]);\n});"
    },
    "cyclicInterpolate": {
      "args": [
        "start",
        "end",
        "fraction"
      ],
      "body": "return fraction < 0.5 ? transformers.interpolateVector(start, end, fraction / 0.5) : transformers.interpolateVector(end, start, (fraction - 0.5) / 0.5);"
    },
    "rgbColorString": {
      "args": [
        "colorArray"
      ],
      "body": "var flooredArray = _.map(colorArray, function (value) {\n    return Math.floor(value);\n  });\nreturn 'rgb(' + flooredArray.join(', ') + ')';"
    },
    "makeTrackingString": {
      "args": [
        "player",
        "events"
      ],
      "body": "return JSON.stringify({\n  player: player,\n  events: events\n});"
    }
  },
  "assets": {
    "colour": "data:application/javascript;base64,LyoKCkNvbG91ci5qcwoKT2JqZWN0cyBmb3IgaGFuZGxpbmcgYW5kIHByb2Nlc3NpbmcgY29sb3VycwoKQ3JlYXRlZCBieSBTdGVwaGVuIE1vcmxleSAtIGh0dHA6Ly9jb2RlLnN0ZXBoZW5tb3JsZXkub3JnLyAtIGFuZCByZWxlYXNlZCB1bmRlcgp0aGUgdGVybXMgb2YgdGhlIENDMCAxLjAgVW5pdmVyc2FsIGxlZ2FsIGNvZGU6CgpodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9wdWJsaWNkb21haW4vemVyby8xLjAvbGVnYWxjb2RlCgoqLwoKLyogQW4gYWJzdHJhY3QgQ29sb3VyIGltcGxlbWVudGF0aW9uLiBDb25jcmV0ZSBDb2xvdXIgaW1wbGVtZW50YXRpb25zIHNob3VsZCB1c2UKICogYW4gaW5zdGFuY2Ugb2YgdGhpcyBmdW5jdGlvbiBhcyB0aGVpciBwcm90b3R5cGUsIGFuZCBpbXBsZW1lbnQgdGhlIGdldFJHQiBhbmQKICogZ2V0SFNMIGZ1bmN0aW9ucy4gZ2V0UkdCIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgUkdCCiAqIGNvbXBvbmVudHMgb2YgdGhpcyBDb2xvdXIsIHdpdGggdGhlIHJlZCwgZ3JlZW4sIGFuZCBibHVlIGNvbXBvbmVudHMgaW4gdGhlCiAqIHJhbmdlIFswLDI1NV0gYW5kIHRoZSBhbHBoYSBjb21wb25lbnQgaW4gdGhlIHJhbmdlIFswLDEwMF0uIGdldEhTTCBzaG91bGQKICogcmV0dXJuIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIEhTTCBjb21wb25lbnRzIG9mIHRoaXMgQ29sb3VyLCB3aXRoIHRoZSBodWUKICogY29tcG9uZW50IGluIHRoZSByYW5nZSBbMCwzNjApLCB0aGUgc2F0dXJhdGlvbiBhbmQgbGlnaHRuZXNzIGNvbXBvbmVudHMgaW4KICogdGhlIHJhbmdlIFswLDEwMF0sIGFuZCB0aGUgYWxwaGEgY29tcG9uZW50IGluIHRoZSByYW5nZSBbMCwxXS4KICovCmZ1bmN0aW9uIENvbG91cigpewoKICAvKiBSZXR1cm5zIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIFJHQkEgY29tcG9uZW50cyBvZiB0aGlzIENvbG91ci4gVGhlIHJlZCwKICAgKiBncmVlbiwgYW5kIGJsdWUgY29tcG9uZW50cyBhcmUgY29udmVydGVkIHRvIGludGVnZXJzIGluIHRoZSByYW5nZSBbMCwyNTVdLgogICAqIFRoZSBhbHBoYSBpcyBhIHZhbHVlIGluIHRoZSByYW5nZSBbMCwxXS4KICAgKi8KICB0aGlzLmdldEludGVnZXJSR0IgPSBmdW5jdGlvbigpewoKICAgIC8vIGdldCB0aGUgUkdCIGNvbXBvbmVudHMgb2YgdGhpcyBjb2xvdXIKICAgIHZhciByZ2IgPSB0aGlzLmdldFJHQigpOwoKICAgIC8vIHJldHVybiB0aGUgaW50ZWdlciBjb21wb25lbnRzCiAgICByZXR1cm4gewogICAgICAncicgOiBNYXRoLnJvdW5kKHJnYi5yKSwKICAgICAgJ2cnIDogTWF0aC5yb3VuZChyZ2IuZyksCiAgICAgICdiJyA6IE1hdGgucm91bmQocmdiLmIpLAogICAgICAnYScgOiByZ2IuYQogICAgfTsKCiAgfTsKCiAgLyogUmV0dXJucyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBSR0JBIGNvbXBvbmVudHMgb2YgdGhpcyBDb2xvdXIuIFRoZSByZWQsCiAgICogZ3JlZW4sIGFuZCBibHVlIGNvbXBvbmVudHMgYXJlIGNvbnZlcnRlZCB0byBudW1iZXJzIGluIHRoZSByYW5nZSBbMCwxMDBdLgogICAqIFRoZSBhbHBoYSBpcyBhIHZhbHVlIGluIHRoZSByYW5nZSBbMCwxXS4KICAgKi8KICB0aGlzLmdldFBlcmNlbnRhZ2VSR0IgPSBmdW5jdGlvbigpewoKICAgIC8vIGdldCB0aGUgUkdCIGNvbXBvbmVudHMgb2YgdGhpcyBjb2xvdXIKICAgIHZhciByZ2IgPSB0aGlzLmdldFJHQigpOwoKICAgIC8vIHJldHVybiB0aGUgcGVyY2VudGFnZSBjb21wb25lbnRzCiAgICByZXR1cm4gewogICAgICAncicgOiAxMDAgKiByZ2IuciAvIDI1NSwKICAgICAgJ2cnIDogMTAwICogcmdiLmcgLyAyNTUsCiAgICAgICdiJyA6IDEwMCAqIHJnYi5iIC8gMjU1LAogICAgICAnYScgOiByZ2IuYQogICAgfTsKCiAgfTsKCiAgLyogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBDb2xvdXIgYXMgYSBDU1MgaGV4YWRlY2ltYWwgUkdCIGNvbG91cgogICAqIHZhbHVlIC0gdGhhdCBpcywgYSBzdHJpbmcgb2YgdGhlIGZvcm0gI1JSR0dCQiB3aGVyZSBlYWNoIG9mIFJSLCBHRywgYW5kIEJCCiAgICogYXJlIHR3by1kaWdpdCBoZXhhZGVjaW1hbCBudW1iZXJzLgogICAqLwogIHRoaXMuZ2V0Q1NTSGV4YWRlY2ltYWxSR0IgPSBmdW5jdGlvbigpewoKICAgIC8vIGdldCB0aGUgaW50ZWdlciBSR0IgY29tcG9uZW50cwogICAgdmFyIHJnYiA9IHRoaXMuZ2V0SW50ZWdlclJHQigpOwoKICAgIC8vIGRldGVybWluZSB0aGUgaGV4YWRlY2ltYWwgZXF1aXZhbGVudHMKICAgIHZhciByMTYgPSByZ2Iuci50b1N0cmluZygxNik7CiAgICB2YXIgZzE2ID0gcmdiLmcudG9TdHJpbmcoMTYpOwogICAgdmFyIGIxNiA9IHJnYi5iLnRvU3RyaW5nKDE2KTsKCiAgICAvLyByZXR1cm4gdGhlIENTUyBSR0IgY29sb3VyIHZhbHVlCiAgICByZXR1cm4gJyMnCiAgICAgICAgKyAocjE2Lmxlbmd0aCA9PSAyID8gcjE2IDogJzAnICsgcjE2KQogICAgICAgICsgKGcxNi5sZW5ndGggPT0gMiA/IGcxNiA6ICcwJyArIGcxNikKICAgICAgICArIChiMTYubGVuZ3RoID09IDIgPyBiMTYgOiAnMCcgKyBiMTYpOwoKICB9OwoKICAvKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIENvbG91ciBhcyBhIENTUyBpbnRlZ2VyIFJHQiBjb2xvdXIKICAgKiB2YWx1ZSAtIHRoYXQgaXMsIGEgc3RyaW5nIG9mIHRoZSBmb3JtIHJnYihyLGcsYikgd2hlcmUgZWFjaCBvZiByLCBnLCBhbmQgYgogICAqIGFyZSBpbnRlZ2VycyBpbiB0aGUgcmFuZ2UgWzAsMjU1XS4KICAgKi8KICB0aGlzLmdldENTU0ludGVnZXJSR0IgPSBmdW5jdGlvbigpewoKICAgIC8vIGdldCB0aGUgaW50ZWdlciBSR0IgY29tcG9uZW50cwogICAgdmFyIHJnYiA9IHRoaXMuZ2V0SW50ZWdlclJHQigpOwoKICAgIC8vIHJldHVybiB0aGUgQ1NTIFJHQiBjb2xvdXIgdmFsdWUKICAgIHJldHVybiAncmdiKCcgKyByZ2IuciArICcsJyArIHJnYi5nICsgJywnICsgcmdiLmIgKyAnKSc7CgogIH07CgogIC8qIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgQ29sb3VyIGFzIGEgQ1NTIGludGVnZXIgUkdCQSBjb2xvdXIKICAgKiB2YWx1ZSAtIHRoYXQgaXMsIGEgc3RyaW5nIG9mIHRoZSBmb3JtIHJnYmEocixnLGIsYSkgd2hlcmUgZWFjaCBvZiByLCBnLCBhbmQKICAgKiBiIGFyZSBpbnRlZ2VycyBpbiB0aGUgcmFuZ2UgWzAsMjU1XSBhbmQgYSBpcyBpbiB0aGUgcmFuZ2UgWzAsMV0uCiAgICovCiAgdGhpcy5nZXRDU1NJbnRlZ2VyUkdCQSA9IGZ1bmN0aW9uKCl7CgogICAgLy8gZ2V0IHRoZSBpbnRlZ2VyIFJHQiBjb21wb25lbnRzCiAgICB2YXIgcmdiID0gdGhpcy5nZXRJbnRlZ2VyUkdCKCk7CgogICAgLy8gcmV0dXJuIHRoZSBDU1MgaW50ZWdlciBSR0JBIGNvbG91ciB2YWx1ZQogICAgcmV0dXJuICdyZ2IoJyArIHJnYi5yICsgJywnICsgcmdiLmcgKyAnLCcgKyByZ2IuYiArICcsJyArIHJnYi5hICsgJyknOwoKICB9OwoKICAvKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIENvbG91ciBhcyBhIENTUyBwZXJjZW50YWdlIFJHQiBjb2xvdXIKICAgKiB2YWx1ZSAtIHRoYXQgaXMsIGEgc3RyaW5nIG9mIHRoZSBmb3JtIHJnYihyJSxnJSxiJSkgd2hlcmUgZWFjaCBvZiByLCBnLCBhbmQKICAgKiBiIGFyZSBpbiB0aGUgcmFuZ2UgWzAsMTAwXS4KICAgKi8KICB0aGlzLmdldENTU1BlcmNlbnRhZ2VSR0IgPSBmdW5jdGlvbigpewoKICAgIC8vIGdldCB0aGUgcGVyY2VudGFnZSBSR0IgY29tcG9uZW50cwogICAgdmFyIHJnYiA9IHRoaXMuZ2V0UGVyY2VudGFnZVJHQigpOwoKICAgIC8vIHJldHVybiB0aGUgQ1NTIFJHQiBjb2xvdXIgdmFsdWUKICAgIHJldHVybiAncmdiKCcgKyByZ2IuciArICclLCcgKyByZ2IuZyArICclLCcgKyByZ2IuYiArICclKSc7CgogIH07CgogIC8qIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoaXMgQ29sb3VyIGFzIGEgQ1NTIHBlcmNlbnRhZ2UgUkdCQSBjb2xvdXIKICAgKiB2YWx1ZSAtIHRoYXQgaXMsIGEgc3RyaW5nIG9mIHRoZSBmb3JtIHJnYmEociUsZyUsYiUsYSkgd2hlcmUgZWFjaCBvZiByLCBnLAogICAqIGFuZCBiIGFyZSBpbiB0aGUgcmFuZ2UgWzAsMTAwXSBhbmQgYSBpcyBpbiB0aGUgcmFuZ2UgWzAsMV0uCiAgICovCiAgdGhpcy5nZXRDU1NQZXJjZW50YWdlUkdCQSA9IGZ1bmN0aW9uKCl7CgogICAgLy8gZ2V0IHRoZSBwZXJjZW50YWdlIFJHQiBjb21wb25lbnRzCiAgICB2YXIgcmdiID0gdGhpcy5nZXRQZXJjZW50YWdlUkdCKCk7CgogICAgLy8gcmV0dXJuIHRoZSBDU1MgcGVyY2VudGFnZSBSR0JBIGNvbG91ciB2YWx1ZQogICAgcmV0dXJuICdyZ2IoJyArIHJnYi5yICsgJyUsJyArIHJnYi5nICsgJyUsJyArIHJnYi5iICsgJyUsJyArIHJnYi5hICsgJyknOwoKICB9OwoKICAvKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIENvbG91ciBhcyBhIENTUyBIU0wgY29sb3VyIHZhbHVlIC0gdGhhdAogICAqIGlzLCBhIHN0cmluZyBvZiB0aGUgZm9ybSBoc2woaCxzJSxsJSkgd2hlcmUgaCBpcyBpbiB0aGUgcmFuZ2UgWzAsMzYwKSBhbmQKICAgKiBzIGFuZCBsIGFyZSBpbiB0aGUgcmFuZ2UgWzAsMTAwXS4KICAgKi8KICB0aGlzLmdldENTU0hTTCA9IGZ1bmN0aW9uKCl7CgogICAgLy8gZ2V0IHRoZSBIU0wgY29tcG9uZW50cwogICAgdmFyIGhzbCA9IHRoaXMuZ2V0SFNMKCk7CgogICAgLy8gcmV0dXJuIHRoZSBDU1MgSFNMIGNvbG91ciB2YWx1ZQogICAgcmV0dXJuICdoc2woJyArIGhzbC5oICsgJywnICsgaHNsLnMgKyAnJSwnICsgaHNsLmwgKyAnJSknOwoKICB9OwoKICAvKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIENvbG91ciBhcyBhIENTUyBIU0xBIGNvbG91ciB2YWx1ZSAtIHRoYXQKICAgKiBpcywgYSBzdHJpbmcgb2YgdGhlIGZvcm0gaHNsYShoLHMlLGwlLGEpIHdoZXJlIGggaXMgaW4gdGhlIHJhbmdlIFswLDM2MCksCiAgICogcyBhbmQgbCBhcmUgaW4gdGhlIHJhbmdlIFswLDEwMF0sIGFuZCBhIGlzIGluIHRoZSByYW5nZSBbMCwxXS4KICAgKi8KICB0aGlzLmdldENTU0hTTEEgPSBmdW5jdGlvbigpewoKICAgIC8vIGdldCB0aGUgSFNMIGNvbXBvbmVudHMKICAgIHZhciBoc2wgPSB0aGlzLmdldEhTTCgpOwoKICAgIC8vIHJldHVybiB0aGUgQ1NTIEhTTCBjb2xvdXIgdmFsdWUKICAgIHJldHVybiAnaHNsKCcgKyBoc2wuaCArICcsJyArIGhzbC5zICsgJyUsJyArIGhzbC5sICsgJyUsJyArIGhzbC5hICsgJyknOwoKICB9OwoKICAvKiBTZXRzIHRoZSBjb2xvdXIgb2YgdGhlIHNwZWNpZmllZCBub2RlIHRvIHRoaXMgQ29sb3VyLiBUaGlzIGZ1bmN0aW9uIHNldHMKICAgKiB0aGUgQ1NTICdjb2xvcicgcHJvcGVydHkgZm9yIHRoZSBub2RlLiBUaGUgcGFyYW1ldGVyIGlzOgogICAqCiAgICogbm9kZSAtIHRoZSBub2RlIHdob3NlIGNvbG91ciBzaG91bGQgYmUgc2V0CiAgICovCiAgdGhpcy5zZXROb2RlQ29sb3VyID0gZnVuY3Rpb24obm9kZSl7CgogICAgLy8gc2V0IHRoZSBjb2xvdXIgb2YgdGhlIG5vZGUKICAgIG5vZGUuc3R5bGUuY29sb3IgPSB0aGlzLmdldENTU0hleGFkZWNpbWFsUkdCKCk7CgogIH07CgogIC8qIFNldHMgdGhlIGJhY2tncm91bmQgY29sb3VyIG9mIHRoZSBzcGVjaWZpZWQgbm9kZSB0byB0aGlzIENvbG91ci4gVGhpcwogICAqIGZ1bmN0aW9uIHNldHMgdGhlIENTUyAnYmFja2dyb3VuZC1jb2xvcicgcHJvcGVydHkgZm9yIHRoZSBub2RlLiBUaGUKICAgKiBwYXJhbWV0ZXIgaXM6CiAgICoKICAgKiBub2RlIC0gdGhlIG5vZGUgd2hvc2UgYmFja2dyb3VuZCBjb2xvdXIgc2hvdWxkIGJlIHNldAogICAqLwogIHRoaXMuc2V0Tm9kZUJhY2tncm91bmRDb2xvdXIgPSBmdW5jdGlvbihub2RlKXsKCiAgICAvLyBzZXQgdGhlIGJhY2tncm91bmQgY29sb3VyIG9mIHRoZSBub2RlCiAgICBub2RlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZ2V0Q1NTSGV4YWRlY2ltYWxSR0IoKTsKCiAgfTsKCn0KCi8qIENyZWF0ZXMgYSBjb2xvdXIgc3BlY2lmaWVkIGluIHRoZSBSR0IgY29sb3VyIHNwYWNlLCB3aXRoIGFuIG9wdGlvbmFsIGFscGhhCiAqIGNvbXBvbmVudC4gVGhlIHBhcmFtZXRlcnMgYXJlOgogKgogKiByIC0gdGhlIHJlZCBjb21wb25lbnQsIGNsaXBwZWQgdG8gdGhlIHJhbmdlIFswLDI1NV0KICogZyAtIHRoZSBncmVlbiBjb21wb25lbnQsIGNsaXBwZWQgdG8gdGhlIHJhbmdlIFswLDI1NV0KICogYiAtIHRoZSBibHVlIGNvbXBvbmVudCwgY2xpcHBlZCB0byB0aGUgcmFuZ2UgWzAsMjU1XQogKiBhIC0gdGhlIGFscGhhIGNvbXBvbmVudCwgY2xpcHBlZCB0byB0aGUgcmFuZ2UgWzAsMV0gLSB0aGlzIHBhcmFtZXRlciBpcwogKiAgICAgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIDEKICovClJHQkNvbG91ci5wcm90b3R5cGUgPSBuZXcgQ29sb3VyKCk7CmZ1bmN0aW9uIFJHQkNvbG91cihyLCBnLCBiLCBhKXsKCiAgLy8gc3RvcmUgdGhlIGFscGhhIGNvbXBvbmVudCBhZnRlciBjbGlwcGluZyBpdCBpZiBuZWNlc3NhcnkKICB2YXIgYWxwaGEgPSAoYSA9PT0gdW5kZWZpbmVkID8gMSA6IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGEpKSk7CgogIC8vIHN0b3JlIHRoZSBSR0IgY29tcG9uZW50cyBhZnRlciBjbGlwcGluZyB0aGVtIGlmIG5lY2Vzc2FyeQogIHZhciByZ2IgPQogICAgICB7CiAgICAgICAgJ3InIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByKSksCiAgICAgICAgJ2cnIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBnKSksCiAgICAgICAgJ2InIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBiKSkKICAgICAgfTsKCiAgLy8gaW5pdGlhbGlzZSB0aGUgSFNWIGFuZCBIU0wgY29tcG9uZW50cyB0byBudWxsCiAgdmFyIGhzdiA9IG51bGw7CiAgdmFyIGhzbCA9IG51bGw7CgogIC8qIFJldHVybnMgdGhlIEhTViBvciBIU0wgaHVlIGNvbXBvbmVudCBvZiB0aGlzIFJHQkNvbG91ci4gVGhlIGh1ZSBpcyBpbiB0aGUKICAgKiByYW5nZSBbMCwzNjApLiBUaGUgcGFyYW1ldGVycyBhcmU6CiAgICoKICAgKiBtYXhpbXVtIC0gdGhlIG1heGltdW0gb2YgdGhlIFJHQiBjb21wb25lbnQgdmFsdWVzCiAgICogcmFuZ2UgICAtIHRoZSByYW5nZSBvZiB0aGUgUkdCIGNvbXBvbmVudCB2YWx1ZXMKICAgKi8KICBmdW5jdGlvbiBnZXRIdWUobWF4aW11bSwgcmFuZ2UpewoKICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIHJhbmdlIGlzIHplcm8KICAgIGlmIChyYW5nZSA9PSAwKXsKCiAgICAgIC8vIHNldCB0aGUgaHVlIHRvIHplcm8gKGFueSBodWUgaXMgYWNjZXB0YWJsZSBhcyB0aGUgY29sb3VyIGlzIGdyZXkpCiAgICAgIHZhciBodWUgPSAwOwoKICAgIH1lbHNlewoKICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG9mIHRoZSBjb21wb25lbnRzIGhhcyB0aGUgaGlnaGVzdCB2YWx1ZSBhbmQgc2V0IHRoZSBodWUKICAgICAgc3dpdGNoIChtYXhpbXVtKXsKCiAgICAgICAgLy8gcmVkIGhhcyB0aGUgaGlnaGVzdCB2YWx1ZQogICAgICAgIGNhc2UgcmdiLnI6CiAgICAgICAgICB2YXIgaHVlID0gKHJnYi5nIC0gcmdiLmIpIC8gcmFuZ2UgKiA2MDsKICAgICAgICAgIGlmIChodWUgPCAwKSBodWUgKz0gMzYwOwogICAgICAgICAgYnJlYWs7CgogICAgICAgIC8vIGdyZWVuIGhhcyB0aGUgaGlnaGVzdCB2YWx1ZQogICAgICAgIGNhc2UgcmdiLmc6CiAgICAgICAgICB2YXIgaHVlID0gKHJnYi5iIC0gcmdiLnIpIC8gcmFuZ2UgKiA2MCArIDEyMDsKICAgICAgICAgIGJyZWFrOwoKICAgICAgICAvLyBibHVlIGhhcyB0aGUgaGlnaGVzdCB2YWx1ZQogICAgICAgIGNhc2UgcmdiLmI6CiAgICAgICAgICB2YXIgaHVlID0gKHJnYi5yIC0gcmdiLmcpIC8gcmFuZ2UgKiA2MCArIDI0MDsKICAgICAgICAgIGJyZWFrOwoKICAgICAgfQoKICAgIH0KCiAgICAvLyByZXR1cm4gdGhlIGh1ZQogICAgcmV0dXJuIGh1ZTsKCiAgfQoKICAvKiBDYWxjdWxhdGVzIGFuZCBzdG9yZXMgdGhlIEhTViBjb21wb25lbnRzIG9mIHRoaXMgUkdCQ29sb3VyIHNvIHRoYXQgdGhleSBjYW4KICAgKiBiZSByZXR1cm5lZCBiZSB0aGUgZ2V0SFNWIGZ1bmN0aW9uLgogICAqLwogIGZ1bmN0aW9uIGNhbGN1bGF0ZUhTVigpewoKICAgIC8vIGdldCB0aGUgbWF4aW11bSBhbmQgcmFuZ2Ugb2YgdGhlIFJHQiBjb21wb25lbnQgdmFsdWVzCiAgICB2YXIgbWF4aW11bSA9IE1hdGgubWF4KHJnYi5yLCByZ2IuZywgcmdiLmIpOwogICAgdmFyIHJhbmdlICAgPSBtYXhpbXVtIC0gTWF0aC5taW4ocmdiLnIsIHJnYi5nLCByZ2IuYik7CgogICAgLy8gc3RvcmUgdGhlIEhTViBjb21wb25lbnRzCiAgICBoc3YgPQogICAgICAgIHsKICAgICAgICAgICdoJyA6IGdldEh1ZShtYXhpbXVtLCByYW5nZSksCiAgICAgICAgICAncycgOiAobWF4aW11bSA9PSAwID8gMCA6IDEwMCAqIHJhbmdlIC8gbWF4aW11bSksCiAgICAgICAgICAndicgOiBtYXhpbXVtIC8gMi41NQogICAgICAgIH07CgogIH0KCiAgLyogQ2FsY3VsYXRlcyBhbmQgc3RvcmVzIHRoZSBIU0wgY29tcG9uZW50cyBvZiB0aGlzIFJHQkNvbG91ciBzbyB0aGF0IHRoZXkgY2FuCiAgICogYmUgcmV0dXJuZWQgYmUgdGhlIGdldEhTTCBmdW5jdGlvbi4KICAgKi8KICBmdW5jdGlvbiBjYWxjdWxhdGVIU0woKXsKCiAgICAvLyBnZXQgdGhlIG1heGltdW0gYW5kIHJhbmdlIG9mIHRoZSBSR0IgY29tcG9uZW50IHZhbHVlcwogICAgdmFyIG1heGltdW0gPSBNYXRoLm1heChyZ2IuciwgcmdiLmcsIHJnYi5iKTsKICAgIHZhciByYW5nZSAgID0gbWF4aW11bSAtIE1hdGgubWluKHJnYi5yLCByZ2IuZywgcmdiLmIpOwoKICAgIC8vIGRldGVybWluZSB0aGUgbGlnaHRuZXNzIGluIHRoZSByYW5nZSBbMCwxXQogICAgdmFyIGwgPSBtYXhpbXVtIC8gMjU1IC0gcmFuZ2UgLyA1MTA7CgogICAgLy8gc3RvcmUgdGhlIEhTTCBjb21wb25lbnRzCiAgICBoc2wgPQogICAgICAgIHsKICAgICAgICAgICdoJyA6IGdldEh1ZShtYXhpbXVtLCByYW5nZSksCiAgICAgICAgICAncycgOiAocmFuZ2UgPT0gMCA/IDAgOiByYW5nZSAvIDIuNTUgLyAobCA8IDAuNSA/IGwgKiAyIDogMiAtIGwgKiAyKSksCiAgICAgICAgICAnbCcgOiAxMDAgKiBsCiAgICAgICAgfTsKCiAgfQoKICAvKiBSZXR1cm5zIHRoZSBSR0IgYW5kIGFscGhhIGNvbXBvbmVudHMgb2YgdGhpcyBSR0JDb2xvdXIgYXMgYW4gb2JqZWN0IHdpdGggciwKICAgKiBnLCBiLCBhbmQgYSBwcm9wZXJ0aWVzLiByLCBnLCBhbmQgYiBhcmUgaW4gdGhlIHJhbmdlIFswLDI1NV0gYW5kIGEgaXMgaW4KICAgKiB0aGUgcmFuZ2UgWzAsMV0uCiAgICovCiAgdGhpcy5nZXRSR0IgPSBmdW5jdGlvbigpewoKICAgIC8vIHJldHVybiB0aGUgUkdCIGNvbXBvbmVudHMKICAgIHJldHVybiB7CiAgICAgICdyJyA6IHJnYi5yLAogICAgICAnZycgOiByZ2IuZywKICAgICAgJ2InIDogcmdiLmIsCiAgICAgICdhJyA6IGFscGhhCiAgICB9OwoKICB9OwoKICAvKiBSZXR1cm5zIHRoZSBIU1YgYW5kIGFscGhhIGNvbXBvbmVudHMgb2YgdGhpcyBSR0JDb2xvdXIgYXMgYW4gb2JqZWN0IHdpdGggaCwKICAgKiBzLCB2LCBhbmQgYSBwcm9wZXJ0aWVzLiBoIGlzIGluIHRoZSByYW5nZSBbMCwzNjApLCBzIGFuZCB2IGFyZSBpbiB0aGUgcmFuZ2UKICAgKiBbMCwxMDBdLCBhbmQgYSBpcyBpbiB0aGUgcmFuZ2UgWzAsMV0uCiAgICovCiAgdGhpcy5nZXRIU1YgPSBmdW5jdGlvbigpewoKICAgIC8vIGNhbGN1bGF0ZSB0aGUgSFNWIGNvbXBvbmVudHMgaWYgbmVjZXNzYXJ5CiAgICBpZiAoaHN2ID09IG51bGwpIGNhbGN1bGF0ZUhTVigpOwoKICAgIC8vIHJldHVybiB0aGUgSFNWIGNvbXBvbmVudHMKICAgIHJldHVybiB7CiAgICAgICdoJyA6IGhzdi5oLAogICAgICAncycgOiBoc3YucywKICAgICAgJ3YnIDogaHN2LnYsCiAgICAgICdhJyA6IGFscGhhCiAgICB9OwoKICB9OwoKICAvKiBSZXR1cm5zIHRoZSBIU0wgYW5kIGFscGhhIGNvbXBvbmVudHMgb2YgdGhpcyBSR0JDb2xvdXIgYXMgYW4gb2JqZWN0IHdpdGggaCwKICAgKiBzLCBsLCBhbmQgYSBwcm9wZXJ0aWVzLiBoIGlzIGluIHRoZSByYW5nZSBbMCwzNjApLCBzIGFuZCBsIGFyZSBpbiB0aGUgcmFuZ2UKICAgKiBbMCwxMDBdLCBhbmQgYSBpcyBpbiB0aGUgcmFuZ2UgWzAsMV0uCiAgICovCiAgdGhpcy5nZXRIU0wgPSBmdW5jdGlvbigpewoKICAgIC8vIGNhbGN1bGF0ZSB0aGUgSFNWIGNvbXBvbmVudHMgaWYgbmVjZXNzYXJ5CiAgICBpZiAoaHNsID09IG51bGwpIGNhbGN1bGF0ZUhTTCgpOwoKICAgIC8vIHJldHVybiB0aGUgSFNMIGNvbXBvbmVudHMKICAgIHJldHVybiB7CiAgICAgICdoJyA6IGhzbC5oLAogICAgICAncycgOiBoc2wucywKICAgICAgJ2wnIDogaHNsLmwsCiAgICAgICdhJyA6IGFscGhhCiAgICB9OwoKICB9OwoKfQoKLyogQ3JlYXRlcyBhIGNvbG91ciBzcGVjaWZpZWQgaW4gdGhlIEhTViBjb2xvdXIgc3BhY2UsIHdpdGggYW4gb3B0aW9uYWwgYWxwaGEKICogY29tcG9uZW50LiBUaGUgcGFyYW1ldGVycyBhcmU6CiAqCiAqIGggLSB0aGUgaHVlIGNvbXBvbmVudCwgd3JhcHBlZCB0byB0aGUgcmFuZ2UgWzAsMzYwKQogKiBzIC0gdGhlIHNhdHVyYXRpb24gY29tcG9uZW50LCBjbGlwcGVkIHRvIHRoZSByYW5nZSBbMCwxMDBdCiAqIHYgLSB0aGUgdmFsdWUgY29tcG9uZW50LCBjbGlwcGVkIHRvIHRoZSByYW5nZSBbMCwxMDBdCiAqIGEgLSB0aGUgYWxwaGEgY29tcG9uZW50LCBjbGlwcGVkIHRvIHRoZSByYW5nZSBbMCwxXSAtIHRoaXMgcGFyYW1ldGVyIGlzCiAqICAgICBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gMQogKi8KSFNWQ29sb3VyLnByb3RvdHlwZSA9IG5ldyBDb2xvdXIoKTsKZnVuY3Rpb24gSFNWQ29sb3VyKGgsIHMsIHYsIGEpewoKICAvLyBzdG9yZSB0aGUgYWxwaGEgY29tcG9uZW50IGFmdGVyIGNsaXBwaW5nIGl0IGlmIG5lY2Vzc2FyeQogIHZhciBhbHBoYSA9IChhID09PSB1bmRlZmluZWQgPyAxIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYSkpKTsKCiAgLy8gc3RvcmUgdGhlIEhTViBjb21wb25lbnRzIGFmdGVyIGNsaXBwaW5nIG9yIHdyYXBwaW5nIHRoZW0gaWYgbmVjZXNzYXJ5CiAgdmFyIGhzdiA9CiAgICAgIHsKICAgICAgICAnaCcgOiAoaCAlIDM2MCArIDM2MCkgJSAzNjAsCiAgICAgICAgJ3MnIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCBzKSksCiAgICAgICAgJ3YnIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCB2KSkKICAgICAgfTsKCiAgLy8gaW5pdGlhbGlzZSB0aGUgUkdCIGFuZCBIU0wgY29tcG9uZW50cyB0byBudWxsCiAgdmFyIHJnYiA9IG51bGw7CiAgdmFyIGhzbCA9IG51bGw7CgogIC8qIENhbGN1bGF0ZXMgYW5kIHN0b3JlcyB0aGUgUkdCIGNvbXBvbmVudHMgb2YgdGhpcyBIU1ZDb2xvdXIgc28gdGhhdCB0aGV5IGNhbgogICAqIGJlIHJldHVybmVkIGJlIHRoZSBnZXRSR0IgZnVuY3Rpb24uCiAgICovCiAgZnVuY3Rpb24gY2FsY3VsYXRlUkdCKCl7CgogICAgLy8gY2hlY2sgd2hldGhlciB0aGUgc2F0dXJhdGlvbiBpcyB6ZXJvCiAgICBpZiAoaHN2LnMgPT0gMCl7CgogICAgICAvLyBzZXQgdGhlIGNvbG91ciB0byB0aGUgYXBwcm9wcmlhdGUgc2hhZGUgb2YgZ3JleQogICAgICB2YXIgciA9IGhzdi52OwogICAgICB2YXIgZyA9IGhzdi52OwogICAgICB2YXIgYiA9IGhzdi52OwoKICAgIH1lbHNlewoKICAgICAgLy8gc2V0IHNvbWUgdGVtcG9yYXJ5IHZhbHVlcwogICAgICB2YXIgZiAgPSBoc3YuaCAvIDYwIC0gTWF0aC5mbG9vcihoc3YuaCAvIDYwKTsKICAgICAgdmFyIHAgID0gaHN2LnYgKiAoMSAtIGhzdi5zIC8gMTAwKTsKICAgICAgdmFyIHEgID0gaHN2LnYgKiAoMSAtIGhzdi5zIC8gMTAwICogZik7CiAgICAgIHZhciB0ICA9IGhzdi52ICogKDEgLSBoc3YucyAvIDEwMCAqICgxIC0gZikpOwoKICAgICAgLy8gc2V0IHRoZSBSR0IgY29sb3VyIGNvbXBvbmVudHMgdG8gdGhlaXIgdGVtcG9yYXJ5IHZhbHVlcwogICAgICBzd2l0Y2ggKE1hdGguZmxvb3IoaHN2LmggLyA2MCkpewogICAgICAgIGNhc2UgMDogdmFyIHIgPSBoc3YudjsgdmFyIGcgPSB0OyB2YXIgYiA9IHA7IGJyZWFrOwogICAgICAgIGNhc2UgMTogdmFyIHIgPSBxOyB2YXIgZyA9IGhzdi52OyB2YXIgYiA9IHA7IGJyZWFrOwogICAgICAgIGNhc2UgMjogdmFyIHIgPSBwOyB2YXIgZyA9IGhzdi52OyB2YXIgYiA9IHQ7IGJyZWFrOwogICAgICAgIGNhc2UgMzogdmFyIHIgPSBwOyB2YXIgZyA9IHE7IHZhciBiID0gaHN2LnY7IGJyZWFrOwogICAgICAgIGNhc2UgNDogdmFyIHIgPSB0OyB2YXIgZyA9IHA7IHZhciBiID0gaHN2LnY7IGJyZWFrOwogICAgICAgIGNhc2UgNTogdmFyIHIgPSBoc3YudjsgdmFyIGcgPSBwOyB2YXIgYiA9IHE7IGJyZWFrOwogICAgICB9CgogICAgfQoKICAgIC8vIHN0b3JlIHRoZSBSR0IgY29tcG9uZW50cwogICAgcmdiID0KICAgICAgICB7CiAgICAgICAgICAncicgOiByICogMi41NSwKICAgICAgICAgICdnJyA6IGcgKiAyLjU1LAogICAgICAgICAgJ2InIDogYiAqIDIuNTUKICAgICAgICB9OwoKICB9CgogIC8qIENhbGN1bGF0ZXMgYW5kIHN0b3JlcyB0aGUgSFNMIGNvbXBvbmVudHMgb2YgdGhpcyBIU1ZDb2xvdXIgc28gdGhhdCB0aGV5IGNhbgogICAqIGJlIHJldHVybmVkIGJlIHRoZSBnZXRIU0wgZnVuY3Rpb24uCiAgICovCiAgZnVuY3Rpb24gY2FsY3VsYXRlSFNMKCl7CgogICAgLy8gZGV0ZXJtaW5lIHRoZSBsaWdodG5lc3MgaW4gdGhlIHJhbmdlIFswLDEwMF0KICAgIHZhciBsID0gKDIgLSBoc3YucyAvIDEwMCkgKiBoc3YudiAvIDI7CgogICAgLy8gc3RvcmUgdGhlIEhTTCBjb21wb25lbnRzCiAgICBoc2wgPQogICAgICAgIHsKICAgICAgICAgICdoJyA6IGhzdi5oLAogICAgICAgICAgJ3MnIDogaHN2LnMgKiBoc3YudiAvIChsIDwgNTAgPyBsICogMiA6IDIwMCAtIGwgKiAyKSwKICAgICAgICAgICdsJyA6IGwKICAgICAgICB9OwoKICAgIC8vIGNvcnJlY3QgYSBkaXZpc2lvbi1ieS16ZXJvIGVycm9yCiAgICBpZiAoaXNOYU4oaHNsLnMpKSBoc2wucyA9IDA7CgogIH0KCiAgLyogUmV0dXJucyB0aGUgUkdCIGFuZCBhbHBoYSBjb21wb25lbnRzIG9mIHRoaXMgSFNWQ29sb3VyIGFzIGFuIG9iamVjdCB3aXRoIHIsCiAgICogZywgYiwgYW5kIGEgcHJvcGVydGllcy4gciwgZywgYW5kIGIgYXJlIGluIHRoZSByYW5nZSBbMCwyNTVdIGFuZCBhIGlzIGluCiAgICogdGhlIHJhbmdlIFswLDFdLgogICAqLwogIHRoaXMuZ2V0UkdCID0gZnVuY3Rpb24oKXsKCiAgICAvLyBjYWxjdWxhdGUgdGhlIFJHQiBjb21wb25lbnRzIGlmIG5lY2Vzc2FyeQogICAgaWYgKHJnYiA9PSBudWxsKSBjYWxjdWxhdGVSR0IoKTsKCiAgICAvLyByZXR1cm4gdGhlIFJHQiBjb21wb25lbnRzCiAgICByZXR1cm4gewogICAgICAncicgOiByZ2IuciwKICAgICAgJ2cnIDogcmdiLmcsCiAgICAgICdiJyA6IHJnYi5iLAogICAgICAnYScgOiBhbHBoYQogICAgfTsKCiAgfTsKCiAgLyogUmV0dXJucyB0aGUgSFNWIGFuZCBhbHBoYSBjb21wb25lbnRzIG9mIHRoaXMgSFNWQ29sb3VyIGFzIGFuIG9iamVjdCB3aXRoIGgsCiAgICogcywgdiwgYW5kIGEgcHJvcGVydGllcy4gaCBpcyBpbiB0aGUgcmFuZ2UgWzAsMzYwKSwgcyBhbmQgdiBhcmUgaW4gdGhlIHJhbmdlCiAgICogWzAsMTAwXSwgYW5kIGEgaXMgaW4gdGhlIHJhbmdlIFswLDFdLgogICAqLwogIHRoaXMuZ2V0SFNWID0gZnVuY3Rpb24oKXsKCiAgICAvLyByZXR1cm4gdGhlIEhTViBjb21wb25lbnRzCiAgICByZXR1cm4gewogICAgICAnaCcgOiBoc3YuaCwKICAgICAgJ3MnIDogaHN2LnMsCiAgICAgICd2JyA6IGhzdi52LAogICAgICAnYScgOiBhbHBoYQogICAgfTsKCiAgfTsKCiAgLyogUmV0dXJucyB0aGUgSFNMIGFuZCBhbHBoYSBjb21wb25lbnRzIG9mIHRoaXMgSFNWQ29sb3VyIGFzIGFuIG9iamVjdCB3aXRoIGgsCiAgICogcywgbCwgYW5kIGEgcHJvcGVydGllcy4gaCBpcyBpbiB0aGUgcmFuZ2UgWzAsMzYwKSwgcyBhbmQgbCBhcmUgaW4gdGhlIHJhbmdlCiAgICogWzAsMTAwXSwgYW5kIGEgaXMgaW4gdGhlIHJhbmdlIFswLDFdLgogICAqLwogIHRoaXMuZ2V0SFNMID0gZnVuY3Rpb24oKXsKCiAgICAvLyBjYWxjdWxhdGUgdGhlIEhTTCBjb21wb25lbnRzIGlmIG5lY2Vzc2FyeQogICAgaWYgKGhzbCA9PSBudWxsKSBjYWxjdWxhdGVIU0woKTsKCiAgICAvLyByZXR1cm4gdGhlIEhTTCBjb21wb25lbnRzCiAgICByZXR1cm4gewogICAgICAnaCcgOiBoc2wuaCwKICAgICAgJ3MnIDogaHNsLnMsCiAgICAgICdsJyA6IGhzbC5sLAogICAgICAnYScgOiBhbHBoYQogICAgfTsKCiAgfTsKCn0KCi8qIENyZWF0ZXMgYSBjb2xvdXIgc3BlY2lmaWVkIGluIHRoZSBIU0wgY29sb3VyIHNwYWNlLCB3aXRoIGFuIG9wdGlvbmFsIGFscGhhCiAqIGNvbXBvbmVudC4gVGhlIHBhcmFtZXRlcnMgYXJlOgogKgogKiBoIC0gdGhlIGh1ZSBjb21wb25lbnQsIHdyYXBwZWQgdG8gdGhlIHJhbmdlIFswLDM2MCkKICogcyAtIHRoZSBzYXR1cmF0aW9uIGNvbXBvbmVudCwgY2xpcHBlZCB0byB0aGUgcmFuZ2UgWzAsMTAwXQogKiBsIC0gdGhlIGxpZ2h0bmVzcyBjb21wb25lbnQsIGNsaXBwZWQgdG8gdGhlIHJhbmdlIFswLDEwMF0KICogYSAtIHRoZSBhbHBoYSBjb21wb25lbnQsIGNsaXBwZWQgdG8gdGhlIHJhbmdlIFswLDFdIC0gdGhpcyBwYXJhbWV0ZXIgaXMKICogICAgIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAxCiAqLwpIU0xDb2xvdXIucHJvdG90eXBlID0gbmV3IENvbG91cigpOwpmdW5jdGlvbiBIU0xDb2xvdXIoaCwgcywgbCwgYSl7CgogIC8vIHN0b3JlIHRoZSBhbHBoYSBjb21wb25lbnQgYWZ0ZXIgY2xpcHBpbmcgaXQgaWYgbmVjZXNzYXJ5CiAgdmFyIGFscGhhID0gKGEgPT09IHVuZGVmaW5lZCA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBhKSkpOwoKICAvLyBzdG9yZSB0aGUgSFNMIGNvbXBvbmVudHMgYWZ0ZXIgY2xpcHBpbmcgb3Igd3JhcHBpbmcgdGhlbSBpZiBuZWNlc3NhcnkKICB2YXIgaHNsID0KICAgICAgewogICAgICAgICdoJyA6IChoICUgMzYwICsgMzYwKSAlIDM2MCwKICAgICAgICAncycgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIHMpKSwKICAgICAgICAnbCcgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIGwpKQogICAgICB9OwoKICAvLyBpbml0aWFsaXNlIHRoZSBSR0IgYW5kIEhTViBjb21wb25lbnRzIHRvIG51bGwKICB2YXIgcmdiID0gbnVsbDsKICB2YXIgaHN2ID0gbnVsbDsKCiAgLyogQ2FsY3VsYXRlcyBhbmQgc3RvcmVzIHRoZSBSR0IgY29tcG9uZW50cyBvZiB0aGlzIEhTTENvbG91ciBzbyB0aGF0IHRoZXkgY2FuCiAgICogYmUgcmV0dXJuZWQgYmUgdGhlIGdldFJHQiBmdW5jdGlvbi4KICAgKi8KICBmdW5jdGlvbiBjYWxjdWxhdGVSR0IoKXsKCiAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBzYXR1cmF0aW9uIGlzIHplcm8KICAgIGlmIChoc2wucyA9PSAwKXsKCiAgICAgIC8vIHN0b3JlIHRoZSBSR0IgY29tcG9uZW50cyByZXByZXNlbnRpbmcgdGhlIGFwcHJvcHJpYXRlIHNoYWRlIG9mIGdyZXkKICAgICAgcmdiID0KICAgICAgICAgIHsKICAgICAgICAgICAgJ3InIDogaHNsLmwgKiAyLjU1LAogICAgICAgICAgICAnZycgOiBoc2wubCAqIDIuNTUsCiAgICAgICAgICAgICdiJyA6IGhzbC5sICogMi41NQogICAgICAgICAgfTsKCiAgICB9ZWxzZXsKCiAgICAgIC8vIHNldCBzb21lIHRlbXBvcmFyeSB2YWx1ZXMKICAgICAgdmFyIHAgPSBoc2wubCA8IDUwCiAgICAgICAgICAgID8gaHNsLmwgKiAoMSArIGhzbC5zIC8gMTAwKQogICAgICAgICAgICA6IGhzbC5sICsgaHNsLnMgLSBoc2wubCAqIGhzbC5zIC8gMTAwOwogICAgICB2YXIgcSA9IDIgKiBoc2wubCAtIHA7CgogICAgICAvLyBpbml0aWFsaXNlIHRoZSBSR0IgY29tcG9uZW50cwogICAgICByZ2IgPQogICAgICAgICAgewogICAgICAgICAgICAncicgOiAoaCArIDEyMCkgLyA2MCAlIDYsCiAgICAgICAgICAgICdnJyA6IGggLyA2MCwKICAgICAgICAgICAgJ2InIDogKGggKyAyNDApIC8gNjAgJSA2CiAgICAgICAgICB9OwoKICAgICAgLy8gbG9vcCBvdmVyIHRoZSBSR0IgY29tcG9uZW50cwogICAgICBmb3IgKHZhciBrZXkgaW4gcmdiKXsKCiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHByb3BlcnR5IGlzIG5vdCBpbmhlcml0ZWQgZnJvbSB0aGUgcm9vdCBvYmplY3QKICAgICAgICBpZiAocmdiLmhhc093blByb3BlcnR5KGtleSkpewoKICAgICAgICAgIC8vIHNldCB0aGUgY29tcG9uZW50IHRvIGl0cyB2YWx1ZSBpbiB0aGUgcmFuZ2UgWzAsMTAwXQogICAgICAgICAgaWYgKHJnYltrZXldIDwgMSl7CiAgICAgICAgICAgIHJnYltrZXldID0gcSArIChwIC0gcSkgKiByZ2Jba2V5XTsKICAgICAgICAgIH1lbHNlIGlmIChyZ2Jba2V5XSA8IDMpewogICAgICAgICAgICByZ2Jba2V5XSA9IHA7CiAgICAgICAgICB9ZWxzZSBpZiAocmdiW2tleV0gPCA0KXsKICAgICAgICAgICAgcmdiW2tleV0gPSBxICsgKHAgLSBxKSAqICg0IC0gcmdiW2tleV0pOwogICAgICAgICAgfWVsc2V7CiAgICAgICAgICAgIHJnYltrZXldID0gcTsKICAgICAgICAgIH0KCiAgICAgICAgICAvLyBzZXQgdGhlIGNvbXBvbmVudCB0byBpdHMgdmFsdWUgaW4gdGhlIHJhbmdlIFswLDI1NV0KICAgICAgICAgIHJnYltrZXldICo9IDIuNTU7CgogICAgICAgIH0KCiAgICAgIH0KCiAgICB9CgogIH0KCiAgLyogQ2FsY3VsYXRlcyBhbmQgc3RvcmVzIHRoZSBIU1YgY29tcG9uZW50cyBvZiB0aGlzIEhTTENvbG91ciBzbyB0aGF0IHRoZXkgY2FuCiAgICogYmUgcmV0dXJuZWQgYmUgdGhlIGdldEhTTCBmdW5jdGlvbi4KICAgKi8KICBmdW5jdGlvbiBjYWxjdWxhdGVIU1YoKXsKCiAgICAvLyBzZXQgYSB0ZW1wb3JhcnkgdmFsdWUKICAgIHZhciB0ID0gaHNsLnMgKiAoaHNsLmwgPCA1MCA/IGhzbC5sIDogMTAwIC0gaHNsLmwpIC8gMTAwOwoKICAgIC8vIHN0b3JlIHRoZSBIU1YgY29tcG9uZW50cwogICAgaHN2ID0KICAgICAgICB7CiAgICAgICAgICAnaCcgOiBoc2wuaCwKICAgICAgICAgICdzJyA6IDIwMCAqIHQgLyAoaHNsLmwgKyB0KSwKICAgICAgICAgICd2JyA6IHQgKyBoc2wubAogICAgICAgIH07CgogICAgLy8gY29ycmVjdCBhIGRpdmlzaW9uLWJ5LXplcm8gZXJyb3IKICAgIGlmIChpc05hTihoc3YucykpIGhzdi5zID0gMDsKCiAgfQoKICAvKiBSZXR1cm5zIHRoZSBSR0IgYW5kIGFscGhhIGNvbXBvbmVudHMgb2YgdGhpcyBIU0xDb2xvdXIgYXMgYW4gb2JqZWN0IHdpdGggciwKICAgKiBnLCBiLCBhbmQgYSBwcm9wZXJ0aWVzLiByLCBnLCBhbmQgYiBhcmUgaW4gdGhlIHJhbmdlIFswLDI1NV0gYW5kIGEgaXMgaW4KICAgKiB0aGUgcmFuZ2UgWzAsMV0uCiAgICovCiAgdGhpcy5nZXRSR0IgPSBmdW5jdGlvbigpewoKICAgIC8vIGNhbGN1bGF0ZSB0aGUgUkdCIGNvbXBvbmVudHMgaWYgbmVjZXNzYXJ5CiAgICBpZiAocmdiID09IG51bGwpIGNhbGN1bGF0ZVJHQigpOwoKICAgIC8vIHJldHVybiB0aGUgUkdCIGNvbXBvbmVudHMKICAgIHJldHVybiB7CiAgICAgICdyJyA6IHJnYi5yLAogICAgICAnZycgOiByZ2IuZywKICAgICAgJ2InIDogcmdiLmIsCiAgICAgICdhJyA6IGFscGhhCiAgICB9OwoKICB9OwoKICAvKiBSZXR1cm5zIHRoZSBIU1YgYW5kIGFscGhhIGNvbXBvbmVudHMgb2YgdGhpcyBIU0xDb2xvdXIgYXMgYW4gb2JqZWN0IHdpdGggaCwKICAgKiBzLCB2LCBhbmQgYSBwcm9wZXJ0aWVzLiBoIGlzIGluIHRoZSByYW5nZSBbMCwzNjApLCBzIGFuZCB2IGFyZSBpbiB0aGUgcmFuZ2UKICAgKiBbMCwxMDBdLCBhbmQgYSBpcyBpbiB0aGUgcmFuZ2UgWzAsMV0uCiAgICovCiAgdGhpcy5nZXRIU1YgPSBmdW5jdGlvbigpewoKICAgIC8vIGNhbGN1bGF0ZSB0aGUgSFNWIGNvbXBvbmVudHMgaWYgbmVjZXNzYXJ5CiAgICBpZiAoaHN2ID09IG51bGwpIGNhbGN1bGF0ZUhTVigpOwoKICAgIC8vIHJldHVybiB0aGUgSFNWIGNvbXBvbmVudHMKICAgIHJldHVybiB7CiAgICAgICdoJyA6IGhzdi5oLAogICAgICAncycgOiBoc3YucywKICAgICAgJ3YnIDogaHN2LnYsCiAgICAgICdhJyA6IGFscGhhCiAgICB9OwoKICB9OwoKICAvKiBSZXR1cm5zIHRoZSBIU0wgYW5kIGFscGhhIGNvbXBvbmVudHMgb2YgdGhpcyBIU0xDb2xvdXIgYXMgYW4gb2JqZWN0IHdpdGggaCwKICAgKiBzLCBsLCBhbmQgYSBwcm9wZXJ0aWVzLiBoIGlzIGluIHRoZSByYW5nZSBbMCwzNjApLCBzIGFuZCBsIGFyZSBpbiB0aGUgcmFuZ2UKICAgKiBbMCwxMDBdLCBhbmQgYSBpcyBpbiB0aGUgcmFuZ2UgWzAsMV0uCiAgICovCiAgdGhpcy5nZXRIU0wgPSBmdW5jdGlvbigpewoKICAgIC8vIHJldHVybiB0aGUgSFNMIGNvbXBvbmVudHMKICAgIHJldHVybiB7CiAgICAgICdoJyA6IGhzbC5oLAogICAgICAncycgOiBoc2wucywKICAgICAgJ2wnIDogaHNsLmwsCiAgICAgICdhJyA6IGFscGhhCiAgICB9OwoKICB9OwoKfQo=",
    "form": "data:text/html;base64,PGRpdiBpZD0id3JhcCI+CiAgICA8aDE+UGxlYXNlIGVudGVyIGEgbGl0dGxlIGluZm9ybWF0aW9uIGFib3V0IHlvdXJzZWxmIGludG8gdGhlIGJveGVzIGJlbG93LjwvaDE+CjxoNT4oQ2xpY2sgImNvbnRpbnVlIiB3aGVuIGNvbXBsZXRlKTwvaDU+Cgo8aDI+CjxwPllvdXIgYWdlIGlzPC9wPgo8L2gyPgoKCjxpbnB1dCBjbGFzcz0iSW5wdXRGaWVsZCIgZGF0YS12YWx1ZT0iZGF0YS5hZ2UiLz4KCgo8aDI+CjxwPllvdXIgZ2VuZGVyIGlzPC9wPgo8L2gyPgoKPGlucHV0IGlkPSJyYWRpb01hbGUiIHR5cGU9InJhZGlvIiBuYW1lPSJnZW5kZXIiIGRhdGEtY2hlY2tlZD0iZGF0YS5nZW5kZXIiIHZhbHVlPSJtYWxlIi8+CjxsYWJlbCBmb3I9InJhZGlvTWFsZSI+TWFsZTwvbGFiZWw+Cjxicj4KPGlucHV0IGlkPSJyYWRpb0ZlbWFsZSIgdHlwZT0icmFkaW8iIG5hbWU9ImdlbmRlciIgZGF0YS1jaGVja2VkPSJkYXRhLmdlbmRlciIgdmFsdWU9ImZlbWFsZSIvPgo8bGFiZWwgZm9yPSJyYWRpb0ZlbWFsZSI+RmVtYWxlPC9sYWJlbD4KPGJyPjxicj4KPGJ1dHRvbiBjbGFzcz0iUmVkQnV0dG9uIiBkYXRhLW9uLWNsaWNrPSJkYXRhLmRvbmUiPkNvbnRpbnVlPC9idXR0b24+CjwvZGl2Pg==",
    "blocksForm": "data:text/html;base64,CjxkaXYgaWQ9ImFkZFNoYXBlIj48YnV0dG9uIGNsYXNzPSJhZGRTaGFwZUJ1dHRvbiIgZGF0YS1zaG93PSJkYXRhLmNhbkFkZFNoYXBlIiBkYXRhLW9uLWNsaWNrPSJkYXRhLmFkZFNoYXBlIj5BZGQgc2hhcGUgdG8gZ2FsbGVyeTwvYnV0dG9uPgo8L2Rpdj4KCgo8ZGl2IGNsYXNzPSJpbmZvcyI+CjxoMj4KPHA+WW91IGhhdmUgPHNwYW4gZGF0YS10ZXh0PSJkYXRhLmdhbGxlcnlTaGFwZUNvdW50Ij48L3NwYW4+IHNoYXBlcyBpbiB5b3VyIGdhbGxlcnkuPC9wPgo8L2gyPgo8L2Rpdj4KCjxkaXYgaWQ9IndyYXBEb25lIgo8ZGl2IGlkPSJkb25lIiBkYXRhLXNob3c9ImRhdGEucmVhZHkiPgoKICAgICAgICA8YnV0dG9uIGNsYXNzPSJkb25lQnV0dG9uIiAgZGF0YS1vbi1jbGljaz0iZGF0YS5kb25lIj5DaG9vc2UgeW91ciBmYXZvcml0ZSBzaGFwZXM8L2J1dHRvbj4KPC9kaXY+CjwvZGl2PgogICAgCgoK",
    "formCss": "data:text/css;base64,I2dhbWVDb250ZW50IHsKCWNvbG9yOiB3aGl0ZTsKCWZvbnQtZmFtaWx5OiBBcmlhbDsKCWZvbnQtc2l6ZTogMjBweDsKfQoKI2dhbWVDb250ZW50IGlucHV0LCBidXR0b24gewoJY29sb3I6IGJsYWNrOwoJZm9udC1mYW1pbHk6IEFyaWFsOwoJZm9udC1zaXplOiAyMHB4Owp9Cgojd3JhcCB7CiAgICBtYXJnaW4tdG9wOiA1MHB4OyAgCiAgICBtYXJnaW4tYm90dG9tOiAxMDBweDsgIAogICAgbWFyZ2luLXJpZ2h0OiAxMjBweDsgIAogICAgbWFyZ2luLWxlZnQ6IDEyMHB4OyAgCn0KCi50aXRsZSB7CiAgICBjb2xvcjogZ3JlZW55ZWxsb3c7Cn0KCmgxewogICAgZm9udC1zaXplOiAxLjVlbTsKICAgIHRleHQtYWxpZ246IGNlbnRlcjsKfQoKaDJ7CiAgICBmb250LXNpemU6IDEuMGVtOwogICAgY29sb3I6Z3JlZW55ZWxsb3c7Cn0KCmgzewogICAgY29sb3I6IGdyZWVueWVsbG93OwogICAgdGV4dC1hbGlnbjogY2VudGVyOwogICAgZm9udC1zaXplOiAxLjVlbTsKfQpoNHsKICAgIGNvbG9yOiBncmVlbnllbGxvdzsKICAgIHRleHQtYWxpZ246IGNlbnRlcjsKICAgIGZvbnQtc2l6ZTogMWVtOwogICAKfQpoNXsKICAgIGZvbnQtc3R5bGU6IGl0YWxpYzsKICAgIHRleHQtYWxpZ246IGNlbnRlcjsKICAgIGNvbG9yOiBvcmFuZ2U7Cn0KCi5JbnB1dEZpZWxkewogICAgd2lkdGg6IDEwMHB4OwogICAgYm9yZGVyOiAycHggc29saWQgZ3JlZW55ZWxsb3c7CgogICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7CgogICAgcGFkZGluZy1sZWZ0OiAgMTBweDsKICAgIHBhZGRpbmctcmlnaHQ6IDEwcHg7CiAgICBwYWRkaW5nLXRvcDogM3B4OwogICAgcGFkZGluZy1ib3R0b206IDNweDsKfQoKLklucHV0RmllbGQ6aG92ZXIgewogICAgYm9yZGVyOiAycHggZG90dGVkIG9yYW5nZTsKfQoKaW5wdXQsIHNlbGVjdCwgSW5wdXRGaWVsZCB7CiAgICBjb2xvcjogcmVkOwp9CgouUmVkQnV0dG9uewogICAgYmFja2dyb3VuZC1jb2xvcjogYnJvd247CiAgICBib3JkZXI6IDJweCBzb2xpZCBvcmFuZ2U7CiAgICBjb2xvcjp3aGl0ZTsKfQoKLlJlZEJ1dHRvbjpob3ZlcnsKICAgIGJvcmRlcjogMnB4IGRvdHRlZCBvcmFuZ2U7IAp9CgouYWRkU2hhcGVCdXR0b24gewogICAgYmFja2dyb3VuZC1jb2xvcjogYnJvd247CiAgICBib3JkZXI6IDJweCBzb2xpZCBvcmFuZ2U7CiAgICBjb2xvcjp3aGl0ZTsKICAgIGZvbnQtc2l6ZTogMC43ZW07Cn0KLmFkZFNoYXBlQnV0dG9uOmhvdmVyewogICAgYm9yZGVyOiAycHggZG90dGVkIG9yYW5nZTsgCn0KCiNhZGRTaGFwZXsKICAgIGZsb2F0OiByaWdodDsKICAgIG1hcmdpbi10b3A6IDE2OHB4OwogICAgbWFyZ2luLXJpZ2h0OiAxMHB4OwogICAgCn0KCgouaW5mb3N7CiAgICBmbG9hdDogbm9uZTsKICAgIHRleHQtYWxpZ246IGNlbnRlcjsKICAgIG1hcmdpbi10b3A6IDQ2MHB4OwogICAgZm9udC1zaXplOiAwLjhlbTsKCiAgIAp9Cgojd3JhcERvbmV7CiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7CiAgICBtYXJnaW4tdG9wOiAwcHg7CiAgICBtYXJnaW4tbGVmdDogMHB4OwogICAKICAgCn0KCiNkb25lewogICB0ZXh0LWFsaWduOiBjZW50ZXI7Cn0KLmRvbmVCdXR0b257CiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBicm93bjsKICAgIGJvcmRlcjogMnB4IHNvbGlkIG9yYW5nZTsKICAgIGNvbG9yOndoaXRlOwogICAgZm9udC1zaXplOiAxZW07CiAgICBtYXJnaW4tdG9wOiAtNXB4OwoKCn0KCi5kb25lQnV0dG9uOmhvdmVyewogICAgYm9yZGVyOiAycHggZG90dGVkIG9yYW5nZTsgCn0KCiNwbGVhc2V7CiAgICBwYWRkaW5nLWxlZnQ6IDI4cHg7CiAgICBtYXJnaW4tdG9wOiAtNXB4Owp9CgojZG9uZTJ7CiAgICBtYXJnaW4tdG9wOiAzODBweDsKICAgIHRleHQtYWxpZ246IGNlbnRlcjsKfQojZG9uZTJCdXR0b257CiAgICBtYXJnaW4tdG9wOiAtMjBweDsKfQoKI3RoYW5rc1dyYXB7CiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7CiAgICBtYXJnaW4tdG9wOiAyMDBweDsKfQo=",
    "selectionForm": "data:text/html;base64,PGRpdiBpZD0icGxlYXNlIj4KICAgIDxoND48cD5QbGVhc2Ugc2VsZWN0IHlvdXIgZmF2b3JpdGUgc2hhcGVzIGJ5IGNsaWNraW5nIG9uIHRoZW0uPC9wPjwvaDQ+CjwvZGl2PgoKPGRpdiBpZD0iZG9uZTIiZGF0YS1zaG93PSJkYXRhLnJlYWR5Ij4KICAgIDxoND48cD5BcmUgeW91IGRvbmU/PC9wPjwvaDQ+CiAgICA8ZGl2IGlkPSJkb25lMkJ1dHRvbiI+Cgk8YnV0dG9uIGNsYXNzPSJSZWRCdXR0b24iIGRhdGEtb24tY2xpY2s9ImRhdGEuZG9uZSI+RG9uZTwvYnV0dG9uPgogICAgICAgIAogICAgPC9kaXY+CjwvZGl2Pgo=",
    "thanksForm": "data:text/html;base64,PGRpdiBpZD0idGhhbmtzV3JhcCI+CiAgICA8aDM+PHA+VGhhbmtzIGZvciBwbGF5aW5nITwvcD48L2gzPgoKPGJ1dHRvbiBjbGFzcz0iUmVkQnV0dG9uIiBkYXRhLW9uLWNsaWNrPSJkYXRhLmRvbmUiPlBsYXkgYWdhaW48L2J1dHRvbj4KPC9kaXY+"
  },
  "redMetricsConfig": {
    "host": "http://localhost:5050",
    "gameVersionId": "a82b1d89-e262-47f4-8150-af5a18e6271e"
  }
}