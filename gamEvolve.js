// Generated by CoffeeScript 1.3.3

/* 
  The algorithm is as follows:
    1. Get a static view of the model at the current time, and keep track of it
    2. Go though the layout from the top-down, recursively. For each:
      1. Check validity and error out otherwise
      2. Switch on block type:
        * If bind, execute query and store param bindings for lower items
        * If set, package with model bindings and add to execution list
        * If call, package with model bindings and add to execution list
        * If action: 
          1. Package with model bindings and add to execution list
          2. Run calculateActiveChildren() and continue with those recursively 
    3. For each active bound block:
      1. Run and gather output and error/success status
        * In case of error: Store error signal
        * In case of success: 
          1. Merge model changes with others. If conflict, nothing passes
          2. If DONE is signaled, store it
    4. Starting at parents of active leaf blocks:
      1. If signals are stored for children, call handleSignals() with them
      2. If more signals are created, store them for parents
*/


(function() {
  var GE, Model, NodeVisitorConstants, NodeVisitorResult, globals,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty;

  globals = this;

  GE = {};

  GE.makeConstantSet = function() {
    var obj, value, values, _i, _len;
    values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    obj = {
      contains: function(value) {
        return value in obj;
      }
    };
    for (_i = 0, _len = values.length; _i < _len; _i++) {
      value = values[_i];
      obj[value] = value;
    }
    return Object.freeze(obj);
  };

  GE.logLevels = GE.makeConstantSet("ERROR", "WARN", "INFO", "LOG");

  GE.Model = Model = (function() {

    function Model(data, previous) {
      if (data == null) {
        data = {};
      }
      this.previous = previous != null ? previous : null;
      this.data = GE.deepFreeze(GE.cloneData(data));
      this.version = this.previous != null ? this.previous.version + 1 : 0;
    }

    Model.prototype.setData = function(data) {
      return new Model(data, this);
    };

    Model.prototype.clonedData = function() {
      return GE.cloneData(this.data);
    };

    Model.prototype.atVersion = function(version) {
      var m;
      if (version > version) {
        throw new Error("Version not found");
      }
      m = this;
      while (m.version > version) {
        m = m.previous;
      }
      return m;
    };

    Model.prototype.makePatches = function(newData) {
      return GE.makePatches(this.data, newData);
    };

    Model.prototype.applyPatches = function(patches) {
      var newData;
      if (patches.length === 0) {
        return this;
      }
      if (GE.doPatchesConflict(patches)) {
        throw new Error("Patches conflict");
      }
      newData = GE.applyPatches(patches, this.data);
      return new Model(newData, this);
    };

    return Model;

  })();

  GE.logToConsole = function(type, message) {
    return window.console[logType.toLowerCase()](message);
  };

  GE.NodeVisitorConstants = NodeVisitorConstants = (function() {

    function NodeVisitorConstants(modelData, serviceData, assets, actions, log) {
      this.modelData = modelData;
      this.serviceData = serviceData;
      this.assets = assets;
      this.actions = actions;
      this.log = log != null ? log : GE.logToConsole;
    }

    return NodeVisitorConstants;

  })();

  GE.NodeVisitorResult = NodeVisitorResult = (function() {

    function NodeVisitorResult(result, modelPatches, servicePatches) {
      this.result = result != null ? result : null;
      this.modelPatches = modelPatches != null ? modelPatches : [];
      this.servicePatches = servicePatches != null ? servicePatches : [];
    }

    NodeVisitorResult.prototype.appendWith = function(other) {
      var newModelPatches, newServicePatches;
      newModelPatches = GE.concatenate(this.modelPatches, other.modelPatches);
      newServicePatches = GE.concatenate(this.servicePatches, other.servicePatches);
      return new NodeVisitorResult(this.result, newModelPatches, newServicePatches);
    };

    return NodeVisitorResult;

  })();

  GE.signals = GE.makeConstantSet("DONE", "ERROR");

  GE.extensions = {
    images: ["png", "gif", "jpeg", "jpg"],
    js: ["js"]
  };

  GE.cloneData = function(o) {
    return JSON.parse(JSON.stringify(o));
  };

  GE.isOnlyObject = function(o) {
    return _.isObject(o) && !_.isArray(o);
  };

  GE.concatenate = function() {
    var rest;
    rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return _.flatten(rest, true);
  };

  GE.getParentAndKey = function(parent, pathParts) {
    if (pathParts.length === 0) {
      return [parent, null];
    }
    if (pathParts.length === 1) {
      return [parent, pathParts[0]];
    }
    return GE.getParentAndKey(parent[pathParts[0]], _.rest(pathParts));
  };

  GE.makePatches = function(oldValue, newValue, prefix, patches) {
    var key, keys, _i, _len;
    if (prefix == null) {
      prefix = "";
    }
    if (patches == null) {
      patches = [];
    }
    if (_.isEqual(newValue, oldValue)) {
      return patches;
    }
    if (oldValue === void 0) {
      patches.push({
        add: prefix,
        value: GE.cloneData(newValue)
      });
    } else if (newValue === void 0) {
      patches.push({
        remove: prefix
      });
    } else if (!_.isObject(newValue) || !_.isObject(oldValue) || typeof oldValue !== typeof newValue) {
      patches.push({
        replace: prefix,
        value: GE.cloneData(newValue)
      });
    } else {
      keys = _.union(_.keys(oldValue), _.keys(newValue));
      for (_i = 0, _len = keys.length; _i < _len; _i++) {
        key = keys[_i];
        GE.makePatches(oldValue[key], newValue[key], "" + prefix + "/" + key, patches);
      }
    }
    return patches;
  };

  GE.applyPatches = function(patches, oldValue, prefix) {
    var key, parent, patch, splitPath, value, _i, _len, _ref, _ref1, _ref2;
    if (prefix == null) {
      prefix = "";
    }
    splitPath = function(path) {
      return _.rest(path.split("/"));
    };
    value = GE.cloneData(oldValue);
    for (_i = 0, _len = patches.length; _i < _len; _i++) {
      patch = patches[_i];
      if ("remove" in patch) {
        _ref = GE.getParentAndKey(value, splitPath(patch.remove)), parent = _ref[0], key = _ref[1];
        delete parent[key];
      } else if ("add" in patch) {
        _ref1 = GE.getParentAndKey(value, splitPath(patch.add)), parent = _ref1[0], key = _ref1[1];
        if (_.isArray(parent)) {
          parent.splice(key, 0, patch.value);
        } else {
          parent[key] = patch.value;
        }
      } else if ("replace" in patch) {
        _ref2 = GE.getParentAndKey(value, splitPath(patch.replace)), parent = _ref2[0], key = _ref2[1];
        if (!(key in parent)) {
          throw new Error("No existing value to replace for patch " + patch);
        }
        parent[key] = patch.value;
      }
    }
    return value;
  };

  GE.doPatchesConflict = function(patches) {
    var affectedKeys, key, patch, _i, _len;
    affectedKeys = {};
    for (_i = 0, _len = patches.length; _i < _len; _i++) {
      patch = patches[_i];
      key = patch.remove || patch.add || patch.replace;
      if (key in affectedKeys) {
        return true;
      }
      affectedKeys[key] = true;
    }
  };

  GE.sandboxActionCall = function(node, constants, bindings, methodName, signals) {
    var action, childNames, compiledParams, defaultValue, evaluatedParams, locals, methodResult, paramName, paramValue, result, value, _i, _ref, _ref1, _results;
    if (signals == null) {
      signals = {};
    }
    action = constants.actions[node.action];
    childNames = node.children != null ? (function() {
      _results = [];
      for (var _i = 0, _ref = node.children.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this) : [];
    compiledParams = {};
    evaluatedParams = {};
    _ref1 = action.paramDefs;
    for (paramName in _ref1) {
      defaultValue = _ref1[paramName];
      if (node.params && paramName in node.params) {
        paramValue = node.params[paramName];
      } else if (paramName in bindings) {
        paramValue = bindings[paramName];
      } else {
        paramValue = defaultValue;
      }
      compiledParams[paramName] = GE.compileParameter(paramValue, constants, bindings);
      value = compiledParams[paramName].get();
      try {
        evaluatedParams[paramName] = GE.cloneData(value);
      } catch (e) {
        evaluatedParams[paramName] = value;
      }
    }
    locals = {
      params: evaluatedParams,
      children: childNames,
      signals: signals,
      assets: constants.assets,
      log: constants.log
    };
    try {
      methodResult = action[methodName].apply(locals);
    } catch (e) {
      constants.log(GE.logLevels.ERROR, "Calling action " + node.action + "." + methodName + " raised an exception " + e);
    }
    result = new GE.NodeVisitorResult(methodResult);
    for (paramName in compiledParams) {
      paramValue = compiledParams[paramName];
      result = result.appendWith(paramValue.set(evaluatedParams[paramName]));
    }
    return result;
  };

  GE.calculateBindingSet = function(node, constants, oldBindings) {
    var bindingExpression, bindingIndex, bindingName, bindingSet, bindingValues, name, newBindings, value, _i, _ref, _ref1, _ref2, _ref3;
    bindingSet = [];
    if ("from" in node.bind) {
      _ref = node.bind.from;
      for (bindingName in _ref) {
        bindingExpression = _ref[bindingName];
        bindingValues = GE.compileParameter(bindingExpression, constants, oldBindings).get();
        for (bindingIndex = _i = 0, _ref1 = bindingValues.length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; bindingIndex = 0 <= _ref1 ? ++_i : --_i) {
          newBindings = Object.create(oldBindings);
          if (_.isString(bindingExpression)) {
            newBindings[bindingName] = "" + bindingExpression + "." + bindingIndex;
          } else {
            newBindings[bindingName] = bindingValues[bindingIndex];
          }
          _ref2 = node.select;
          for (name in _ref2) {
            value = _ref2[name];
            newBindings[name] = GE.compileParameter(value, constants, newBindings).get();
          }
          bindingSet.push(newBindings);
        }
      }
    } else {
      newBindings = Object.create(oldBindings);
      _ref3 = node.bind.select;
      for (name in _ref3) {
        value = _ref3[name];
        newBindings[name] = value;
      }
      bindingSet.push(newBindings);
    }
    return bindingSet;
  };

  GE.visitActionNode = function(node, constants, bindings) {
    var activeChildren, activeChildrenResult, child, childIndex, childResult, childSignals, errorResult, result, _i, _j, _len, _ref, _results;
    if (!(node.action in constants.actions)) {
      throw new Error("Cannot find action '" + node.action + "'");
    }
    if ("update" in constants.actions[node.action]) {
      result = GE.sandboxActionCall(node, constants, bindings, "update");
    } else {
      result = new GE.NodeVisitorResult();
    }
    if ("listActiveChildren" in constants.actions[node.action]) {
      activeChildrenResult = GE.sandboxActionCall(node, constants, bindings, "listActiveChildren");
      activeChildren = activeChildrenResult.result;
    } else {
      activeChildren = node.children != null ? (function() {
        _results = [];
        for (var _i = 0, _ref = node.children.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this) : [];
    }
    childSignals = [];
    for (_j = 0, _len = activeChildren.length; _j < _len; _j++) {
      childIndex = activeChildren[_j];
      child = node.children[childIndex];
      childResult = GE.visitNode(child, constants, bindings);
      childSignals[childIndex] = childResult.result;
      result = result.appendWith(childResult);
    }
    if ("handleSignals" in constants.actions[node.action]) {
      errorResult = GE.sandboxActionCall(node, constants, bindings, "handleSignals", childSignals);
      result.result = errorResult;
      result = result.appendWith(errorResult);
    }
    return result;
  };

  GE.visitCallNode = function(node, constants, bindings) {
    var compiledParams, evaluatedParams, param, parameter;
    compiledParams = (function() {
      var _i, _len, _ref, _results;
      _ref = node.params;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        parameter = _ref[_i];
        _results.push(GE.compileParameter(parameter, constants, bindings));
      }
      return _results;
    })();
    evaluatedParams = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = compiledParams.length; _i < _len; _i++) {
        param = compiledParams[_i];
        _results.push(param.get());
      }
      return _results;
    })();
    try {
      globals[node.call].apply({}, evaluatedParams);
    } catch (e) {
      constants.log(GE.logLevels.ERROR, "Calling function " + functionName + " raised an exception " + e);
    }
    return new GE.NodeVisitorResult();
  };

  GE.visitBindNode = function(node, constants, oldBindings) {
    var bindingSet, child, childResult, newBindings, result, _i, _j, _len, _len1, _ref;
    bindingSet = GE.calculateBindingSet(node, constants, oldBindings);
    result = new NodeVisitorResult();
    for (_i = 0, _len = bindingSet.length; _i < _len; _i++) {
      newBindings = bindingSet[_i];
      _ref = node.children || [];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        child = _ref[_j];
        childResult = GE.visitNode(child, constants, newBindings);
        result = result.appendWith(childResult);
      }
    }
    return result;
  };

  GE.visitSetModelNode = function(node, constants, bindings) {
    var evaluatedParam, name, result, value, _ref;
    result = new GE.NodeVisitorResult();
    _ref = node.setModel;
    for (name in _ref) {
      value = _ref[name];
      evaluatedParam = GE.compileParameter(value, constants, bindings).get();
      result = result.appendWith(GE.makeModelEvaluator(constants, name).set(evaluatedParam));
    }
    return result;
  };

  GE.nodeVisitors = {
    "action": GE.visitActionNode,
    "call": GE.visitCallNode,
    "bind": GE.visitBindNode,
    "setModel": GE.visitSetModelNode
  };

  GE.visitNode = function(node, constants, bindings) {
    var nodeType, visitor, _ref;
    if (bindings == null) {
      bindings = {};
    }
    _ref = GE.nodeVisitors;
    for (nodeType in _ref) {
      visitor = _ref[nodeType];
      if (nodeType in node) {
        return visitor(node, constants, bindings);
      }
    }
    constants.log(GE.logLevels.ERROR, "Layout item is not understood");
    return new NodeVisitorResult();
  };

  GE.stepLoop = function(node, modelData, assets, actions, services, log, inputServiceData, outputServiceData) {
    var modelPatches, result, service, serviceName;
    if (log == null) {
      log = null;
    }
    if (inputServiceData == null) {
      inputServiceData = null;
    }
    if (outputServiceData == null) {
      outputServiceData = null;
    }
    if (outputServiceData !== null) {
      modelPatches = [];
    } else {
      if (inputServiceData === null) {
        inputServiceData = {};
        for (serviceName in services) {
          service = services[serviceName];
          inputServiceData[serviceName] = service.provideData(assets);
        }
      }
      result = GE.visitNode(node, new GE.NodeVisitorConstants(modelData, inputServiceData, assets, actions, log));
      modelPatches = result.modelPatches;
      outputServiceData = GE.applyPatches(result.servicePatches, inputServiceData);
    }
    for (serviceName in services) {
      service = services[serviceName];
      service.establishData(outputServiceData[serviceName], assets);
    }
    return modelPatches;
  };

  GE.makeModelEvaluator = function(constants, name) {
    if (!(name != null)) {
      throw new Error("Model evaluator requires a name");
    }
    return {
      get: function() {
        var key, parent, _ref;
        _ref = GE.getParentAndKey(constants.modelData, name.split(".")), parent = _ref[0], key = _ref[1];
        return parent[key];
      },
      set: function(x) {
        var key, newData, parent, _ref;
        newData = GE.cloneData(constants.modelData);
        _ref = GE.getParentAndKey(newData, name.split(".")), parent = _ref[0], key = _ref[1];
        parent[key] = x;
        return new GE.NodeVisitorResult(null, GE.makePatches(constants.modelData, newData));
      }
    };
  };

  GE.makeServiceEvaluator = function(constants, name) {
    if (!(name != null)) {
      throw new Error("Service evaluator requires a name");
    }
    return {
      get: function() {
        var key, parent, _ref;
        _ref = GE.getParentAndKey(constants.serviceData, name.split(".")), parent = _ref[0], key = _ref[1];
        return GE.cloneData(parent[key]);
      },
      set: function(x) {
        var key, newData, parent, _ref;
        newData = GE.cloneData(constants.serviceData);
        _ref = GE.getParentAndKey(newData, name.split(".")), parent = _ref[0], key = _ref[1];
        parent[key] = x;
        return new GE.NodeVisitorResult(null, [], GE.makePatches(constants.serviceData, newData));
      }
    };
  };

  GE.makeAssetEvaluator = function(constants, name) {
    if (!(name != null)) {
      throw new Error("Asset evaluator requires a name");
    }
    return {
      get: function() {
        return constants.assets[name];
      },
      set: function(x) {
        return new GE.NodeVisitorResult();
      }
    };
  };

  GE.makeConstantEvaluator = function(constants, value) {
    return {
      get: function() {
        return value;
      },
      set: function() {
        return new GE.NodeVisitorResult();
      }
    };
  };

  GE.parameterEvaluators = {
    "model": GE.makeModelEvaluator,
    "asset": GE.makeAssetEvaluator,
    "service": GE.makeServiceEvaluator,
    "constant": GE.makeConstantEvaluator
  };

  GE.compileParameter = function(layoutParameter, constants, bindings) {
    var argument, bindingKey, endChar, matcherName, _ref;
    if (_.isString(layoutParameter) && layoutParameter.length > 0) {
      if (layoutParameter[0] === "$") {
        layoutParameter = layoutParameter.slice(1);
        endChar = layoutParameter.search(/\./);
        if (endChar === -1) {
          endChar = layoutParameter.length;
        }
        bindingKey = bindings[layoutParameter.slice(0, endChar)];
        if (_.isString(bindingKey)) {
          layoutParameter = "" + bindingKey + (layoutParameter.slice(endChar));
        } else {
          return GE.makeConstantEvaluator(constants, bindingKey);
        }
      }
      if (layoutParameter[0] === "@") {
        _ref = layoutParameter.slice(1).split(":"), matcherName = _ref[0], argument = _ref[1];
        if (!matcherName in GE.parameterEvaluators) {
          throw new Error("Cannot handle evaluator " + matcherName);
        }
        return GE.parameterEvaluators[matcherName](constants, argument);
      }
    }
    return GE.makeConstantEvaluator(constants, layoutParameter);
  };

  GE.loadAssets = function(assets, callback) {
    var extension, loadedCount, name, onError, onLoad, results, url;
    results = {};
    loadedCount = 0;
    onLoad = function() {
      if (++loadedCount === _.size(assets)) {
        return callback(null, results);
      }
    };
    onError = function() {
      return callback(new Error(arguments));
    };
    for (name in assets) {
      url = assets[name];
      extension = url.slice(url.lastIndexOf(".") + 1);
      if (__indexOf.call(GE.extensions.images, extension) >= 0) {
        results[name] = new Image();
        results[name].onload = onLoad;
        results[name].onabort = onError;
        results[name].onerror = onError;
        results[name].src = url + ("?_=" + (new Date().getTime()));
      } else if (__indexOf.call(GE.extensions.js, extension) >= 0) {
        $.ajax({
          url: url,
          dataType: "script",
          cache: false,
          success: onLoad,
          error: onError
        });
      } else {
        return callback(new Error("Do not know how to load " + url));
      }
    }
  };

  GE.doLater = function(f) {
    return setTimeout(f, 0);
  };

  GE.deepFreeze = function(o) {
    var key, prop;
    Object.freeze(o);
    for (key in o) {
      if (!__hasProp.call(o, key)) continue;
      prop = o[key];
      if (_.isObject(prop) && !Object.isFrozen(prop)) {
        GE.deepFreeze(prop);
      }
    }
    return o;
  };

  globals.GE = GE;

}).call(this);
