// Generated by CoffeeScript 1.6.2
/* 
  The algorithm is as follows:
    1. Get a static view of the model at the current time, and keep track of it
    2. Go though the layout from the top-down, recursively. For each:
      1. Check validity and error out otherwise
      2. Switch on block type:
        * If bind, execute query and store param bindings for lower items
        * If set, package with model bindings and add to execution list
        * If call, package with model bindings and add to execution list
        * If action: 
          1. Package with model bindings and add to execution list
          2. Run calculateActiveChildren() and continue with those recursively 
    3. For each active bound block:
      1. Run and gather output and error/success status
        * In case of error: Store error signal
        * In case of success: 
          1. Merge model changes with others. If conflict, nothing passes
          2. If DONE is signaled, store it
    4. Starting at parents of active leaf blocks:
      1. If signals are stored for children, call handleSignals() with them
      2. If more signals are created, store them for parents
*/


(function() {
  var GE, GameController, Model, globals, makeConstantSet,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  globals = this;

  makeConstantSet = function() {
    var obj, value, values, _i, _len;

    values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    obj = {};
    for (_i = 0, _len = values.length; _i < _len; _i++) {
      value = values[_i];
      obj[value] = value;
    }
    return Object.freeze(obj);
  };

  GE = {
    logLevels: makeConstantSet("ERROR", "WARN", "INFO", "LOG"),
    logger: {
      log: function(logType, message) {
        if (logLevels[logType]) {
          return console[logType](message);
        }
      }
    },
    Model: Model = (function() {
      function Model(data, previous) {
        if (data == null) {
          data = {};
        }
        this.previous = previous != null ? previous : null;
        this.data = GE.cloneData(data);
        this.version = this.previous != null ? this.previous.version + 1 : 0;
      }

      Model.prototype.setData = function(data) {
        return new Model(data, this);
      };

      Model.prototype.clonedData = function() {
        return GE.cloneData(this.data);
      };

      Model.prototype.atVersion = function(version) {
        var m;

        if (version > version) {
          throw new Error("Version not found");
        }
        m = this;
        while (m.version > version) {
          m = m.previous;
        }
        return m;
      };

      Model.prototype.makePatches = function(newData) {
        return GE.makePatches(this.data, newData);
      };

      Model.prototype.applyPatches = function(patches) {
        var newData;

        if (patches.length === 0) {
          return this;
        }
        if (GE.doPatchesConflict(patches)) {
          throw new Error("Patches conflict");
        }
        newData = GE.applyPatches(patches, this.data);
        return new Model(newData, this);
      };

      return Model;

    })(),
    signals: makeConstantSet("DONE", "ERROR"),
    extensions: {
      images: ["png", "gif", "jpeg", "jpg"],
      js: ["js"]
    },
    GameController: GameController = (function() {
      function GameController(model, assets, actions, layout) {
        this.model = model;
        this.assets = assets;
        this.actions = actions;
        this.layout = layout;
      }

      GameController.prototype.loadAssets = function(callback) {
        var _this = this;

        return GE.loadAssets(this.assets, function(err, loadedAssets) {
          if (err != null) {
            return callback(err);
          }
          _this.loadedAssets = loadedAssets;
          return callback(null);
        });
      };

      GameController.prototype.dryStep = function() {
        return GE.runStep(this.model, this.loadedAssets, this.actions, this.layout);
      };

      GameController.prototype.step = function() {
        var patches, result, _ref;

        _ref = GE.runStep(this.model, this.loadedAssets, this.actions, this.layout), result = _ref[0], patches = _ref[1];
        return this.model = this.model.applyPatches(patches);
      };

      return GameController;

    })(),
    makeConstantSet: makeConstantSet,
    cloneData: function(o) {
      return JSON.parse(JSON.stringify(o));
    },
    isOnlyObject: function(o) {
      return _.isObject(o) && !_.isArray(o);
    },
    getParentAndKey: function(parent, pathParts) {
      if (pathParts.length === 0) {
        return [parent, null];
      }
      if (pathParts.length === 1) {
        return [parent, pathParts[0]];
      }
      return GE.getParentAndKey(parent[pathParts[0]], _.rest(pathParts));
    },
    makePatches: function(oldValue, newValue, prefix, patches) {
      var key, keys, _i, _len;

      if (prefix == null) {
        prefix = "";
      }
      if (patches == null) {
        patches = [];
      }
      if (_.isEqual(newValue, oldValue)) {
        return patches;
      }
      if (oldValue === void 0) {
        patches.push({
          add: prefix,
          value: GE.cloneData(newValue)
        });
      } else if (newValue === void 0) {
        patches.push({
          remove: prefix
        });
      } else if (!_.isObject(newValue) || !_.isObject(oldValue) || typeof oldValue !== typeof newValue) {
        patches.push({
          replace: prefix,
          value: GE.cloneData(newValue)
        });
      } else {
        keys = _.union(_.keys(oldValue), _.keys(newValue));
        for (_i = 0, _len = keys.length; _i < _len; _i++) {
          key = keys[_i];
          GE.makePatches(oldValue[key], newValue[key], "" + prefix + "/" + key, patches);
        }
      }
      return patches;
    },
    applyPatches: function(patches, oldValue, prefix) {
      var key, parent, patch, splitPath, value, _i, _len, _ref, _ref1, _ref2;

      if (prefix == null) {
        prefix = "";
      }
      splitPath = function(path) {
        return _.rest(path.split("/"));
      };
      value = GE.cloneData(oldValue);
      for (_i = 0, _len = patches.length; _i < _len; _i++) {
        patch = patches[_i];
        if ("remove" in patch) {
          _ref = GE.getParentAndKey(value, splitPath(patch.remove)), parent = _ref[0], key = _ref[1];
          delete parent[key];
        } else if ("add" in patch) {
          _ref1 = GE.getParentAndKey(value, splitPath(patch.add)), parent = _ref1[0], key = _ref1[1];
          parent[key] = patch.value;
        } else if ("replace" in patch) {
          _ref2 = GE.getParentAndKey(value, splitPath(patch.replace)), parent = _ref2[0], key = _ref2[1];
          if (!(key in parent)) {
            throw new Error("No existing value to replace for patch " + patch);
          }
          parent[key] = patch.value;
        }
      }
      return value;
    },
    doPatchesConflict: function(patches) {
      var affectedKeys, key, patch, _i, _len;

      affectedKeys = {};
      for (_i = 0, _len = patches.length; _i < _len; _i++) {
        patch = patches[_i];
        key = patch.remove || patch.add || patch.replace;
        if (key in affectedKeys) {
          return true;
        }
        affectedKeys[key] = true;
      }
    },
    sandboxFunctionCall: function(model, assets, bindings, functionName, parameters) {
      var compiledParams, e, evaluatedParams, modelData, param, parameter;

      modelData = model.clonedData();
      compiledParams = (function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = parameters.length; _i < _len; _i++) {
          parameter = parameters[_i];
          _results.push(GE.compileParameter(modelData, assets, bindings, parameter));
        }
        return _results;
      })();
      evaluatedParams = (function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = compiledParams.length; _i < _len; _i++) {
          param = compiledParams[_i];
          _results.push(param.get());
        }
        return _results;
      })();
      try {
        return globals[functionName].apply({}, evaluatedParams);
      } catch (_error) {
        e = _error;
        return GE.logger.log(GE.logLevels.WARN, "Calling function " + functionName + " raised an exception " + e);
      }
    },
    sandboxActionCall: function(model, assets, bindings, actions, actionName, methodName, layoutParameters, childNames, signals) {
      var action, compiledParams, defaultValue, e, evaluatedParams, locals, modelData, paramName, paramValue, result, _ref;

      action = actions[actionName];
      modelData = model.clonedData();
      compiledParams = {};
      evaluatedParams = {};
      _ref = action.paramDefs;
      for (paramName in _ref) {
        defaultValue = _ref[paramName];
        if (layoutParameters && paramName in layoutParameters) {
          paramValue = layoutParameters[paramName];
        } else if (paramName in bindings) {
          paramValue = bindings[paramName];
        } else {
          paramValue = defaultValue;
        }
        compiledParams[paramName] = GE.compileParameter(modelData, assets, bindings, paramValue);
        evaluatedParams[paramName] = compiledParams[paramName].get();
      }
      locals = {
        params: evaluatedParams,
        children: childNames,
        signals: signals,
        assets: assets
      };
      try {
        result = action[methodName].apply(locals);
      } catch (_error) {
        e = _error;
        GE.logger.log(GE.logLevels.WARN, "Calling action " + action + "." + methodName + " raised an exception " + e);
      }
      for (paramName in compiledParams) {
        paramValue = compiledParams[paramName];
        paramValue.set(evaluatedParams[paramName]);
      }
      return [result, model.makePatches(modelData)];
    },
    calculateBindingSet: function(modelData, assets, oldBindings, bindingLayout) {
      var bindingExpression, bindingIndex, bindingName, bindingSet, bindingValues, name, newBindings, value, _i, _ref, _ref1, _ref2, _ref3;

      bindingSet = [];
      if ("from" in bindingLayout) {
        _ref = bindingLayout.from;
        for (bindingName in _ref) {
          bindingExpression = _ref[bindingName];
          bindingValues = GE.compileParameter(modelData, assets, oldBindings, bindingExpression).get();
          for (bindingIndex = _i = 0, _ref1 = bindingValues.length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; bindingIndex = 0 <= _ref1 ? ++_i : --_i) {
            newBindings = Object.create(oldBindings);
            if (_.isString(bindingExpression)) {
              newBindings[bindingName] = "" + bindingExpression + "." + bindingIndex;
            } else {
              newBindings[bindingName] = bindingValues[bindingIndex];
            }
            _ref2 = bindingLayout.select;
            for (name in _ref2) {
              value = _ref2[name];
              newBindings[name] = GE.compileParameter(modelData, assets, newBindings, value).get();
            }
            bindingSet.push(newBindings);
          }
        }
      } else {
        newBindings = Object.create(oldBindings);
        _ref3 = bindingLayout.select;
        for (name in _ref3) {
          value = _ref3[name];
          newBindings[name] = value;
        }
        bindingSet.push(newBindings);
      }
      return bindingSet;
    },
    handleSetModel: function(model, assets, bindings, setModelLayout) {
      var evaluatedParam, modelData, name, value;

      modelData = model.clonedData();
      for (name in setModelLayout) {
        value = setModelLayout[name];
        evaluatedParam = GE.compileParameter(modelData, assets, bindings, value).get();
        GE.makeModelEvaluator(modelData, name).set(evaluatedParam);
      }
      return model.makePatches(modelData);
    },
    runStep: function(model, assets, actions, layout, bindings) {
      var actionPatches, activeChildren, bindingSet, child, childIndex, childNames, childPatches, childSignals, newBindings, patches, result, setModelPatches, __, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _results;

      if (bindings == null) {
        bindings = {};
      }
      patches = [];
      result = void 0;
      if ("action" in layout) {
        if (!(layout.action in actions)) {
          throw new Error("Cannot find action '" + layout.action + "'");
        }
        childNames = layout.children != null ? (function() {
          _results = [];
          for (var _i = 0, _ref = layout.children.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this) : [];
        if ("update" in actions[layout.action]) {
          _ref1 = GE.sandboxActionCall(model, assets, bindings, actions, layout.action, "update", layout.params, childNames), result = _ref1[0], actionPatches = _ref1[1];
          patches.push.apply(patches, actionPatches);
        }
        if ("listActiveChildren" in actions[layout.action]) {
          _ref2 = GE.sandboxActionCall(model, assets, bindings, actions, layout.action, "listActiveChildren", layout.params, childNames), activeChildren = _ref2[0], __ = _ref2[1];
        } else {
          activeChildren = childNames;
        }
        childSignals = [];
        for (_j = 0, _len = activeChildren.length; _j < _len; _j++) {
          childIndex = activeChildren[_j];
          child = layout.children[childIndex];
          _ref3 = GE.runStep(model, assets, actions, child, bindings), childSignals[childIndex] = _ref3[0], childPatches = _ref3[1];
          patches.push.apply(patches, childPatches);
        }
        if ("handleSignals" in actions[layout.action]) {
          _ref4 = GE.sandboxActionCall(model, assets, bindings, actions, layout.action, "handleSignals", layout.params, childNames, childSignals), result = _ref4[0], actionPatches = _ref4[1];
          patches.push.apply(patches, actionPatches);
        }
      } else if ("call" in layout) {
        GE.sandboxFunctionCall(model, assets, bindings, layout.call, layout.params, bindings);
      } else if ("bind" in layout) {
        bindingSet = GE.calculateBindingSet(model.data, assets, bindings, layout.bind);
        for (_k = 0, _len1 = bindingSet.length; _k < _len1; _k++) {
          newBindings = bindingSet[_k];
          _ref5 = layout.children || [];
          for (_l = 0, _len2 = _ref5.length; _l < _len2; _l++) {
            child = _ref5[_l];
            _ref6 = GE.runStep(model, assets, actions, child, newBindings), __ = _ref6[0], childPatches = _ref6[1];
            patches.push.apply(patches, childPatches);
          }
        }
      } else if ("setModel" in layout) {
        setModelPatches = GE.handleSetModel(model, assets, bindings, layout.setModel);
        patches.push.apply(patches, setModelPatches);
      } else {
        GE.logError("Layout item is not understood");
      }
      return [result, patches];
    },
    makeModelEvaluator: function(modelData, name) {
      var key, parent, _ref;

      if (name == null) {
        throw new Error("Model evaluator requires a name");
      }
      _ref = GE.getParentAndKey(modelData, name.split(".")), parent = _ref[0], key = _ref[1];
      return {
        get: function() {
          return parent[key];
        },
        set: function(x) {
          return parent[key] = x;
        }
      };
    },
    makeAssetEvaluator: function(assets, name) {
      if (name == null) {
        throw new Error("Asset evaluator requires a name");
      }
      return {
        get: function() {
          return assets[name];
        },
        set: function(x) {}
      };
    },
    makeConstantEvaluator: function(value) {
      return {
        get: function() {
          return value;
        },
        set: function() {}
      };
    },
    compileParameter: function(modelData, assets, bindings, layoutParameter) {
      var argument, bindingKey, endChar, matcherName, _ref;

      if (_.isString(layoutParameter) && layoutParameter.length > 0) {
        if (layoutParameter[0] === "$") {
          layoutParameter = layoutParameter.slice(1);
          endChar = layoutParameter.search(/\./);
          if (endChar === -1) {
            endChar = layoutParameter.length;
          }
          bindingKey = bindings[layoutParameter.slice(0, endChar)];
          if (_.isString(bindingKey)) {
            layoutParameter = "" + bindingKey + (layoutParameter.slice(endChar));
          } else {
            return GE.makeConstantEvaluator(bindingKey);
          }
        }
        if (layoutParameter[0] === "@") {
          _ref = layoutParameter.slice(1).split(":"), matcherName = _ref[0], argument = _ref[1];
          switch (matcherName) {
            case "model":
              return GE.makeModelEvaluator(modelData, argument);
            case "asset":
              return GE.makeAssetEvaluator(assets, argument);
            default:
              throw new Error("Cannot handle evaluator " + matcherName);
          }
        }
      }
      return GE.makeConstantEvaluator(layoutParameter);
    },
    loadAssets: function(assets, callback) {
      var extension, loadedCount, name, onError, onLoad, results, url;

      results = {};
      loadedCount = 0;
      onLoad = function() {
        if (++loadedCount === _.size(assets)) {
          return callback(null, results);
        }
      };
      onError = function() {
        return callback(new Error(arguments));
      };
      for (name in assets) {
        url = assets[name];
        extension = url.slice(url.lastIndexOf(".") + 1);
        if (__indexOf.call(GE.extensions.images, extension) >= 0) {
          results[name] = new Image();
          results[name].onload = onLoad;
          results[name].onabort = onError;
          results[name].onerror = onError;
          results[name].src = url + ("?_=" + (new Date().getTime()));
        } else if (__indexOf.call(GE.extensions.js, extension) >= 0) {
          $.ajax({
            url: url,
            dataType: "script",
            cache: false,
            success: onLoad,
            error: onError
          });
        } else {
          return callback(new Error("Do not know how to load " + url));
        }
      }
    },
    doLater: function(f) {
      return setTimeout(f, 0);
    }
  };

  globals.GE = GE;

}).call(this);
