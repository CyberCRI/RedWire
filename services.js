// Generated by CoffeeScript 1.6.3
(function() {
  registerService('Keyboard', function(options) {
    var eventNamespace, keysDown;
    if (options == null) {
      options = {};
    }
    eventNamespace = _.uniqueId('keyboard');
    keysDown = {};
    $(options.elementSelector).on("keydown." + eventNamespace + " keyup." + eventNamespace + " focusout." + eventNamespace, "canvas", function(event) {
      event.preventDefault();
      switch (event.type) {
        case 'keydown':
          return keysDown[event.which] = true;
        case 'keyup':
          return delete keysDown[event.which];
        case 'focusout':
          return keysDown = {};
        default:
          throw new Error('Unexpected event type');
      }
    });
    return {
      provideData: function() {
        return {
          'keysDown': keysDown
        };
      },
      establishData: function() {},
      destroy: function() {
        return $(options.elementSelector).off("." + eventNamespace);
      }
    };
  });

  registerService('Mouse', function(options) {
    var eventNamespace, mouse;
    if (options == null) {
      options = {};
    }
    eventNamespace = _.uniqueId('mouse');
    mouse = {
      down: false,
      position: null,
      cursor: null
    };
    $(options.elementSelector).on("selectstart." + eventNamespace, function() {
      return false;
    });
    $(options.elementSelector).on("mousedown." + eventNamespace + " mouseup." + eventNamespace + " mousemove." + eventNamespace + " mouseleave." + eventNamespace, "canvas", function(event) {
      var rect, target;
      switch (event.type) {
        case 'mousedown':
          return mouse.down = true;
        case 'mouseup':
          return mouse.down = false;
        case 'mousemove':
          rect = event.target.getBoundingClientRect();
          target = $(event.target);
          return mouse.position = [Math.floor((event.clientX - rect.left) * target.attr("width") / rect.width), Math.floor((event.clientY - rect.top) * target.attr("height") / rect.height)];
      }
    });
    return {
      provideData: function() {
        return mouse;
      },
      establishData: function(data) {
        return $(options.elementSelector).css("cursor", data.cursor || "");
      },
      destroy: function() {
        return $(options.elementSelector).off("." + eventNamespace);
      }
    };
  });

  registerService('Canvas', function(options) {
    var CANVAS_CSS, createLayers, drawShape, handleTransformations, interpretStyle, layers, orderForShape, shapeSorter;
    if (options == null) {
      options = {};
    }
    CANVAS_CSS = "position: absolute; left: 0px; top: 0px;";
    createLayers = function() {
      var createdLayers, layer, layerName, zIndex, _i, _len, _ref;
      createdLayers = {};
      zIndex = 0;
      _ref = options.layers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layerName = _ref[_i];
        layer = $("<canvas id='canvasLayer-" + layerName + "' class='gameCanvas' width='" + options.size[0] + "' height='" + options.size[1] + "' tabIndex=0 style='z-index: " + zIndex + "; " + CANVAS_CSS + "' />");
        $(options.elementSelector).append(layer);
        createdLayers[layerName] = layer;
        zIndex++;
      }
      return createdLayers;
    };
    orderForShape = function(shape) {
      return shape.order || 0;
    };
    shapeSorter = function(a, b) {
      return orderForShape(a) - orderForShape(b);
    };
    interpretStyle = function(style, ctx) {
      var colorStop, grad, _i, _j, _len, _len1, _ref, _ref1;
      if (_.isString(style)) {
        return style;
      }
      if (!_.isObject(style)) {
        throw new Error('Style must be string or object');
      }
      switch (style.type) {
        case 'radialGradient':
          grad = ctx.createRadialGradient(style.start.position[0], style.start.position[1], style.start.radius, style.end.position[0], style.end.position[1], style.end.radius);
          _ref = style.colorStops;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            colorStop = _ref[_i];
            grad.addColorStop(colorStop.position, colorStop.color);
          }
          return grad;
        case 'linearGradient':
          grad = ctx.createLinearGradient(style.startPosition[0], style.startPosition[1], style.endPosition[0], style.endPosition[1]);
          _ref1 = style.colorStops;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            colorStop = _ref1[_j];
            grad.addColorStop(colorStop.position, colorStop.color);
          }
          return grad;
        default:
          throw new Error('Unknown or missing style type');
      }
    };
    handleTransformations = function(shape, ctx) {
      if (shape.translation) {
        ctx.translate(shape.translation[0], shape.translation[1]);
      }
      if (shape.rotation) {
        ctx.rotate(shape.rotation * Math.PI / 180);
      }
      if (shape.scale) {
        if (_.isArray(shape.scale)) {
          return ctx.scale(shape.scale[0], shape.scale[1]);
        } else if (_.isNumber(shape.scale)) {
          return ctx.scale(shape.scale, shape.scale);
        } else {
          throw new Error('Scale argument must be number or array');
        }
      }
    };
    drawShape = function(shape, ctx, assets) {
      var point, text, _i, _len, _ref;
      ctx.save();
      handleTransformations(shape, ctx);
      if (shape.composition) {
        ctx.globalCompositeOperation = shape.composition;
      }
      if (shape.alpha) {
        ctx.globalAlpha = shape.alpha;
      }
      switch (shape.type) {
        case 'rectangle':
          if (shape.fillStyle) {
            ctx.fillStyle = interpretStyle(shape.fillStyle, ctx);
            ctx.fillRect(shape.position[0], shape.position[1], shape.size[0], shape.size[1]);
          }
          if (shape.strokeStyle) {
            ctx.strokeStyle = interpretStyle(shape.strokeStyle, ctx);
            if (shape.lineWidth) {
              ctx.lineWidth = shape.lineWidth;
            }
            ctx.strokeRect(shape.position[0], shape.position[1], shape.size[0], shape.size[1]);
          }
          break;
        case 'image':
          ctx.drawImage(assets[shape.asset], shape.position[0], shape.position[1]);
          break;
        case 'text':
          text = _.isString(shape.text) && shape.text || JSON.stringify(shape.text);
          ctx.font = shape.font;
          ctx.textAlign = shape.align;
          if (shape.fillStyle) {
            ctx.fillStyle = interpretStyle(shape.fillStyle, ctx);
            ctx.fillText(text, shape.position[0], shape.position[1]);
          }
          if (shape.strokeStyle) {
            ctx.strokeStyle = interpretStyle(shape.strokeStyle, ctx);
            ctx.strokeText(text, shape.position[0], shape.position[1]);
          }
          break;
        case 'path':
          ctx.beginPath();
          ctx.moveTo(shape.points[0][0], shape.points[0][1]);
          _ref = shape.points.slice(1);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            point = _ref[_i];
            ctx.lineTo(point[0], point[1]);
          }
          if (shape.fillStyle) {
            ctx.fillStyle = interpretStyle(shape.fillStyle, ctx);
            ctx.fill();
          }
          if (shape.strokeStyle) {
            ctx.strokeStyle = interpretStyle(shape.strokeStyle, ctx);
            if (shape.lineWidth) {
              ctx.lineWidth = shape.lineWidth;
            }
            if (shape.lineCap) {
              ctx.lineCap = shape.lineCap;
            }
            if (shape.lineJoin) {
              ctx.lineJoin = shape.lineJoin;
            }
            if (shape.miterLimit) {
              ctx.miterLimit = shape.miterLimit;
            }
            ctx.stroke();
          }
          break;
        case 'circle':
          ctx.moveTo(shape.position[0], shape.position[1]);
          ctx.arc(shape.position[0], shape.position[1], shape.radius, 0, 2 * Math.PI);
          if (shape.fillStyle) {
            ctx.fillStyle = interpretStyle(shape.fillStyle, ctx);
            ctx.fill();
          }
          if (shape.strokeStyle) {
            ctx.strokeStyle = interpretStyle(shape.strokeStyle, ctx);
            if (shape.lineWidth) {
              ctx.lineWidth = shape.lineWidth;
            }
            ctx.stroke();
          }
          break;
        default:
          throw new Error('Unknown or missing shape type');
      }
      return ctx.restore();
    };
    options = _.defaults(options, {
      layers: ['default']
    });
    layers = createLayers();
    return {
      provideData: function() {
        return {
          layers: options.layers,
          size: options.size,
          shapes: {}
        };
      },
      establishData: function(data, config, assets) {
        var canvas, ctx, id, layerName, shape, shapeArray, shapeArrays, _ref, _results;
        if (!data.shapes) {
          return;
        }
        shapeArrays = {};
        for (layerName in layers) {
          canvas = layers[layerName];
          canvas[0].getContext('2d').clearRect(0, 0, options.size[0], options.size[1]);
          shapeArrays[layerName] = [];
        }
        _ref = data.shapes;
        for (id in _ref) {
          shape = _ref[id];
          layerName = shape.layer || 'default';
          if (!(layerName in layers)) {
            throw new Error('No layer for shape');
          }
          shapeArrays[layerName].push(shape);
        }
        _results = [];
        for (layerName in shapeArrays) {
          shapeArray = shapeArrays[layerName];
          shapeArray.sort(shapeSorter);
          ctx = layers[layerName][0].getContext('2d');
          _results.push((function() {
            var _i, _len, _results1;
            _results1 = [];
            for (_i = 0, _len = shapeArray.length; _i < _len; _i++) {
              shape = shapeArray[_i];
              _results1.push(drawShape(shape, ctx, assets));
            }
            return _results1;
          })());
        }
        return _results;
      },
      destroy: function() {
        var canvas, layerName, _results;
        _results = [];
        for (layerName in layers) {
          canvas = layers[layerName];
          _results.push(canvas.remove());
        }
        return _results;
      }
    };
  });

  registerService('HTML', function(options) {
    var callbacks, layers, templates, views;
    if (options == null) {
      options = {};
    }
    templates = {};
    layers = {};
    views = {};
    callbacks = {};
    rivets.configure({
      handler: function(target, event, binding) {
        return templates[binding.view.models.data]["values"][binding.keypath] = true;
      },
      adapter: {
        subscribe: function(templateName, keypath, callback) {
          return callbacks[templateName][keypath] = callback;
        },
        unsubscribe: function(templateName, keypath, callback) {
          return delete callbacks[templateName][keypath];
        },
        read: function(templateName, keypath) {
          return templates[templateName]["values"][keypath];
        },
        publish: function(templateName, keypath, value) {
          return templates[templateName]["values"][keypath] = value;
        }
      }
    });
    return {
      provideData: function() {
        return {
          receive: templates,
          send: {}
        };
      },
      establishData: function(data, config, assets) {
        var binding, existingTemplates, newTemplateData, newTemplates, outerWrapper, templateHtml, templateName, view, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
        newTemplateData = data.send;
        existingTemplates = _.keys(templates);
        newTemplates = _.keys(newTemplateData);
        _ref = _.difference(existingTemplates, newTemplates);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          templateName = _ref[_i];
          delete templates[templateName];
          layers[templateName].remove();
          delete layers[templateName];
          views[templateName].unbind();
          delete views[templateName];
          delete callbacks[templateName];
        }
        _ref1 = _.difference(newTemplates, existingTemplates);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          templateName = _ref1[_j];
          templateHtml = assets[newTemplateData[templateName].asset];
          outerWrapper = $("<div id='html-" + templateName + "' style='position: absolute; z-index: 100; pointer-events: none; width: " + options.size[0] + "; height: " + options.size[1] + "'/>");
          outerWrapper.append(templateHtml);
          $(options.elementSelector).append(outerWrapper);
          layers[templateName] = outerWrapper;
          templates[templateName] = newTemplateData[templateName];
          callbacks[templateName] = {};
          views[templateName] = rivets.bind(outerWrapper[0], {
            data: templateName
          });
        }
        _ref2 = _.intersection(newTemplates, existingTemplates);
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          templateName = _ref2[_k];
          if (!_.isEqual(newTemplateData[templateName].values, templates[templateName].values)) {
            templates[templateName].values = newTemplateData[templateName].values;
            views[templateName].sync();
          }
        }
        _results = [];
        for (templateName in views) {
          view = views[templateName];
          _results.push((function() {
            var _l, _len3, _ref3, _results1;
            _ref3 = view.bindings;
            _results1 = [];
            for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
              binding = _ref3[_l];
              if (binding.type.indexOf("on-") === 0) {
                _results1.push(templates[templateName]["values"][binding.keypath] = false);
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          })());
        }
        return _results;
      },
      destroy: function() {
        var layer, templateName, view, _results;
        for (templateName in views) {
          view = views[templateName];
          view.unbind();
        }
        _results = [];
        for (templateName in layers) {
          layer = layers[templateName];
          _results.push(layer.remove());
        }
        return _results;
      }
    };
  });

  registerService('Time', function() {
    return {
      provideData: function() {
        return Date.now();
      },
      establishData: function() {},
      destroy: function() {}
    };
  });

  registerService('Http', function() {
    var state;
    state = {
      requests: {},
      responses: {}
    };
    return {
      provideData: function() {
        return state;
      },
      establishData: function(serviceData, config, assets) {
        var requestName, _fn, _i, _j, _len, _len1, _ref, _ref1;
        _ref = _.difference(_.keys(serviceData.requests), _.keys(state.requests));
        _fn = function(requestName) {
          var jqXhr, _ref1, _ref2;
          jqXhr = $.ajax({
            url: serviceData.requests[requestName].url,
            type: (_ref1 = serviceData.requests[requestName].method) != null ? _ref1 : "GET",
            cache: (_ref2 = serviceData.requests[requestName].cache) != null ? _ref2 : true,
            data: serviceData.requests[requestName].data,
            contentType: serviceData.requests[requestName].contentType
          });
          jqXhr.done(function(data, textStatus) {
            return state.responses[requestName] = {
              status: textStatus,
              data: data
            };
          });
          jqXhr.fail(function(__, textStatus, errorThrown) {
            return state.responses[requestName] = {
              status: textStatus,
              error: errorThrown
            };
          });
          return delete state.requests[requestName];
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          requestName = _ref[_i];
          _fn(requestName);
        }
        _ref1 = _.difference(_.keys(state.responses), _.keys(serviceData.responses));
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          requestName = _ref1[_j];
          delete state.responses[requestName];
        }
        return state;
      },
      destroy: function() {}
    };
  });

}).call(this);
