// Generated by CoffeeScript 1.6.2
(function() {
  registerService('Keyboard', function(options) {
    var eventNamespace, keysDown;

    if (options == null) {
      options = {};
    }
    options = _.defaults(options, {
      elementSelector: '#gameContent'
    });
    eventNamespace = _.uniqueId('keyboard');
    keysDown = {};
    $(options.elementSelector).on("keydown." + eventNamespace + " keyup." + eventNamespace + " focusout." + eventNamespace, function(event) {
      event.preventDefault();
      switch (event.type) {
        case 'keydown':
          return keysDown[event.which] = true;
        case 'keyup':
          return delete keysDown[event.which];
        case 'focusout':
          return keysDown = {};
        default:
          throw new Error('Unexpected event type');
      }
    });
    return {
      provideData: function() {
        return {
          'keysDown': keysDown
        };
      },
      establishData: function() {},
      destroy: function() {
        return $(options.elementSelector).off("." + eventNamespace);
      }
    };
  });

  registerService('Mouse', function(options) {
    var eventNamespace, mouse;

    if (options == null) {
      options = {};
    }
    options = _.defaults(options, {
      elementSelector: '#gameContent'
    });
    eventNamespace = _.uniqueId('mouse');
    mouse = {
      down: false,
      position: null,
      cursor: null
    };
    $(options.elementSelector).on("selectstart." + eventNamespace, function() {
      return false;
    });
    $(options.elementSelector).on("mousedown." + eventNamespace + " mouseup." + eventNamespace + " mousemove." + eventNamespace + " mouseleave." + eventNamespace, function(event) {
      var rect, target;

      switch (event.type) {
        case 'mousedown':
          return mouse.down = true;
        case 'mouseup':
          return mouse.down = false;
        case 'mouseleave':
          mouse.down = false;
          return mouse.position = null;
        case 'mousemove':
          rect = event.target.getBoundingClientRect();
          target = $(event.target);
          return mouse.position = {
            x: Math.floor((event.clientX - rect.left) * target.attr("width") / rect.width),
            y: Math.floor((event.clientY - rect.top) * target.attr("height") / rect.height)
          };
        default:
          throw new Error('Unexpected event type');
      }
    });
    return {
      provideData: function() {
        return mouse;
      },
      establishData: function(data) {
        return $(options.elementSelector).css("cursor", data.cursor || "");
      },
      destroy: function() {
        return $(options.elementSelector).off("." + eventNamespace);
      }
    };
  });

  registerService('Canvas', function(options) {
    var CANVAS_CSS, createLayers, drawShape, handleTransformations, interpretStyle, layers, orderForShape, shapeSorter;

    if (options == null) {
      options = {};
    }
    CANVAS_CSS = "height: 100%; position: absolute; left: 0px; top: 0px;";
    createLayers = function() {
      var createdLayers, layer, layerName, zIndex, _i, _len, _ref;

      createdLayers = {};
      zIndex = 0;
      _ref = options.layers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layerName = _ref[_i];
        layer = $("<canvas id='canvasLayer-" + layerName + "' class='gameCanvas' width='" + options.size[0] + "' height='" + options.size[1] + "' tabIndex='0' style='z-index: " + zIndex + "; " + CANVAS_CSS + "' />");
        $('#gameContent').append(layer);
        createdLayers[layerName] = layer;
      }
      return createdLayers;
    };
    orderForShape = function(shape) {
      return shape.order || 0;
    };
    shapeSorter = function(a, b) {
      return orderForShape(a) - orderForShape(b);
    };
    interpretStyle = function(style, ctx) {
      var colorStop, grad, _i, _j, _len, _len1, _ref, _ref1;

      if (_.isString(style)) {
        return style;
      }
      if (!_.isObject(style)) {
        throw new Error('Style must be string or object');
      }
      switch (style.type) {
        case 'radialGradient':
          grad = ctx.createRadialGradient(style.start.position[0], style.start.position[1], style.start.radius, style.end.position[0], style.end.position[1], style.end.radius);
          _ref = style.colorStops;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            colorStop = _ref[_i];
            grad.addColorStop(colorStop.position, colorStop.color);
          }
          return grad;
        case 'linearGradient':
          grad = ctx.createLinearGradient(style.startPosition[0], style.startPosition[1], style.endPosition[0], style.endPosition[1]);
          _ref1 = style.colorStops;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            colorStop = _ref1[_j];
            grad.addColorStop(colorStop.position, colorStop.color);
          }
          return grad;
        default:
          throw new Error('Unknown or missing style type');
      }
    };
    handleTransformations = function(shape, ctx) {
      if (shape.translation) {
        ctx.translate(shape.translation[0], shape.translation[1]);
      }
      if (shape.rotation) {
        ctx.rotate(shape.rotation * Math.PI / 180);
      }
      if (shape.scale) {
        if (_.isArray(shape.scale)) {
          return ctx.scale(shape.scale[0], shape.scale[1]);
        } else if (_.isNumber(shape.scale)) {
          return ctx.scale(shape.scale, shape.scale);
        } else {
          throw new Error('Scale argument must be number or array');
        }
      }
    };
    drawShape = function(shape, ctx, assets) {
      var point, text, _i, _len, _ref;

      ctx.save();
      handleTransformations(shape, ctx);
      if (shape.composition) {
        ctx.globalCompositeOperation = shape.composition;
      }
      if (shape.alpha) {
        ctx.globalAlpha = shape.alpha;
      }
      switch (shape.type) {
        case 'rectangle':
          if (shape.fillStyle) {
            ctx.fillStyle = interpretStyle(shape.fillStyle, ctx);
            ctx.fillRect(shape.position[0], shape.position[1], shape.size[0], shape.size[1]);
          }
          if (shape.strokeStyle) {
            ctx.strokeStyle = interpretStyle(shape.strokeStyle, ctx);
            if (shape.lineWidth) {
              ctx.lineWidth = shape.lineWidth;
            }
            ctx.strokeRect(shape.position[0], shape.position[1], shape.size[0], shape.size[1]);
          }
          break;
        case 'image':
          ctx.drawImage(assets[shape.asset], shape.position[0], shape.position[1]);
          break;
        case 'text':
          text = _.isString(shape.text) && shape.text || JSON.stringify(shape.text);
          ctx.font = shape.font;
          ctx.textAlign = shape.align;
          if (shape.fillStyle) {
            ctx.fillStyle = interpretStyle(shape.fillStyle, ctx);
            ctx.fillText(text, shape.position[0], shape.position[1]);
          }
          if (shape.strokeStyle) {
            ctx.strokeStyle = interpretStyle(shape.strokeStyle, ctx);
            ctx.strokeText(text, shape.position[0], shape.position[1]);
          }
          break;
        case 'path':
          ctx.beginPath();
          ctx.moveTo(shape.points[0][0], shape.points[0][1]);
          _ref = shape.points.slice(1);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            point = _ref[_i];
            ctx.lineTo(point[0], point[1]);
          }
          if (shape.fillStyle) {
            ctx.fillStyle = interpretStyle(shape.fillStyle, ctx);
            ctx.fill();
          }
          if (shape.strokeStyle) {
            ctx.strokeStyle = interpretStyle(shape.strokeStyle, ctx);
            if (shape.lineWidth) {
              ctx.lineWidth = shape.lineWidth;
            }
            if (shape.lineCap) {
              ctx.lineCap = shape.lineCap;
            }
            if (shape.lineJoin) {
              ctx.lineJoin = shape.lineJoin;
            }
            if (shape.miterLimit) {
              ctx.miterLimit = shape.miterLimit;
            }
            ctx.stroke();
          }
          break;
        case 'circle':
          ctx.moveTo(shape.position[0], shape.position[1]);
          ctx.arc(shape.position[0], shape.position[1], shape.radius, 0, 2 * Math.PI);
          if (shape.fillStyle) {
            ctx.fillStyle = interpretStyle(shape.fillStyle, ctx);
            ctx.fill();
          }
          if (shape.strokeStyle) {
            ctx.strokeStyle = interpretStyle(shape.strokeStyle, ctx);
            ctx.stroke();
          }
          break;
        default:
          throw new Error('Unknown or missing shape type');
      }
      return ctx.restore();
    };
    options = _.defaults(options, {
      layers: ['default'],
      size: [960, 540]
    });
    layers = createLayers();
    return {
      provideData: function() {
        return {
          layers: options.layers,
          size: options.size,
          shapes: {}
        };
      },
      establishData: function(data, assets) {
        var canvas, ctx, id, layerName, shape, shapeArray, shapeArrays, _ref, _results;

        if (!data.shapes) {
          return;
        }
        shapeArrays = {};
        for (layerName in layers) {
          canvas = layers[layerName];
          canvas[0].getContext('2d').clearRect(0, 0, options.size[0], options.size[1]);
          shapeArrays[layerName] = [];
        }
        _ref = data.shapes;
        for (id in _ref) {
          shape = _ref[id];
          layerName = shape.layer || 'default';
          if (!(layerName in layers)) {
            throw new Error('No layer for shape');
          }
          shapeArrays[layerName].push(shape);
        }
        _results = [];
        for (layerName in shapeArrays) {
          shapeArray = shapeArrays[layerName];
          shapeArray.sort(shapeSorter);
          ctx = layers[layerName][0].getContext('2d');
          _results.push((function() {
            var _i, _len, _results1;

            _results1 = [];
            for (_i = 0, _len = shapeArray.length; _i < _len; _i++) {
              shape = shapeArray[_i];
              _results1.push(drawShape(shape, ctx, assets));
            }
            return _results1;
          })());
        }
        return _results;
      },
      destroy: function() {
        var canvas, layerName, _results;

        _results = [];
        for (layerName in layers) {
          canvas = layers[layerName];
          _results.push(canvas.remove());
        }
        return _results;
      }
    };
  });

}).call(this);
